var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Everything that is not exported is considered internal.","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.union_typeof","category":"page"},{"location":"manual/internals/#PAndQ.union_typeof","page":"Internals","title":"PAndQ.union_typeof","text":"union_typeof(xs)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.FoldDirection\nPAndQ.Left\nPAndQ.Right\nPAndQ.fold_direction","category":"page"},{"location":"manual/internals/#PAndQ.FoldDirection","page":"Internals","title":"PAndQ.FoldDirection","text":"FoldDirection\n\nA trait to indicate which direction to fold an operator.\n\nSupertype of Left and Right.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Left","page":"Internals","title":"PAndQ.Left","text":"Left <: FoldDirection\n\nA trait to indicate that an operator should fold left.\n\nSubtype of FoldDirection.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Right","page":"Internals","title":"PAndQ.Right","text":"Right <: FoldDirection\n\nA trait to indicate that an operator should fold right.\n\nSubtype of FoldDirection.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.fold_direction","page":"Internals","title":"PAndQ.fold_direction","text":"fold_direction(operator)\n\nReturn the FoldDirection of the given operator.\n\nIf the operator has no FoldDirection, return nothing.\n\njulia> PAndQ.fold_direction(→)\nPAndQ.Left()\n\njulia> PAndQ.fold_direction(←)\nPAndQ.Right()\n\njulia> PAndQ.fold_direction(⊼)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Union-Types","page":"Internals","title":"Union Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.NaryOperator\nPAndQ.Operator\nPAndQ.AndOr","category":"page"},{"location":"manual/internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of Nullary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of Unary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of Binary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.NaryOperator","page":"Internals","title":"PAndQ.NaryOperator","text":"NaryOperator\n\nThe Union of Nary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Operator","page":"Internals","title":"PAndQ.Operator","text":"Operator\n\nThe Union of Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.value_exception\nPAndQ.simplify_clause","category":"page"},{"location":"manual/internals/#PAndQ.value_exception","page":"Internals","title":"PAndQ.value_exception","text":"value_exception\n\n\n\n\n\n","category":"constant"},{"location":"manual/internals/#PAndQ.simplify_clause","page":"Internals","title":"PAndQ.simplify_clause","text":"simplify_clause(p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"import AbstractTrees: children # hide\nusing AbstractTrees: print_tree # hide\nusing InteractiveUtils: subtypes # hide\nusing PAndQ: Proposition # hide\n\nchildren(x::Type) = subtypes(x) # hide\nprint_tree(Proposition) # hide","category":"page"},{"location":"manual/internals/#Abstract","page":"Internals","title":"Abstract","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Proposition\nPAndQ.Atom\nPAndQ.Compound","category":"page"},{"location":"manual/internals/#PAndQ.Proposition","page":"Internals","title":"PAndQ.Proposition","text":"Proposition\n\nA proposition.\n\nSupertype of Atom and Compound.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Atom","page":"Internals","title":"PAndQ.Atom","text":"Atom <: Proposition\n\nA proposition with no deeper propositional structure.\n\nSubtype of Proposition. Supertype of Constant and Variable.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Compound","page":"Internals","title":"PAndQ.Compound","text":"Compound <: Proposition\n\nA proposition composed from connecting Atoms with one or more Operators.\n\nSubtype of Proposition. Supertype of Tree, Clause, and Normal.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Concrete","page":"Internals","title":"Concrete","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Constant\nPAndQ.Variable\nPAndQ.Tree\nPAndQ.Literal\nPAndQ.Clause\nPAndQ.Normal","category":"page"},{"location":"manual/internals/#PAndQ.Constant","page":"Internals","title":"PAndQ.Constant","text":"Constant{T} <: Atom\nConstant(::T)\n\nAn atomic sentence.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Constant(1)\n$(1)\n\njulia> PAndQ.Constant(\"Logic is fun\")\n$(\"Logic is fun\")\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Variable","page":"Internals","title":"PAndQ.Variable","text":"Variable <: Atom\n\nAn atomic formula.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Variable(:p)\np\n\njulia> PAndQ.Variable(:q)\nq\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Tree","page":"Internals","title":"PAndQ.Tree","text":"Tree{O <: Operator, AT <: Union{Atom, Tree}, N} <: Compound\nTree(::NullaryOperator, ::Atom)\nTree(::Operator, ::Tree...)\nTree(::Proposition)\n\nA Proposition represented by an abstract syntax tree.\n\nSubtype of Compound. See also Atom, NullaryOperator, and Operator.\n\nExamples\n\njulia> PAndQ.Tree(⊤)\n⊤\n\njulia> @atomize PAndQ.Tree(¬, p)\n¬p\n\njulia> @atomize PAndQ.Tree(and, PAndQ.Tree(p), PAndQ.Tree(q))\np ∧ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Literal","page":"Internals","title":"PAndQ.Literal","text":"Literal <: Tree{<:Operator, <:Atom, 1}\n\nA proposition represented by an atomic formula or its negation.\n\nSee also Operator, Atom, and Tree.\n\nExamples\n\njulia> @atomize PAndQ.Literal(𝒾, p)\np\n\njulia> @atomize PAndQ.Literal(¬, p)\n¬p\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Clause","page":"Internals","title":"PAndQ.Clause","text":"Clause{AO <: AndOr, A <: AbstractVector{<:Atom}, L <: AbstractVector{Int}} <: Compound\nClause(::AO, ::A, ::L)\n\nA proposition represented as either a conjunction or disjunction of literals.\n\ninfo: Info\nAn empty Clause is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Atom, Literal, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Clause(∧, PAndQ.Atom[], Int[])\n⊤\n\njulia> @atomize PAndQ.Clause(∧, [p], [1])\np\n\njulia> @atomize PAndQ.Clause(∨, [p, q], [1, -2])\np ∨ ¬q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Normal","page":"Internals","title":"PAndQ.Normal","text":"Normal{AO <: AndOr, A <: AbstractVector{<:Atom}, C <: AbstractVector{<:AbstractVector{Int}}} <: Compound\nNormal(::AO, ::A, ::C)\n\nA Proposition represented in conjunctive or disjunctive normal form.\n\ninfo: Info\nAn empty Normal is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Clause, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Normal(∧, PAndQ.Atom[], Vector{Int}[])\n⊤\n\njulia> @atomize PAndQ.Normal(∧, [p, q], [[1, 2], [-1, -2]])\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.jl","page":"Internals","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.children\nPAndQ.nodevalue\nPAndQ.printnode\nPAndQ.NodeType\nPAndQ.nodetype","category":"page"},{"location":"manual/internals/#AbstractTrees.children","page":"Internals","title":"AbstractTrees.children","text":"children(::Proposition)\n\nReturn an iterator over the child nodes of the given Proposition.\n\nExamples\n\njulia> @atomize PAndQ.children(p)\n()\n\njulia> @atomize PAndQ.children(¬p)\n(PAndQ.Variable(:p),)\n\njulia> @atomize PAndQ.children(p ∧ q)\n(PAndQ.Variable(:p), PAndQ.Variable(:q))\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.nodevalue","page":"Internals","title":"AbstractTrees.nodevalue","text":"nodevalue(::Union{Tree{O}, Clause{O}, Normal{O}}) where O\n\nReturn O.instance.\n\nSee also Compound.\n\nExamples\n\njulia> @atomize PAndQ.nodevalue(¬p)\nnot (generic function with 6 methods)\n\njulia> @atomize PAndQ.nodevalue(p ∧ q)\nand (generic function with 11 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.printnode","page":"Internals","title":"AbstractTrees.printnode","text":"printnode(::IO, ::Union{NullaryOperator, Proposition}; kwargs...)\n\nSee also Proposition.\n\nExamples\n\njulia> @atomize PAndQ.printnode(stdout, p)\np\njulia> @atomize PAndQ.printnode(stdout, ¬p)\n¬\njulia> @atomize PAndQ.printnode(stdout, p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.NodeType","page":"Internals","title":"AbstractTrees.NodeType","text":"NodeType(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.nodetype","page":"Internals","title":"AbstractTrees.nodetype","text":"nodetype(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.child\nPAndQ.atomize\nPAndQ.negated_normal\nPAndQ.distribute\nPAndQ.flatten!","category":"page"},{"location":"manual/internals/#PAndQ.child","page":"Internals","title":"PAndQ.child","text":"child(x)\n\nEquivalent to only ∘ children\n\nSee also children.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.atomize","page":"Internals","title":"PAndQ.atomize","text":"atomize(x)\n\nIf x is a symbol, return an expression that instantiates it as a Variable if it is undefined in the caller's scope. If isexpr(x, :$), return an expression that instantiates it as a Constant. If x is a different expression, traverse it with recursive calls to atomize. Otherise, return x.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.negated_normal","page":"Internals","title":"PAndQ.negated_normal","text":"negated_normal(p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.distribute","page":"Internals","title":"PAndQ.distribute","text":"distribute(p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.flatten!","page":"Internals","title":"PAndQ.flatten!","text":"flatten!(p, clauses)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.symbol_of\nPAndQ.parenthesize\nPAndQ.print_node\nPAndQ.show_atom\nPAndQ.base_type","category":"page"},{"location":"manual/internals/#PAndQ.symbol_of","page":"Internals","title":"PAndQ.symbol_of","text":"symbol_of(::Operator)\n\nReturn the Unicode symbol of the given Operator.\n\nExamples\n\njulia> PAndQ.symbol_of(⊤)\n:⊤\n\njulia> PAndQ.symbol_of(¬)\n:¬\n\njulia> PAndQ.symbol_of(∧)\n:∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.parenthesize","page":"Internals","title":"PAndQ.parenthesize","text":"parenthesize(io, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.print_node","page":"Internals","title":"PAndQ.print_node","text":"print_node(io, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.show_atom","page":"Internals","title":"PAndQ.show_atom","text":"show_atom(::IO, ::Atom)\n\nSee also Atom.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.base_type","page":"Internals","title":"PAndQ.base_type","text":"base_type(::Union{<:Type{<:Proposition}}, Proposition)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.IteratorSize\nPAndQ.neutral_operator\nPAndQ.eval_doubles\nPAndQ.combine\nPAndQ.negated_normal_template\nconvert(::Type{PAndQ.Atom}, ::PAndQ.Literal{typeof(𝒾)})","category":"page"},{"location":"manual/internals/#Base.IteratorSize","page":"Internals","title":"Base.IteratorSize","text":"IteratorSize(::Type{PicoSolIterator})\n\nPatch a bug in PicoSAT.jl\n\nwarning: Warning\nThis method commits type piracy. Remove it after the PR to fix the bug has been released.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.neutral_operator","page":"Internals","title":"PAndQ.neutral_operator","text":"neutral_operator(::NullaryOperator)\n\nReturn one of AndOr that is the neutral element of the given NullaryOperator.\n\nExamples\n\njulia> PAndQ.neutral_operator(⊤)\nand (generic function with 11 methods)\n\njulia> PAndQ.neutral_operator(⊥)\nor (generic function with 9 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.eval_doubles","page":"Internals","title":"PAndQ.eval_doubles","text":"eval_doubles(f, doubles)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.combine","page":"Internals","title":"PAndQ.combine","text":"combine(p, q)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.negated_normal_template","page":"Internals","title":"PAndQ.negated_normal_template","text":"negated_normal_template(left, right)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.convert-Tuple{Type{PAndQ.Atom}, PAndQ.Tree{typeof(identity), <:PAndQ.Atom, 1}}","page":"Internals","title":"Base.convert","text":"convert(::Type{<:Proposition}, p)\n\nSee also Proposition.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"This tutorial will demonstrate how to solve a Sudoku puzzle by encoding the rules sudoku into propositional logic. Although it is more computationally efficient to frame Sudoku as an optimization problem, it is a good example of a non-trivial logic problem.","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Grid","page":"Sudoku","title":"Creating a Grid","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is traditionally played on a 9x9 grid. Such a grid can be created using the pretty_table function.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"using PAndQ\nlines = collect(0:3:9);\ngrid = zeros(Int, 9, 9);\nprint_grid(grid) = pretty_table(\n    map(cell -> cell == 0 ? \"⋅\" : string(cell), grid);\n    vlines = lines, hlines = lines, show_header = false\n);\nprint_grid(grid)","category":"page"},{"location":"tutorials/sudoku/#Encoding-the-Rules","page":"Sudoku","title":"Encoding the Rules","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The grid is currently empty. Placing random numbers in some of the cells has a very high probability of generating an unsolvable board. Knowing which numbers to place in each cell requires the same functionality that it takes to solve the board in the first place. Encoding the rules of Sudoku into a proposition means that any solution to that proposition can be decoded into a solution of Sudoku.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given the predicate P(row, column, value) is true when the given row and column of the grid contains the given value:","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"p(row, column, value) = @atomize $((row, column) => value);","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"1. Each row contains each number from 1 to 9. This proposition can be read as \"for each row and for each value, one of the cells in that row contains that value\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_n = 1^9 bigveelimits_j = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"one = map_reducers((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do i, n, j\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"2. Each column contains each number from 1 to 9. This proposition can be read as \"for each column and for each value, one of the cells of that column contains that value\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^9 bigveelimits_i = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"two = map_reducers((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do j, n, i\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"3. Each 3x3 subgrid contains each number from 1 to 9. This proposition can be read as \"for each 3x3 subgrid and for each value, one of the cells of that subgrid contains that value\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_r = 0^2 bigwedgelimits_c = 0^2 bigwedgelimits_n = 1^9 bigveelimits_i = 1^3 bigveelimits_j = 1^3 P(3r + i 3c + j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"three = map_reducers(\n    (∧) => 0:2, (∧) => 0:2, (∧) => 1:9, (∨) => 1:3, (∨) => 1:3\n) do r, c, n, i, j\n    p(3r + i, 3c + j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"4. Each cell contains a single number. This proposition can be read as \"for each cell and for pair of unique values, that cell does not contain both values\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^8 bigwedgelimits_m = n + 1^9 P(i j n)  P(i j m)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"four = map_reducers((∧) => 1:9, (∧) => 1:9, (∧) => 1:8) do i, j, n\n    map_reducers((∧) => n + 1:9) do m\n        ¬p(i, j, n) ∨ ¬p(i, j, m)\n    end\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The conjunction of these rules represent the encoding.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"rules = ⋀((one, two, three, four));","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"note: Note\nThe backend solver requires that propositions are given in conjunctive normal form. Although there are several ways to encode the rules of Sudoku into a proposition, these rules are constructed in such a way that it is more computationally efficient to convert the syntax tree representation to a normalized internal representation. Since the syntax tree is already in conjunctive normal form, converting the representation does not require computationally expensive operator distribution.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"note: Note\nSee also @atomize, map_reducers, and, and or.","category":"page"},{"location":"tutorials/sudoku/#Finding-a-Solution","page":"Sudoku","title":"Finding a Solution","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given a proposition, valuations that result in a true interpretation can be found using the solutions function. Since the encoding does not specify any initial values of the cells, there will be many possible solutions to the proposition. Each solution contains 729 assignments of a Constants to a Bool, which makes sense because the 9x9 grid has 81 cells and each cell contains one of 9 possible values.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"first_solution(p) = collect(first(solutions(p)));\nsolution = first_solution(rules)","category":"page"},{"location":"tutorials/sudoku/#Decoding-the-Solution","page":"Sudoku","title":"Decoding the Solution","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The assignments from a Constant to true correspond to cells that contain the given values. There are 81 such constants, corresponding to each cell in the grid. Each cell contains a Pair in the form (row, column) => value, which maps from the row and column of the grid to that cell's value. Each pair can be extracted with the value function, then placed into the grid.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"extract(solution) = map(value ∘ first, filter(last, solution));\ncells = extract(solution)\nfunction decode!(grid, cells)\n    for ((row, column), value) in cells\n        grid[row, column] = value\n    end\n\n    grid\nend;\nprint_grid(decode!(grid, cells))","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Puzzle","page":"Sudoku","title":"Creating a Puzzle","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now that a solution has been found, it can be used to create a puzzle.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"grid .*= rand(Bool, 9, 9);\nprint_grid(grid)","category":"page"},{"location":"tutorials/sudoku/#Solving-a-Puzzle","page":"Sudoku","title":"Solving a Puzzle","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Since rules represents an empty Sudoku grid, finding a solution to this puzzle means encoding the initial values as additional rules and finding a solution to the combined ruleset. If a grid has no solutions, then it contains a contradiction to the rules.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"puzzle = rules ∧ ⋀(map(filter(i -> grid[i] != 0, CartesianIndices(grid))) do i\n    p(i.I..., grid[i])\nend);\nprint_grid(decode!(grid, extract(first_solution(puzzle))))","category":"page"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/#Markdown","page":"Extensions","title":"Markdown","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"pretty_table(::Type{Markdown.MD}, ::TruthTable)","category":"page"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{Markdown.MD}, TruthTable}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Type{Markdown.MD},\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    alignment = :l\n)\n\nSee also Nullary Operators, Proposition, TruthTable, and formatter.\n\nExamples\n\njulia> @atomize pretty_table(Markdown.MD, p ∧ q)\n  p q p ∧ q\n  – – –––––\n  ⊤ ⊤ ⊤\n  ⊥ ⊤ ⊥\n  ⊤ ⊥ ⊥\n  ⊥ ⊥ ⊥\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#Latexify","page":"Extensions","title":"Latexify","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nA @latexrecipe has been defined for Operators, Proposition, and TruthTable.","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"formatter(::Type{Latexify.LaTeXString})\npretty_table(::Type{Latexify.LaTeXString}, ::Union{PAndQ.Proposition, TruthTable})","category":"page"},{"location":"manual/extensions/#PAndQ.formatter-Tuple{Type{LaTeXStrings.LaTeXString}}","page":"Extensions","title":"PAndQ.formatter","text":"formatter(::Latexify.LaTeXString)\n\nExamples\n\njulia> formatter(Latexify.LaTeXString)(true, nothing, nothing)\nL\"$\\top$\"\n\njulia> formatter(Latexify.LaTeXString)(false, nothing, nothing)\nL\"$\\bot$\"\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Latexify.LaTeXString))\n┌─────────┬─────────┬─────────┐\n│ p       │ q       │ p ∧ q   │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\top$ │ $\\\\top$ │\n│ $\\\\bot$ │ $\\\\top$ │ $\\\\bot$ │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\bot$ │ $\\\\bot$ │\n│ $\\\\bot$ │ $\\\\bot$ │ $\\\\bot$ │\n└─────────┴─────────┴─────────┘\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{LaTeXStrings.LaTeXString}, Union{PAndQ.Proposition, TruthTable}}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Latexify.LaTexString,\n    x::Union{Proposition, TruthTable};\n    backend = Val(:latex),\n    kwargs...\n)\n\nEquivalent to Latexify.LaTeXString(pretty_table(String, x; backend, kwargs...)).\n\nSee also Proposition and TruthTable.\n\nExamples\n\njulia> pretty_table(Latexify.LaTeXString, @atomize p ∧ q)\nL\"\\begin{tabular}{|l|l|l|}\n  \\hline\n  \\textbf{$p$} & \\textbf{$q$} & \\textbf{$p \\wedge q$} \\\\\\hline\n  $\\top$ & $\\top$ & $\\top$ \\\\\n  $\\bot$ & $\\top$ & $\\bot$ \\\\\\hline\n  $\\top$ & $\\bot$ & $\\bot$ \\\\\n  $\\bot$ & $\\bot$ & $\\bot$ \\\\\\hline\n\\end{tabular}\n\"\n\n\n\n\n\n","category":"method"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/#Truths","page":"Semantics","title":"Truths","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"valuations\nmap\ninterpret\ninterpretations\nsolutions","category":"page"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuations(atoms)\nvaluations(::Union{NullaryOperator, Proposition})\n\nReturn an iterator of every possible valuation.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> collect(valuations(⊤))\n0-dimensional Array{Vector{Union{}}, 0}:\n[]\n\njulia> @atomize collect(valuations(p))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n [PAndQ.Variable(:p) => 0]\n\njulia> @atomize collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.Variable, Bool}}}:\n [Variable(:p)=>1, Variable(:q)=>1]  [Variable(:p)=>1, Variable(:q)=>0]\n [Variable(:p)=>0, Variable(:q)=>1]  [Variable(:p)=>0, Variable(:q)=>0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.map","page":"Semantics","title":"Base.map","text":"map(::Function, ::Union{NullaryOperator, Proposition})\n\nApply the given function to each Atom in the given argument.\n\nAlternatively, propositions are callable with the function as an argument.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize map(atom -> ⊤, p ⊻ q)\n⊤ ⊻ ⊤\n\njulia> @atomize map(atom -> $(value(atom) + 1), $1 ∧ $2)\n$(2) ∧ $(3)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(valuation, p)\n\nSubstitute each Atom in the given Proposition with values from the valuation.\n\nThe valuation can be a Function with the signature valuation(::Atom)::Union{Bool, NullaryOperator, Proposition}, a Dict, or an iterable that can construct a Dict. No substitution is performed if an Atom from the Proposition is not one of the dictionary's keys.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize interpret(p -> true, ¬p)\nfalse\n\njulia> @atomize interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(valuations, p)\ninterpretations(p)\n\nReturn an iterator of truth values given by interpreting p with each valuation in valuations.\n\nExamples\n\njulia> collect(interpretations(⊤))\n0-dimensional Array{Bool, 0}:\n1\n\njulia> @atomize collect(interpretations(p))\n2-element Vector{Bool}:\n 1\n 0\n\njulia> @atomize collect(interpretations(p ∧ q))\n2×2 Matrix{Bool}:\n 1  0\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solutions","page":"Semantics","title":"PAndQ.solutions","text":"solutions(p)\n\nReturn an iterator containing valuations such that interpret(valuation, p) == ⊤.\n\nTo find every valuation that results in a true interpretation, convert the proposition to conjunctive normal form using normalize. Otherwise, a subset of those valuations will be identified using the tseytin transformation.\n\nSee also interpret and tautology.\n\nExamples\n\njulia> map(collect, solutions(⊤))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n []\n\njulia> @atomize map(collect, solutions(p))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n\njulia> map(collect, solutions(⊥))\nVector{Pair{PAndQ.Variable, Bool}}[]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Predicates","page":"Semantics","title":"Predicates","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"is_commutative\nis_associative\nis_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable\nis_equisatisfiable","category":"page"},{"location":"manual/semantics/#PAndQ.is_commutative","page":"Semantics","title":"PAndQ.is_commutative","text":"is_commutative(binary_operator)\n\nReturn a boolean indicating whether the given binary operator has the commutative property.\n\nExamples\n\njulia> is_commutative(∧)\ntrue\n\njulia> is_commutative(→)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_associative","page":"Semantics","title":"PAndQ.is_associative","text":"is_associative(binary_operator)\n\nReturn a boolean indicating whether the given binary operator has the associative property.\n\nExamples\n\njulia> is_associative(∧)\ntrue\n\njulia> is_associative(→)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturn a boolean indicating whether the given proposition is logically equivalent to a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @atomize is_tautology(p)\nfalse\n\njulia> @atomize is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturn a boolean indicating whether the given proposition is logically equivalent to a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @atomize is_contradiction(p)\nfalse\n\njulia> @atomize is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturn a boolean indicating whether given proposition is logically equivalent to a nullary operator.\n\nSee also Proposition.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @atomize is_truth(p ∧ ¬p)\ntrue\n\njulia> @atomize is_truth(p)\nfalse\n\njulia> @atomize is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturn a boolean indicating whether p is a contingency (not logically equivalent to a nullary operator).\n\nSee also Proposition.\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @atomize is_contingency(p ∧ ¬p)\nfalse\n\njulia> @atomize is_contingency(p)\ntrue\n\njulia> @atomize is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturn a boolean indicating whether p is satisfiable (not logically equivalent to a contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @atomize is_satisfiable(p)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturns a boolean indicating whether p is falsifiable (not logica equivalent to a tautology).\n\nSee also Proposition.\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @atomize is_falsifiable(p ∨ ¬p)\nfalse\n\njulia> @atomize is_falsifiable(p)\ntrue\n\njulia> @atomize is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_equisatisfiable","page":"Semantics","title":"PAndQ.is_equisatisfiable","text":"is_equisatisfiable(p, q)\n\nReturn a boolean indicating whether the predicate is_satisfiable is congruent for both propositions.\n\nExamples\n\njulia> is_equisatisfiable(⊤, ⊥)\nfalse\n\njulia> @atomize is_equisatisfiable(p, q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Ordering","page":"Semantics","title":"Ordering","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Propositions and their truth values have a strict partial order. The truth values tautology and contradiction are the top and bottom of this order, respectively. A proposition that satisfies the predicate is_tautology or is_contradiction is also at the top or bottom of the order, respectively. Propositions that satisfy the predicate is_contingency occupy the middle of this order. More specifically, ⊥ <= p <= ⊤ for some proposition p. The ordering is partial because the predicates == and is_truth may both be false for two given propositions.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"note: Note\nThe implementations for == and < also define the semantics of isequal, >, <=, and >=. This does not define the semantics of isless, which is used for total orders.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"warning: Warning\nThe assumption that isequal(p, q) implies hash(p) == hash(q) is currently being violated. The implementation of hash for propositions is in-progress.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"==\n<","category":"page"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"==(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\np == q\n\nReturn a boolean indicating whether p and q are logically equivalent.\n\nConstants are equivalent only if their values are equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize ⊥ == p ∧ ¬p\ntrue\n\njulia> @atomize (p ↔ q) == ¬(p ⊻ q)\ntrue\n\njulia> @atomize $1 == $1\ntrue\n\njulia> @atomize p == ¬p\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.:<","page":"Semantics","title":"Base.:<","text":"<(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\n\nReturn a boolean indicating whether the arguments are ordered such that p < q < r, where p, q, and r satisfy is_contradiction, is_contingency, and is_tautology, respectively.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize ⊥ < p < ⊤\ntrue\n\njulia> @atomize p ∧ ¬p < p < p ∨ ¬p\ntrue\n\njulia> ⊤ < ⊥\nfalse\n\njulia> @atomize p < p\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Properties","page":"Semantics","title":"Properties","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"dual\nconverse\nleft_neutrals\nright_neutrals","category":"page"},{"location":"manual/semantics/#PAndQ.dual","page":"Semantics","title":"PAndQ.dual","text":"dual(operator)\n\nReturns the operator that is the dual of the given operator.\n\nExamples\n\njulia> dual(and)\nor (generic function with 9 methods)\n\njulia> @atomize and(p, q) == not(dual(and)(not(p), not(q)))\ntrue\n\njulia> dual(imply)\nnot_converse_imply (generic function with 6 methods)\n\njulia> @atomize imply(p, q) == not(dual(imply)(not(p), not(q)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.converse","page":"Semantics","title":"PAndQ.converse","text":"converse(binary_operator)\n\nReturns the operator that is the converse of the given binary operator.\n\nExamples\n\njulia> converse(and)\nand (generic function with 11 methods)\n\njulia> @atomize and(p, q) == converse(and)(q, p)\ntrue\n\njulia> converse(imply)\nconverse_imply (generic function with 6 methods)\n\njulia> @atomize imply(p, q) == converse(imply)(q, p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.left_neutrals","page":"Semantics","title":"PAndQ.left_neutrals","text":"left_neutrals(binary_operator)\n\nReturn a Set of the Nullary Operators that are left neutral elements of the given binary operator.\n\nExamples\n\njulia> left_neutrals(or)\nSet{typeof(contradiction)} with 1 element:\n  PAndQ.contradiction\n\njulia> left_neutrals(imply)\nSet{typeof(tautology)} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.right_neutrals","page":"Semantics","title":"PAndQ.right_neutrals","text":"right_neutrals(binary_operator)\n\nReturn a Set of the Nullary Operators that are right neutral elements of the given binary operator.\n\nExamples\n\njulia> right_neutrals(or)\nSet{typeof(contradiction)} with 1 element:\n  PAndQ.contradiction\n\njulia> right_neutrals(converse_imply)\nSet{typeof(tautology)} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Utilities","page":"Semantics","title":"Utilities","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Bool(::PAndQ.NullaryOperator)","category":"page"},{"location":"manual/semantics/#Core.Bool-Tuple{Union{typeof(contradiction), typeof(tautology)}}","page":"Semantics","title":"Core.Bool","text":"Bool(nullary_operator)\n\nReturn a Bool corresponding to the given nullary operator.\n\nExamples\n\njulia> Bool(⊤)\ntrue\n\njulia> Bool(⊥)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page demonstrates the basic functionality of this package. For additional features and documentation, see the Tutorials and Manual.","category":"page"},{"location":"getting_started/#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Operators are functions represented by a symbol that return a symbolic expression.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The operators tautology and contradiction are similar to the boolean values true and false, respectively. These operators are represented with the symbols ⊤ and ⊥ and return themselves when called.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ⊤()\ntautology (generic function with 1 method)\n\njulia> ⊥()\ncontradiction (generic function with 1 method)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The symbols ! and ¬ both represent the unary operator not. The symbols & and ∧ represent the binary operator and.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> !true\nfalse\n\njulia> true & false\nfalse\n\njulia> ¬⊤\n¬⊤\n\njulia> ⊤ ∧ ⊥\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/#Propositions","page":"Getting Started","title":"Propositions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A proposition is a statement that can be either true or false. For example, \"Logic is fun\". This proposition has a known value, so it is a constant. Note that the proposition exists independently of whether it is known to be true or false. Constants can be instantiated inline with the @atomize macro and unwrapped with the value function.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p = @atomize $\"Logic is fun\"\n$(\"Logic is fun\")\n\njulia> q = @atomize $\"Julia is awesome\"\n$(\"Julia is awesome\")\n\njulia> map(value, [p, q])\n2-element Vector{String}:\n \"Logic is fun\"\n \"Julia is awesome\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A proposition can be negated, such as \"Logic is not fun\". Propositions can be connected, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ¬p\n¬$(\"Logic is fun\")\n\njulia> p ∧ q\n$(\"Logic is fun\") ∧ $(\"Julia is awesome\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Variables represent a proposition with an arbitrary value. Use the @atomize macro to instantiate them inline or the @variables macro to define multiple variables at once.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> ¬p\n¬p\n\njulia> p ∧ q\np ∧ q","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The tautology and contradiction operators can interoperate with both booleans and propositions. However, booleans and propositions cannot interoperate.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> Bool(⊤)\ntrue\n\njulia> true ∧ ⊤\ntrue\n\njulia> ⊤ ∧ p\n⊤ ∧ p","category":"page"},{"location":"getting_started/#Semantics","page":"Getting Started","title":"Semantics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Constants and variables are atomic propositions. Operators construct compound propositions from one or more atomic propositions. Each atom in a proposition can be assigned the valuation true or false. This results in an interpretation, which determines the truth value of the overall proposition. For example, assigning the valuation true to the atomic proposition \"Logic is fun\" determines that the compound proposition \"Logic is not fun\" is interpreted as false. Use the interpret function to assign truth values to atomic propositions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\njulia> interpret([p => ⊤, q => ⊥], p ∧ q)\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. Use == to check if two propositions are logically equivalent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p ∧ ¬p == ⊥\ntrue\n\njulia> p ∧ ¬p === ⊥\nfalse","category":"page"},{"location":"getting_started/#Printing","page":"Getting Started","title":"Printing","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"TruthTables are used to enumerate the interpretations of propositions. The header contains propositions and the atoms composing them. Each column corresponds to the truth values of the proposition in the header. Each row represents an interpretation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> TruthTable([⊤, ¬p, p ∧ q])\n┌───┬───┬───┬────┬───────┐\n│ ⊤ │ p │ q │ ¬p │ p ∧ q │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊤ │ ⊥  │ ⊤     │\n│ ⊤ │ ⊥ │ ⊤ │ ⊤  │ ⊥     │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊥ │ ⊥  │ ⊥     │\n│ ⊤ │ ⊥ │ ⊥ │ ⊤  │ ⊥     │\n└───┴───┴───┴────┴───────┘","category":"page"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nshow\nformatter\npretty_table(::IO, ::TruthTable)\nprint_tree","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(::Vector{String}, ::Matrix{Bool})\nTruthTable(ps)\n\nConstruct a truth table for the given Propositions.\n\nThe header is a vector containing vectors of logically equivalent propositions. The body is a matrix where the rows contain interpretations of each proposition in the given column.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\njulia> @atomize TruthTable([p ∧ ¬p, p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q)])\n┌────────┬───┬───┬───────────────────────────┐\n│ p ∧ ¬p │ p │ q │ p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q) │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥                         │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤                         │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊤                         │\n│ ⊥      │ ⊥ │ ⊥ │ ⊥                         │\n└────────┴───┴───┴───────────────────────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#Base.show","page":"Printing","title":"Base.show","text":"show(::IO, ::MIME\"text/plain\", ::Proposition)\n\nRepresent the given Proposition as a propositional formula.\n\nThe value of a Constant is shown with IOContext(io, :compact => get(io, :compact, true)).\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), p ⊻ q)\np ⊻ q\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), normalize(∧, p ⊻ q))\n(¬q ∨ ¬p) ∧ (q ∨ p)\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::TruthTable)\n\nSee also TruthTable.\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), TruthTable([p ∧ q]))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\nshow(::IO, ::Proposition)\n\nShow the given Proposition with verbose Atoms.\n\nExamples\n\njulia> @atomize show(stdout, p ∧ q)\nPAndQ.Variable(:p) ∧ PAndQ.Variable(:q)\n\njulia> PAndQ.Variable(:p) ∧ PAndQ.Variable(:q)\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.formatter","page":"Printing","title":"PAndQ.formatter","text":"formatter(type)\n\nUse as the formatters keyword argument in pretty_table.\n\ntype formatter(type)(true, _, _) formatter(type)(false, _, _)\nNullaryOperator \"⊤\" \"⊥\"\nString \"tautology\" \"contradiction\"\nChar \"T\" \"F\"\nBool \"true\" \"false\"\nInt \"1\" \"0\"\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Int))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ 1 │ 1 │ 1     │\n│ 0 │ 1 │ 0     │\n├───┼───┼───────┤\n│ 1 │ 0 │ 0     │\n│ 0 │ 0 │ 0     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PrettyTables.pretty_table-Tuple{IO, TruthTable}","page":"Printing","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Union{IO, Type{<:Union{String, Docs.HTML}}} = stdout,\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    kwargs...\n)\n\nSee also Nullary Operators, Proposition, TruthTable, formatter, and PrettyTables.pretty_table.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\njulia> @atomize pretty_table(p ∧ q; backend = Val(:markdown))\n| **p** | **q** | **p ∧ q** |\n|:------|:------|:----------|\n| ⊤     | ⊤     | ⊤         |\n| ⊥     | ⊤     | ⊥         |\n| ⊤     | ⊥     | ⊥         |\n| ⊥     | ⊥     | ⊥         |\n\njulia> @atomize print(pretty_table(String, p ∧ q; backend = Val(:html)))\n<table>\n  <thead>\n    <tr class = \"header headerLastRow\">\n      <th style = \"text-align: left;\">p</th>\n      <th style = \"text-align: left;\">q</th>\n      <th style = \"text-align: left;\">p ∧ q</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n\n\n","category":"method"},{"location":"manual/printing/#AbstractTrees.print_tree","page":"Printing","title":"AbstractTrees.print_tree","text":"print_tree(::IO = stdout, ::Proposition; kwargs...)\n\nPrints a tree diagram of the given Proposition.\n\nSee also AbstractTrees.print_tree.\n\njulia> @atomize print_tree(p ∧ q ∨ ¬s)\n∨\n├─ ∧\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ 𝒾\n│     └─ q\n└─ ¬\n   └─ s\n\njulia> @atomize print_tree(normalize(∧, p ∧ q ∨ ¬s))\n∧\n├─ ∨\n│  ├─ 𝒾\n│  │  └─ q\n│  └─ ¬\n│     └─ s\n└─ ∨\n   ├─ 𝒾\n   │  └─ p\n   └─ ¬\n      └─ s\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is a computer algebra system for propositional logic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First-class propositions\nSyntax and pretty-printing corresponding to written logic\nEasy instantiation\nCustom REPL mode\nNormalization\nNegated, conjunctive, and disjunctive forms\nTseytin transformation\nSatisfiability solving\nLogical equivalence\nPartial interpretation\nDiagrams\nSyntax trees\nTruth tables\nPlain text, HTML, Markdown, and LaTeX output\nConvert propositions to LaTeX","category":"page"},{"location":"#Planned","page":"Home","title":"Planned","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simplification\nSubstitution\nProofs\nGenerate propositions\nNormal forms\nAlgebraic, Blake\nMinimization\nDiagrams\nDecision trees\nCircuits\nModal logic\nFirst order logic\nLambda calculus\nElectronic circuits\nSatisfiability modulo theories","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊤\n¬⊤\n\njulia> @atomize p ∧ q → $1\n(p ∧ q) → $(1)\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> r = p ⊻ q\np ⊻ q\n\njulia> interpret(p => ⊤, r)\n⊤ ⊻ q\n\njulia> valuation = collect(only(solutions(p ∧ q)))\n2-element Vector{Pair{PAndQ.Variable, Bool}}:\n PAndQ.Variable(:p) => 1\n PAndQ.Variable(:q) => 1\n\njulia> interpret(valuation, p ∧ q)\ntrue\n\njulia> s = normalize(∧, r)\n(¬q ∨ ¬p) ∧ (q ∨ p)\n\njulia> TruthTable([p ∧ ¬p, ¬p, r, s])\n┌────────┬───┬───┬────┬────────────────────────────┐\n│ p ∧ ¬p │ p │ q │ ¬p │ p ⊻ q, (¬q ∨ ¬p) ∧ (q ∨ p) │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥  │ ⊥                          │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤  │ ⊤                          │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥  │ ⊤                          │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤  │ ⊥                          │\n└────────┴───┴───┴────┴────────────────────────────┘","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#Logic","page":"Home","title":"Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nImplements a Prolog-like logic programming language for propositional and first-order logic\nLogicCircuits.jl\nImplements propositional logic with support for SIMD and CUDA\nSoleLogics.jl\nImplements propositional and modal logic\nTruthTables.jl\nImplements a macro that prints a truth table\nPAndQ.jl implements a superset of the features in this package\nMathematicalPredicates.jl\nImplements propositional logic\nPAndQ.jl, Julog.jl, and SoleLogics.jl implement a superset of the features in this package\nSatifsiability.jl\nAn interface to satisfiability modulo theory solvers\nSolvers must be installed on the user's system","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PicoSat.jl\nAn interface to the PicoSAT solver using PicoSAT_jll.jl\nZ3.jl\nAn interface to the Z3 Theorem Prover using z3_jll.jl\nCommits type piracy","category":"page"},{"location":"#Binaries","page":"Home","title":"Binaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These packages are generated by BinaryBuilder.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PicoSAT_jll.jl\nz3_jll.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Metatheory.jl\nSymbolicUtils.jl\nSymbolics.jl\nOscar.jl\nCatlab.jl","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl\nConstraintSolver.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed.jl\nCPLEXCP.jl\nBeeEncoder.jl\n3+ years since last update","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operators accept Bools, Nullary Operators, and Propositions. Operations on symbolic expressions are not simplified.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊤ is typed with \\top[TAB]. See also Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For those cases, you may need to use parentheses. For example, @atomize p → q == r parses as @atomize p → (q == r) rather than @atomize (p → q) == r.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion Associativity Precedence\ntautology ⊤ \\top none 0\ncontradiction ⊥ \\bot none 0\nidentity 𝒾 \\scri none 0\nnot ¬ \\neg right 0\nand ∧ \\wedge left 12\nnand ⊼ \\nand left 12\nnor ⊽ \\nor left 11\nor ∨ \\vee left 11\nxor ⊻ \\xor left 11\nxnor ↔ \\leftrightarrow right 4\nimply → \\rightarrow right 4\nnot_imply ↛ \\nrightarrow right 4\nconverse_imply ← \\leftarrow right 4\nnot_converse_imply ↚ \\nleftarrow right 4\nconjunction ⋀ \\bigwedge none 0\ndisjunction ⋁ \\bigvee none 0","category":"page"},{"location":"manual/operators/#nullary_operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"tautology()\n⊤()\n\nLogical true operator.\n\n⊤ can be typed by \\top[TAB].\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"contradiction()\n⊥()\n\nLogical false operator.\n\n⊥ can be typed by \\bot[TAB].\n\nExamples\n\njulia> TruthTable([⊥])\n┌───┐\n│ ⊥ │\n├───┤\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#unary_operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identity\nnot","category":"page"},{"location":"manual/operators/#Base.identity","page":"Operators","title":"Base.identity","text":"identity(p)\n𝒾(p)\n\nLogical identity operator.\n\nExamples\n\njulia> @atomize TruthTable([𝒾(p)])\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"not(p)\n¬p\n\nLogical negation operator.\n\n¬ can be typed by \\neg[TAB].\n\nExamples\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#binary_operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tip: Tip\nEach binary operator bo has been curried such that bo(p) = Base.Fix2(bo, p) and bo(p)(q) == bo(q, p).","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nnand\nnor\nor\nxor\nxnor\nimply\nnot_imply\nconverse_imply\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"and(p, q)\np ∧ q\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∧ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nand","page":"Operators","title":"Base.nand","text":"nand(p, q)\np ⊼ q\n\nLogical non-conjunction operator.\n\n⊼ can be typed by \\nand[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊼ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊼ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nor","page":"Operators","title":"Base.nor","text":"nor(p, q)\np ⊽ q\n\nLogical non-disjunction operator.\n\n⊽ can be typed by \\nor[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊽ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊽ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"or(p, q)\np ∨ q\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∨ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∨ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.xor","page":"Operators","title":"Base.xor","text":"xor(p, q)\np ⊻ q\n\nLogical exclusive disjunction operator.\n\n⊻ can be typed by \\xor[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊻ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊻ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.xnor","page":"Operators","title":"PAndQ.xnor","text":"xnor(p, q)\np ↔ q\n\nLogical exclusive non-disjunction operator.\n\n↔ can be typed by \\leftrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↔ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↔ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"imply(p, q)\np → q\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p → q])\n┌───┬───┬───────┐\n│ p │ q │ p → q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"not_imply(p, q)\np ↛ q\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↛ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↛ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"converse_imply(p, q)\np ← q\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ← q])\n┌───┬───┬───────┐\n│ p │ q │ p ← q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"not_converse_imply(p, q)\np ↚ q\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↚ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↚ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#nary_operators","page":"Operators","title":"Nary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tip: Tip\nIt is more performant to perform a reduction of propositions contained in a tuple. Using other containers may be type unstable due to the internal representation of propositions.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"conjunction\ndisjunction","category":"page"},{"location":"manual/operators/#PAndQ.conjunction","page":"Operators","title":"PAndQ.conjunction","text":"conjunction(ps)\n⋀(ps)\n\nEquivalent to something(foldl(∧, ps; init = Some(⊤))).\n\n⋀ can be typed by \\bigwedge[TAB].\n\nSee also and and tautology.\n\nExamples\n\njulia> @atomize ⋀((p, q, r, s))\n((p ∧ q) ∧ r) ∧ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.disjunction","page":"Operators","title":"PAndQ.disjunction","text":"disjunction(ps)\n⋁(ps)\n\nEquivalent to something(foldl(∨, ps; init = Some(⊥))).\n\n⋁ can be typed by \\bigvee[TAB].\n\nSee also or and contradiction.\n\nExamples\n\njulia> @atomize ⋁((p, q, r, s))\n((¬¬p ∨ q) ∨ r) ∨ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Utilities","page":"Operators","title":"Utilities","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"arity\nmap_reducers","category":"page"},{"location":"manual/operators/#PAndQ.arity","page":"Operators","title":"PAndQ.arity","text":"arity(operator)\n\nReturn the arity of the given operator.\n\nExamples\n\njulia> arity(⊤)\n0\n\njulia> arity(¬)\n1\n\njulia> arity(∧)\n2\n\njulia> arity(⋀)\nInf\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.map_reducers","page":"Operators","title":"PAndQ.map_reducers","text":"map_reducers(f, pairs...)\n\nSimilar to mapreduce, but with an arbitrary number of nested reductions.\n\nThe function f must accept as many arguments as there are pairs. Each pair must be a two element iterable where the first element is a binary operator and the second element is an iterable.\n\nThe purpose of this function is to simplify the following pattern:\n\nmapreduce(a, xs) do x\n    mapreduce(b, ys) do y\n        ...\n            f(x, y, zs...)\n        ...\n    end\nend\n\nThis can be rewritten as:\n\nmap_reducers(a => xs, b => ys, ...) do (x, y, zs...)\n    f(x, y, zs...)\nend\n\nUsing do notation corresponds to mathematical syntax. For example:\n\nbigwedgelimits_i = 1^n bigveelimits_j = 1^m f(i j)\n\nExamples\n\njulia> map_reducers(⊤)\ntautology (generic function with 1 method)\n\njulia> @atomize map_reducers(i -> $i, (∧) => 1:2)\n$(1) ∧ $(2)\n\njulia> @atomize map_reducers((i, j) -> $(i, j), (∧) => 1:2, (∨) => 1:2)\n(¬¬$((1, 1)) ∨ $((1, 2))) ∧ (¬¬$((2, 1)) ∨ $((2, 2)))\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/#Instantiation","page":"Propositions","title":"Instantiation","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"@atomize\n@variables\nconstants","category":"page"},{"location":"manual/propositions/#PAndQ.@atomize","page":"Propositions","title":"PAndQ.@atomize","text":"@atomize(expression)\n\nInstantiate Constants and Variables inline.\n\nConstants are instantiated with the $ interpolation syntax. Variables are instantiated with previously undefined symbols.\n\nwarning: Warning\nThis macro attempts to ignore symbols that are being assigned a value. For example, @atomize f(; x = p) = x ∧ q should be equivalent to f(; x = @atomize p)) = x ∧ @atomize q. However, this feature is in-progress and only works in some cases. The implementation is cautious to skip the parts of the expression that it cannot yet handle.\n\nExamples\n\njulia> @atomize x = p ∧ q\np ∧ q\n\njulia> @atomize x → r\n(p ∧ q) → r\n\njulia> @atomize $1 ∧ $(1 + 1)\n$(1) ∧ $(2)\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.@variables","page":"Propositions","title":"PAndQ.@variables","text":"@variables(ps...)\n\nDefine Variables and return a vector containing them.\n\nEach symbol p is defined as p = PAndQ.Variable(:p).\n\nExamples\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.constants","page":"Propositions","title":"PAndQ.constants","text":"constants(xs)\n\nInstantiate each element as a Constant.\n\nExamples\n\njulia> constants(1:2)\n2-element Vector{PAndQ.Constant{Int64}}:\n $(1)\n $(2)\n\njulia> constants([[1,2], [3,4]])\n2-element Vector{PAndQ.Constant{Vector{Int64}}}:\n $([1, 2])\n $([3, 4])\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Utilities","page":"Propositions","title":"Utilities","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"value\natoms\noperators\ninstall_atomize_mode","category":"page"},{"location":"manual/propositions/#PAndQ.value","page":"Propositions","title":"PAndQ.value","text":"value(::Proposition)\n\nUnwrap the value of a Constant.\n\nThe Proposition must be logically equivalent to a Constant.\n\nExamples\n\njulia> @atomize value($1)\n1\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.atoms","page":"Propositions","title":"PAndQ.atoms","text":"atoms(p)\n\nReturn an iterator of each Atom contained in p.\n\nExamples\n\njulia> @atomize collect(atoms(p ∧ q))\n2-element Vector{PAndQ.Variable}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.operators","page":"Propositions","title":"PAndQ.operators","text":"operators(p)\n\nReturn an iterator of each operator contained in p.\n\nExamples\n\njulia> @atomize collect(operators(¬p))\n1-element Vector{typeof(not)}:\n not (generic function with 6 methods)\n\njulia> @atomize collect(operators(¬p ∧ q))\n3-element Vector{Function}:\n and (generic function with 11 methods)\n not (generic function with 6 methods)\n identity (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.install_atomize_mode","page":"Propositions","title":"PAndQ.install_atomize_mode","text":"install_atomize_mode(; start_key = \"\\M-a\", prompt_text = \"atomize> \", prompt_color = :cyan, kwargs...)\n\nInstall the atomize REPL mode, where input implicitly begins with @atomize.\n\nKeyword arguments are passed to ReplMaker.initrepl. The default start keys are pressing both the [Meta] (also known as [Alt]) and [a] keys at the same time. The available prompt_colors are in Base.text_colors.\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Transformations","page":"Propositions","title":"Transformations","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"normalize\ntseytin","category":"page"},{"location":"manual/propositions/#PAndQ.normalize","page":"Propositions","title":"PAndQ.normalize","text":"normalize(::Union{typeof(¬), typeof(∧), typeof(∨)}, p)\n\nConvert the given proposition to negation, conjunction, or disjunction normal form depending on whether the first argument is not, and, or or, respectively.\n\nConsidering the syntax tree of a normalized proposition, each leaf node is a literal; either an Atom or it's negation. Propositions in negation normal form are expanded such that the syntax tree branches only contain the operators and and [or]. Conjunction and disjunction normal forms are negated normal forms that have been flattened by recursively distributing either the and or or operator over the other. In other words, a collection of literals is a clause and a proposition in conjunctive or disjunctive normal form is a conjunction of disjunctive clauses or a disjunction of conjunctive clauses, respectively.\n\nConjunctive and disjunctive, but not negation, normal forms are called canonical. Distributing an operator during conversion increases the size of the syntax tree exponentially. Therefore, it is not possible to compute the canonical form for sufficiently large propositions. Use the tseytin transformation to compute an equisatisfiable proposition in conjunctive normal form.\n\nOperations between canonical propositions return another canonical proposition, while operations between canonical and non-canonical propositions return a non-canonical proposition. It is performant to apply the not operator to a proposition in canonical normal form and the and or or operator to two propositions in conjunction or disjunction normal form, respectively. It is not performant to convert a proposition between conjunction and disjunction normal form. Therefore, it is usually more performant to first perform operations on non-canonical propositions before converting them to a canonical form.\n\nExamples\n\njulia> @atomize normalize(∧, p ⊻ q)\n(¬q ∨ ¬p) ∧ (q ∨ p)\n\njulia> @atomize normalize(∨, p ↔ q)\n(¬q ∧ ¬p) ∨ (q ∧ p)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.tseytin","page":"Propositions","title":"PAndQ.tseytin","text":"tseytin(p)\n\nApply the Tseytin transformation to the given proposition.\n\nThe transformed proposition is normalized to conjunction form, contains introduced Variables, and is_equisatisfiable to p. The valuations of the transformed proposition that result in a true interpretation are a subset of the same for p.\n\nExamples\n\njulia> is_equisatisfiable(⊤, tseytin(⊤))\ntrue\n\njulia> @atomize is_equisatisfiable(p, tseytin(p))\ntrue\n\njulia> is_equisatisfiable(⊥, tseytin(⊥))\ntrue\n\n\n\n\n\n","category":"function"}]
}
