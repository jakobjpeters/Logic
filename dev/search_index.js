var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Everything that is not exported is considered internal.","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.union_typeof","category":"page"},{"location":"manual/internals/#PAndQ.union_typeof","page":"Internals","title":"PAndQ.union_typeof","text":"union_typeof(xs)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"manual/internals/#Union-Types","page":"Internals","title":"Union Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.NaryOperator\nPAndQ.Operator\nPAndQ.AndOr","category":"page"},{"location":"manual/internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of Nullary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of Unary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of Binary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.NaryOperator","page":"Internals","title":"PAndQ.NaryOperator","text":"NaryOperator\n\nThe Union of Nary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Operator","page":"Internals","title":"PAndQ.Operator","text":"Operator\n\nThe Union of Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"manual/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"import AbstractTrees: children # hide\nusing AbstractTrees: print_tree # hide\nusing InteractiveUtils: subtypes # hide\nusing PAndQ: Proposition # hide\n\nchildren(x::Type) = subtypes(x) # hide\nprint_tree(Proposition) # hide","category":"page"},{"location":"manual/internals/#Abstract","page":"Internals","title":"Abstract","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Proposition\nPAndQ.Atom\nPAndQ.Compound","category":"page"},{"location":"manual/internals/#PAndQ.Proposition","page":"Internals","title":"PAndQ.Proposition","text":"Proposition\n\nA proposition.\n\nSupertype of Atom and Compound.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Atom","page":"Internals","title":"PAndQ.Atom","text":"Atom <: Proposition\n\nA proposition with no deeper propositional structure.\n\nSubtype of Proposition. Supertype of Constant and Variable.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Compound","page":"Internals","title":"PAndQ.Compound","text":"Compound <: Proposition\n\nA proposition composed from connecting Atoms with one or more Operators.\n\nSubtype of Proposition. Supertype of Tree, Clause, and Normal.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Concrete","page":"Internals","title":"Concrete","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Constant\nPAndQ.Variable\nPAndQ.Tree\nPAndQ.Literal\nPAndQ.Clause\nPAndQ.Normal","category":"page"},{"location":"manual/internals/#PAndQ.Constant","page":"Internals","title":"PAndQ.Constant","text":"Constant{T} <: Atom\nConstant(::T)\n\nAn atomic sentence.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Constant(1)\n$(1)\n\njulia> PAndQ.Constant(\"Logic is fun\")\n$(\"Logic is fun\")\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Variable","page":"Internals","title":"PAndQ.Variable","text":"Variable <: Atom\n\nAn atomic formula.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Variable(:p)\np\n\njulia> PAndQ.Variable(:q)\nq\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Tree","page":"Internals","title":"PAndQ.Tree","text":"Tree{O <: Operator, AT <: Union{Atom, Tree}, N} <: Compound\nTree(::NullaryOperator, ::Atom)\nTree(::Operator, ::Tree...)\nTree(::Proposition)\n\nA Proposition represented by an abstract syntax tree.\n\nSubtype of Compound. See also Atom, NullaryOperator, and Operator.\n\nExamples\n\njulia> PAndQ.Tree(⊤)\n⊤\n\njulia> @atomize PAndQ.Tree(¬, p)\n¬p\n\njulia> @atomize PAndQ.Tree(and, PAndQ.Tree(p), PAndQ.Tree(q))\np ∧ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Literal","page":"Internals","title":"PAndQ.Literal","text":"Literal <: Tree{<:Operator, <:Atom, 1}\n\nA proposition represented by an atomic formula or its negation.\n\nSee also Operator, Atom, and Tree.\n\nExamples\n\njulia> @atomize PAndQ.Literal(𝒾, p)\np\n\njulia> @atomize PAndQ.Literal(¬, p)\n¬p\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Clause","page":"Internals","title":"PAndQ.Clause","text":"Clause{AO <: AndOr, L <: Literal} <: Compound\nClause(::AO, ps = Literal[])\nClause(::AO, p::Proposition)\nClause(::Union{NullaryOperator, Atom, Literal})\n\nA proposition represented as either a conjunction or disjunction of literals.\n\ninfo: Info\nAn empty Clause is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Atom, Literal, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Clause(∧)\n⊤\n\njulia> @atomize PAndQ.Clause(p)\np\n\njulia> @atomize PAndQ.Clause(∨, [¬p, q])\n¬p ∨ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Normal","page":"Internals","title":"PAndQ.Normal","text":"Normal{AO <: AndOr, C <: Clause} <: Compound\nNormal(::typeof(and), ps = Clause{typeof(or)}[])\nNormal(::typeof(or), ps = Clause{typeof(and)}[])\nNormal(::AO, ::Proposition)\nNormal(::Union{NullaryOperator, Proposition})\n\nA Proposition represented in conjunctive or disjunctive normal form.\n\ninfo: Info\nAn empty Normal is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Clause, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Normal(⊤)\n⊤\n\njulia> @atomize PAndQ.Normal(∧, p ⊻ q)\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.jl","page":"Internals","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.children\nPAndQ.nodevalue\nPAndQ.printnode\nPAndQ.NodeType\nPAndQ.nodetype","category":"page"},{"location":"manual/internals/#AbstractTrees.children","page":"Internals","title":"AbstractTrees.children","text":"children(::Proposition)\n\nReturn an iterator over the child nodes of the given Proposition.\n\nExamples\n\njulia> @atomize PAndQ.children(p)\n()\n\njulia> @atomize PAndQ.children(¬p)\n(PAndQ.Variable(:p),)\n\njulia> @atomize PAndQ.children(p ∧ q)\n(PAndQ.Variable(:p), PAndQ.Variable(:q))\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.nodevalue","page":"Internals","title":"AbstractTrees.nodevalue","text":"nodevalue(::Union{Tree{O}, Clause{O}, Normal{O}}) where O\n\nReturn O.instance.\n\nSee also Compound.\n\nExamples\n\njulia> @atomize PAndQ.nodevalue(¬p)\nnot (generic function with 5 methods)\n\njulia> @atomize PAndQ.nodevalue(p ∧ q)\nand (generic function with 17 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.printnode","page":"Internals","title":"AbstractTrees.printnode","text":"printnode(::IO, ::Union{NullaryOperator, Proposition}; kwargs...)\n\nSee also Proposition.\n\nExamples\n\njulia> @atomize PAndQ.printnode(stdout, p)\np\njulia> @atomize PAndQ.printnode(stdout, ¬p)\n¬\njulia> @atomize PAndQ.printnode(stdout, p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.NodeType","page":"Internals","title":"AbstractTrees.NodeType","text":"NodeType(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.nodetype","page":"Internals","title":"AbstractTrees.nodetype","text":"nodetype(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.child\nPAndQ.atomize","category":"page"},{"location":"manual/internals/#PAndQ.child","page":"Internals","title":"PAndQ.child","text":"child(x)\n\nEquivalent to only ∘ children\n\nSee also children\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.atomize","page":"Internals","title":"PAndQ.atomize","text":"atomize(x)\n\nIf x is a symbol, return an expression that instantiates it as a Variable if it is undefined in the caller's scope. If isexpr(x, :$), return an expression that instantiates it as a Constant. If x is another expression, traverse it with recursive calls to atomize Otherise, return x.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.symbol_of\nPAndQ.parenthesize\nPAndQ.print_node\nPAndQ.show_atom\nPAndQ.base_type","category":"page"},{"location":"manual/internals/#PAndQ.symbol_of","page":"Internals","title":"PAndQ.symbol_of","text":"symbol_of(::Operator)\n\nReturn the Unicode symbol of the given Operator.\n\nExamples\n\njulia> PAndQ.symbol_of(⊤)\n:⊤\n\njulia> PAndQ.symbol_of(¬)\n:¬\n\njulia> PAndQ.symbol_of(∧)\n:∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.parenthesize","page":"Internals","title":"PAndQ.parenthesize","text":"parenthesize(::IO, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.print_node","page":"Internals","title":"PAndQ.print_node","text":"print_node(io, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.show_atom","page":"Internals","title":"PAndQ.show_atom","text":"show_atom(::IO, ::Atom)\n\nSee also Atom.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.base_type","page":"Internals","title":"PAndQ.base_type","text":"base_type(::Proposition)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.interpret_bool\nPAndQ.process_valuations\nPAndQ.neutral_operator\nPAndQ.eval_doubles\nconvert(::Type{PAndQ.Atom}, ::PAndQ.Literal{typeof(𝒾)})","category":"page"},{"location":"manual/internals/#PAndQ.interpret_bool","page":"Internals","title":"PAndQ.interpret_bool","text":"interpret_bool\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.process_valuations","page":"Internals","title":"PAndQ.process_valuations","text":"process_valuations(valuations, p, f)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.neutral_operator","page":"Internals","title":"PAndQ.neutral_operator","text":"neutral_operator(::NullaryOperator)\n\nReturn a subtype of AndOr that is the neutral element of the given NullaryOperator.\n\nExamples\n\njulia> PAndQ.neutral_operator(⊤)\nand (generic function with 17 methods)\n\njulia> PAndQ.neutral_operator(⊥)\nor (generic function with 17 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.eval_doubles","page":"Internals","title":"PAndQ.eval_doubles","text":"eval_doubles(f, doubles)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.convert-Tuple{Type{PAndQ.Atom}, PAndQ.Tree{typeof(identity), <:PAndQ.Atom, 1}}","page":"Internals","title":"Base.convert","text":"convert(::Type{<:Proposition}, ::Union{NullaryOperator, Proposition})\n\nSee also NullaryOperator and Proposition.\n\n\n\n\n\n","category":"method"},{"location":"manual/propositions/#Propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/#Macros","page":"Propositions","title":"Macros","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"@atomize\n@variables","category":"page"},{"location":"manual/propositions/#PAndQ.@atomize","page":"Propositions","title":"PAndQ.@atomize","text":"@atomize(expression)\n\nInstantiate Constants and Variables inline.\n\nConstants are instantiated with the $ interpolation syntax. Variables are instantiated with previously undefined symbols.\n\nwarning: Warning\nThis macro attempts to ignore symbols that are being assigned a value. For example, @atomize f(; x = p) = x ∧ q should be equivalent to f(; x = @atomize p)) = x ∧ @atomize q. However, this feature is in-progress and only works in some cases. The implementation is cautious to skip the parts of the expression that it cannot yet handle.\n\nExamples\n\njulia> @atomize x = p ∧ q\np ∧ q\n\njulia> @atomize x → r\n(p ∧ q) → r\n\njulia> @atomize $1 ∧ $(1 + 1)\n$(1) ∧ $(2)\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.@variables","page":"Propositions","title":"PAndQ.@variables","text":"@variables(ps...)\n\nDefine Variables and return a vector containing them.\n\nEach symbol p is defined as p = PAndQ.Variable(:p).\n\nExamples\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#Utilities","page":"Propositions","title":"Utilities","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"atoms\noperators\nvalue","category":"page"},{"location":"manual/propositions/#PAndQ.atoms","page":"Propositions","title":"PAndQ.atoms","text":"atoms(p)\n\nReturn an iterator of each Atom contained in p.\n\nExamples\n\njulia> @atomize collect(atoms(p ∧ q))\n2-element Vector{PAndQ.Variable}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.operators","page":"Propositions","title":"PAndQ.operators","text":"operators(p)\n\nReturn an iterator of each operator contained in p.\n\nExamples\n\njulia> @atomize collect(operators(¬p))\n1-element Vector{typeof(not)}:\n not (generic function with 5 methods)\n\njulia> @atomize collect(operators(¬p ∧ q))\n3-element Vector{Function}:\n and (generic function with 17 methods)\n not (generic function with 5 methods)\n identity (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.value","page":"Propositions","title":"PAndQ.value","text":"value(::Proposition)\n\nUnwrap the value of a Constant.\n\nThe Proposition must be logically equivalent to a Constant.\n\nExamples\n\njulia> @atomize value($1)\n1\n\n\n\n\n\n","category":"function"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/#Markdown","page":"Extensions","title":"Markdown","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"pretty_table(::Type{Markdown.MD}, ::TruthTable)","category":"page"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{Markdown.MD}, TruthTable}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Type{Markdown.MD},\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    alignment = :l\n)\n\nSee also Nullary Operators, Proposition, TruthTable, and formatter.\n\nExamples\n\njulia> @atomize pretty_table(Markdown.MD, p ∧ q)\n  p q p ∧ q\n  – – –––––\n  ⊤ ⊤ ⊤\n  ⊥ ⊤ ⊥\n  ⊤ ⊥ ⊥\n  ⊥ ⊥ ⊥\n\njulia> @atomize print(pretty_table(String, p ∧ q; backend = Val(:markdown)))\n| p   | q   | p ∧ q |\n|:--- |:--- |:----- |\n| ⊤   | ⊤   | ⊤     |\n| ⊥   | ⊤   | ⊥     |\n| ⊤   | ⊥   | ⊥     |\n| ⊥   | ⊥   | ⊥     |\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#Latexify","page":"Extensions","title":"Latexify","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nA @latexrecipe has been defined for Operators, Proposition, and TruthTable.","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"formatter(::Type{Latexify.LaTeXString})\npretty_table(::Type{Latexify.LaTeXString}, ::Union{PAndQ.Proposition, TruthTable})","category":"page"},{"location":"manual/extensions/#PAndQ.formatter-Tuple{Type{LaTeXStrings.LaTeXString}}","page":"Extensions","title":"PAndQ.formatter","text":"formatter(::Latexify.LaTeXString)\n\nExamples\n\njulia> formatter(Latexify.LaTeXString)(true, nothing, nothing)\nL\"$\\top$\"\n\njulia> formatter(Latexify.LaTeXString)(false, nothing, nothing)\nL\"$\\bot$\"\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Latexify.LaTeXString))\n┌─────────┬─────────┬─────────┐\n│ p       │ q       │ p ∧ q   │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\top$ │ $\\\\top$ │\n│ $\\\\bot$ │ $\\\\top$ │ $\\\\bot$ │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\bot$ │ $\\\\bot$ │\n│ $\\\\bot$ │ $\\\\bot$ │ $\\\\bot$ │\n└─────────┴─────────┴─────────┘\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{LaTeXStrings.LaTeXString}, Union{PAndQ.Proposition, TruthTable}}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Latexify.LaTexString,\n    x::Union{Proposition, TruthTable};\n    backend = Val(:latex),\n    kwargs...\n)\n\nEquivalent to Latexify.LaTeXString(pretty_table(String, x; backend, kwargs...)).\n\nSee also Proposition and TruthTable.\n\nExamples\n\njulia> pretty_table(Latexify.LaTeXString, @atomize p ∧ q)\nL\"\\begin{tabular}{|l|l|l|}\n  \\hline\n  \\textbf{$p$} & \\textbf{$q$} & \\textbf{$p \\wedge q$} \\\\\\hline\n  $\\top$ & $\\top$ & $\\top$ \\\\\n  $\\bot$ & $\\top$ & $\\bot$ \\\\\\hline\n  $\\top$ & $\\bot$ & $\\bot$ \\\\\n  $\\bot$ & $\\bot$ & $\\bot$ \\\\\\hline\n\\end{tabular}\n\"\n\n\n\n\n\n","category":"method"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"warning: Warning\nThe model checking algorithm currently has a naive implementation with a time complexity of O(2 ^ length(unique(atoms(p)))).","category":"page"},{"location":"manual/semantics/#Truths","page":"Semantics","title":"Truths","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"valuations\nmap\ninterpret\ninterpretations\nsolve","category":"page"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuation(atoms)\nvaluations(::Union{NullaryOperator, Proposition})\n\nReturn an iterator of every possible valuation.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> collect(valuations(⊤))\n0-dimensional Array{Vector{Union{}}, 0}:\n[]\n\njulia> @atomize collect(valuations(p))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n [PAndQ.Variable(:p) => 0]\n\njulia> @atomize collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.Variable, Bool}}}:\n [Variable(:p)=>1, Variable(:q)=>1]  [Variable(:p)=>1, Variable(:q)=>0]\n [Variable(:p)=>0, Variable(:q)=>1]  [Variable(:p)=>0, Variable(:q)=>0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.map","page":"Semantics","title":"Base.map","text":"map(::Function, ::Union{NullaryOperator, Proposition})\n\nApply the given function to each Atom in the given argument.\n\nAlternatively, propositions are callable with the function as an argument.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize map(atom -> ⊤, p ⊻ q)\n⊤ ⊻ ⊤\n\njulia> @atomize map(atom -> $(value(atom) + 1), $1 ∧ $2)\n$(2) ∧ $(3)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(valuation, p)\n\nSubstitute each Atom in the given Proposition with values from the valuation.\n\nThe valuation can be a Function with the signature valuation(::Atom)::Union{Bool, NullaryOperator, Proposition}, a Dict, or an iterable that can construct a Dict. No substitution is performed if an Atom from the Proposition is not one of the dictionary's keys.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize interpret(p -> true, ¬p)\nfalse\n\njulia> @atomize interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(valuations, p)\ninterpretations(p)\n\nReturn an iterator of truth values given by interpreting p with each valuation in valuations.\n\nExamples\n\njulia> collect(interpretations(⊤))\n0-dimensional Array{Bool, 0}:\n1\n\njulia> @atomize collect(interpretations(p))\n2-element Vector{Bool}:\n 1\n 0\n\njulia> @atomize collect(interpretations(p ∧ q))\n2×2 Matrix{Bool}:\n 1  0\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solve","page":"Semantics","title":"PAndQ.solve","text":"solve(valuations, p)\nsolve(p)\n\nReturn a vector containing all valuations such that interpret(valuation, p) == ⊤.\n\nSee also interpret and tautology.\n\nExamples\n\njulia> collect(solve(⊤))\n1-element Vector{Vector{Union{}}}:\n []\n\njulia> @atomize collect(solve(p))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n\njulia> @atomize collect(solve(p ∧ q))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1, PAndQ.Variable(:q) => 1]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Predicates","page":"Semantics","title":"Predicates","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"is_commutative\nis_associative\n==\nis_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable","category":"page"},{"location":"manual/semantics/#PAndQ.is_commutative","page":"Semantics","title":"PAndQ.is_commutative","text":"is_commutative(::BinaryOperator)\n\nSee also Binary Operators.\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_associative","page":"Semantics","title":"PAndQ.is_associative","text":"is_associative(::BinaryOperator)\n\nSee also Binary Operators.\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"==(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\np == q\n\nReturns a boolean indicating whether p and q are logically equivalent.\n\nConstants are equivalent if and only if their values are equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize p == ¬p\nfalse\n\njulia> @atomize ¬(p ⊻ q) == (p → q) ∧ (p ← q)\ntrue\n\njulia> @atomize ¬(p ⊻ q) === (p → q) ∧ (p ← q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturns a boolean on whether p is a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @atomize is_tautology(p)\nfalse\n\njulia> @atomize is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturns a boolean on whether p is a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @atomize is_contradiction(p)\nfalse\n\njulia> @atomize is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturns a boolean on whether p is a nullary operator.\n\nSee also Proposition.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @atomize is_truth(p ∧ ¬p)\ntrue\n\njulia> @atomize is_truth(p)\nfalse\n\njulia> @atomize is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturns a boolean on whether p is a contingency (not logically equivalent to a nullary operator).\n\nSee also Proposition.\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @atomize is_contingency(p ∧ ¬p)\nfalse\n\njulia> @atomize is_contingency(p)\ntrue\n\njulia> @atomize is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturns a boolean on whether p is satisfiable (not a contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @atomize is_satisfiable(p)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturns a boolean on whether p is falsifiable (not a tautology).\n\nSee also Proposition.\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @atomize is_falsifiable(p ∨ ¬p)\nfalse\n\njulia> @atomize is_falsifiable(p)\ntrue\n\njulia> @atomize is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Properties","page":"Semantics","title":"Properties","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"dual\nconverse\nleft_neutrals\nright_neutrals","category":"page"},{"location":"manual/semantics/#PAndQ.dual","page":"Semantics","title":"PAndQ.dual","text":"dual(::Operator)\n\nReturns the operator that is the dual of the given operator.\n\nExamples\n\njulia> dual(and)\nor (generic function with 17 methods)\n\njulia> @atomize and(p, q) == not(dual(and)(not(p), not(q)))\ntrue\n\njulia> dual(imply)\nnot_converse_imply (generic function with 3 methods)\n\njulia> @atomize imply(p, q) == not(dual(imply)(not(p), not(q)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.converse","page":"Semantics","title":"PAndQ.converse","text":"converse(::Operator)\n\nReturns the operator that is the converse of the given operator.\n\nExamples\n\njulia> converse(and)\nand (generic function with 17 methods)\n\njulia> @atomize and(p, q) == converse(and)(q, p)\ntrue\n\njulia> converse(imply)\nconverse_imply (generic function with 3 methods)\n\njulia> @atomize imply(p, q) == converse(imply)(q, p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.left_neutrals","page":"Semantics","title":"PAndQ.left_neutrals","text":"left_neutrals(::Operator)\n\nReturn a Set of the Nullary Operators that are left neutral elements of the given operator.\n\nExamples\n\njulia> left_neutrals(or)\nSet{typeof(contradiction)} with 1 element:\n  PAndQ.contradiction\n\njulia> left_neutrals(imply)\nSet{typeof(tautology)} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.right_neutrals","page":"Semantics","title":"PAndQ.right_neutrals","text":"right_neutrals(::Operator)\n\nReturn a Set of the Nullary Operators that are right neutral elements of the given operator.\n\nExamples\n\njulia> right_neutrals(or)\nSet{typeof(contradiction)} with 1 element:\n  PAndQ.contradiction\n\njulia> right_neutrals(converse_imply)\nSet{typeof(tautology)} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Utilities","page":"Semantics","title":"Utilities","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Bool(::PAndQ.NullaryOperator)\nconvert(::Type{Bool}, ::typeof(⊤))","category":"page"},{"location":"manual/semantics/#Core.Bool-Tuple{Union{typeof(contradiction), typeof(tautology)}}","page":"Semantics","title":"Core.Bool","text":"Bool(::NullaryOperator)\n\nSee also Nullary Operators.\n\n\n\n\n\n","category":"method"},{"location":"manual/semantics/#Base.convert-Tuple{Type{Bool}, typeof(tautology)}","page":"Semantics","title":"Base.convert","text":"convert(::Type{Bool}, ::NullaryOperator)\n\nSee also Nullary Operators.\n\n\n\n\n\n","category":"method"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nshow\nformatter\npretty_table(::IO, ::TruthTable)\nprint_tree","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(::Vector{String}, ::Matrix{Bool})\nTruthTable(ps)\n\nConstruct a truth table for the given Propositions.\n\nThe header is a vector containing vectors of logically equivalent propositions. The body is a matrix where the rows contain interpretations of each proposition in the given column.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\njulia> @atomize TruthTable([p ∧ ¬p, p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q)])\n┌────────┬───┬───┬───────────────────────────┐\n│ p ∧ ¬p │ p │ q │ p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q) │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥                         │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤                         │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊤                         │\n│ ⊥      │ ⊥ │ ⊥ │ ⊥                         │\n└────────┴───┴───┴───────────────────────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#Base.show","page":"Printing","title":"Base.show","text":"show(::IO, ::MIME\"text/plain\", ::Proposition)\n\nRepresent the given Proposition as a propositional formula.\n\nThe value of a Constant is shown with IOContext(io, :compact => get(io, :compact, true)).\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), p ⊻ q)\np ⊻ q\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), PAndQ.Normal(p ⊻ q))\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::TruthTable)\n\nSee also TruthTable.\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), TruthTable([p ∧ q]))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\nshow(::IO, ::Proposition)\n\nShow the given Proposition with verbose Atoms.\n\nExamples\n\njulia> @atomize show(stdout, p ∧ q)\nPAndQ.Variable(:p) ∧ PAndQ.Variable(:q)\n\njulia> PAndQ.Variable(:p) ∧ PAndQ.Variable(:q)\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.formatter","page":"Printing","title":"PAndQ.formatter","text":"formatter(type)\n\nUse as the formatters keyword argument in pretty_table.\n\ntype formatter(type)(true, _, _) formatter(type)(false, _, _)\nNullaryOperator \"⊤\" \"⊥\"\nString \"tautology\" \"contradiction\"\nChar \"T\" \"F\"\nBool \"true\" \"false\"\nInt \"1\" \"0\"\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Int))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ 1 │ 1 │ 1     │\n│ 0 │ 1 │ 0     │\n├───┼───┼───────┤\n│ 1 │ 0 │ 0     │\n│ 0 │ 0 │ 0     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PrettyTables.pretty_table-Tuple{IO, TruthTable}","page":"Printing","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Union{IO, Type{<:Union{String, Docs.HTML}}} = stdout,\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    kwargs...\n)\n\nSee also Nullary Operators, Proposition, TruthTable, formatter, and PrettyTables.pretty_table.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\njulia> print(pretty_table(Docs.HTML, @atomize p ∧ q).content)\n<table>\n  <thead>\n    <tr class = \"header headerLastRow\">\n      <th style = \"text-align: left;\">p</th>\n      <th style = \"text-align: left;\">q</th>\n      <th style = \"text-align: left;\">p ∧ q</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n\n\n","category":"method"},{"location":"manual/printing/#AbstractTrees.print_tree","page":"Printing","title":"AbstractTrees.print_tree","text":"print_tree(::IO = stdout, ::Proposition; kwargs...)\n\nPrints a tree diagram of the given Proposition.\n\nSee also AbstractTrees.print_tree.\n\njulia> @atomize print_tree(p ∧ ¬q ⊻ s)\n⊻\n├─ ∧\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ ¬\n│     └─ q\n└─ 𝒾\n   └─ s\n\njulia> @atomize print_tree(PAndQ.Normal(p ∧ ¬q ⊻ s))\n∧\n├─ ∨\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ 𝒾\n│     └─ s\n├─ ∨\n│  ├─ ¬\n│  │  └─ q\n│  └─ 𝒾\n│     └─ s\n└─ ∨\n   ├─ ¬\n   │  └─ p\n   ├─ 𝒾\n   │  └─ q\n   └─ ¬\n      └─ s\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is a computer algebra system for propositional logic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Syntax and pretty-printing identical to symbolic propositional logic\nNormalization\nLogical equivalence checking\nBoolean satisfiability solving\nPartial interpretation\nConvert propositions to LaTeX\nTruth tables\nPlain text, HTML, Markdown, and LaTeX output\nTree diagrams","category":"page"},{"location":"#Planned","page":"Home","title":"Planned","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Canonical normal form\nFast solver backends\nGraph plotting\nSubstitution\nProofs\nGenerate propositions\nModal logic\nFirst order logic\nLambda calculus\nElectronic circuits","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊤\n¬⊤\n\njulia> @atomize p ∧ q → $1\n(p ∧ q) → $(1)\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> r = ¬p\n¬p\n\njulia> interpret(p => true, r)\nfalse\n\njulia> s = (p ∨ q) ∧ (r ∨ ¬q)\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\njulia> interpret([p => ⊤, q => ⊥], s)\n(⊤ ∨ ⊥) ∧ (¬⊤ ∨ ¬⊥)\n\njulia> TruthTable([p ∧ ¬p, r, p ⊻ q, s])\n┌────────┬───┬───┬────┬────────────────────────────┐\n│ p ∧ ¬p │ p │ q │ ¬p │ p ⊻ q, (p ∨ q) ∧ (¬p ∨ ¬q) │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥  │ ⊥                          │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤  │ ⊤                          │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥  │ ⊤                          │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤  │ ⊥                          │\n└────────┴───┴───┴────┴────────────────────────────┘","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#Logic","page":"Home","title":"Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nImplements a Prolog-like logic programming language for propositional and first-order logic\nLogicCircuits.jl\nImplements propositional logic with support for SIMD and CUDA\nSoleLogics.jl\nImplements propositional and modal logic\nTruthTables.jl\nImplements a macro that prints a truth table\nPAndQ.jl implements a superset of the features in this package\nMathematicalPredicates.jl\nImplements propositional logic\nPAndQ.jl, Julog.jl, and SoleLogics.jl implement a superset of the features in this package","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Satifsiability.jl\nAn interface to satisfiability modulo theory solvers\nSolvers must be installed on the user's system\nPicoSat.jl\nAn interface to the PicoSAT solver using PicoSAT_jll.jl\nZ3.jl\nAn interface to the Z3 Theorem Prover using z3_jll.jl\nCommits type piracy","category":"page"},{"location":"#Binaries","page":"Home","title":"Binaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These packages are generated by BinaryBuilder.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PicoSAT_jll.jl\nz3_jll.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Symbolics.jl\nSymbolicUtils.jl\nMetatheory.jl","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl\nConstraintSolver.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed.jl\nCPLEXCP.jl\nBeeEncoder.jl\n3+ years since last update","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page demonstrates the basic functionality of this package. For additional features and documentation, see the Manual.","category":"page"},{"location":"tutorial/#tutorial_operators","page":"Tutorial","title":"Operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operators are functions represented by a symbol that return a symbolic expression.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The operators tautology and contradiction are similar to the boolean values true and false, respectively. These operators are represented with the symbols ⊤ and ⊥ and return themselves when called.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ⊤()\ntautology (generic function with 1 method)\n\njulia> ⊥()\ncontradiction (generic function with 1 method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The symbols ! and ¬ both represent the unary operator not. The symbols & and ∧ represent the binary operator and.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> !true\nfalse\n\njulia> true & false\nfalse\n\njulia> ¬⊤\n¬⊤\n\njulia> ⊤ ∧ ⊥\n⊤ ∧ ⊥","category":"page"},{"location":"tutorial/#Propositions","page":"Tutorial","title":"Propositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition is a statement that can be either true or false. For example, \"Logic is fun\". This proposition has a known value, so it is a constant. Note that the proposition exists independently of whether it is known to be true or false. Constants can be instantiated inline with the @atomize macro and unwrapped with the value function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p = @atomize $\"Logic is fun\"\n$(\"Logic is fun\")\n\njulia> q = @atomize $\"Julia is awesome\"\n$(\"Julia is awesome\")\n\njulia> map(value, [p, q])\n2-element Vector{String}:\n \"Logic is fun\"\n \"Julia is awesome\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition can be negated, such as \"Logic is not fun\". Propositions can be connected, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ¬p\n¬$(\"Logic is fun\")\n\njulia> p ∧ q\n$(\"Logic is fun\") ∧ $(\"Julia is awesome\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Variables represent a proposition with an arbitrary value. Use the @atomize macro to instantiate them inline or the @variables macro to define multiple variables at once.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> ¬p\n¬p\n\njulia> p ∧ q\np ∧ q","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tautology and contradiction operators can interoperate with both booleans and propositions. However, booleans and propositions cannot interoperate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Bool(⊤)\ntrue\n\njulia> true ∧ ⊤\ntrue\n\njulia> ⊤ ∧ p\n⊤ ∧ p","category":"page"},{"location":"tutorial/#Semantics","page":"Tutorial","title":"Semantics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Constants and variables are atomic propositions. Operators construct compound propositions from one or more atomic propositions. Each atom in a proposition can be assigned the valuation true or false. This results in an interpretation, which determines the truth value of the overall proposition. For example, assigning the valuation true to the atomic proposition \"Logic is fun\" determines that the compound proposition \"Logic is not fun\" is interpreted as false. Use the interpret function to assign truth values to atomic propositions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\njulia> interpret([p => ⊤, q => ⊥], p ∧ q)\n⊤ ∧ ⊥","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. Use == to check if two propositions are logically equivalent.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p ∧ ¬p == ⊥\ntrue\n\njulia> p ∧ ¬p === ⊥\nfalse","category":"page"},{"location":"tutorial/#Printing","page":"Tutorial","title":"Printing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TruthTables are used to enumerate the interpretations of propositions. The header contains propositions and the atoms composing them. Each column corresponds to the truth values of the proposition in the header. Each row represents an interpretation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TruthTable([⊤, ¬p, p ∧ q])\n┌───┬───┬───┬────┬───────┐\n│ ⊤ │ p │ q │ ¬p │ p ∧ q │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊤ │ ⊥  │ ⊤     │\n│ ⊤ │ ⊥ │ ⊤ │ ⊤  │ ⊥     │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊥ │ ⊥  │ ⊥     │\n│ ⊤ │ ⊥ │ ⊥ │ ⊤  │ ⊥     │\n└───┴───┴───┴────┴───────┘","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operators accept Bools, Nullary Operators, and Propositions. Operations on symbolic expressions are not simplified.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊤ is typed with \\top[TAB]. See also Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For those cases, you may need to use parentheses. For example, @atomize p → q == r parses as @atomize p → (q == r) rather than @atomize (p → q) == r.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion Associativity Precedence\ntautology ⊤ \\top none 0\ncontradiction ⊥ \\bot none 0\nidentity 𝒾 \\scri none 0\nnot ¬ \\neg right 0\nand ∧ \\wedge left 12\nnand ⊼ \\nand left 12\nnor ⊽ \\nor left 11\nor ∨ \\vee left 11\nxor ⊻ \\xor left 11\nxnor ↔ \\leftrightarrow right 4\nimply → \\rightarrow right 4\nnot_imply ↛ \\nrightarrow right 4\nconverse_imply ← \\leftarrow right 4\nnot_converse_imply ↚ \\nleftarrow right 4\nconjunction ⋀ \\bigwedge none 0\ndisjunction ⋁ \\bigvee none 0","category":"page"},{"location":"manual/operators/#nullary_operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"tautology()\n⊤()\n\nLogical true operator.\n\n⊤ can be typed by \\top[TAB].\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"contradiction()\n⊥()\n\nLogical false operator.\n\n⊥ can be typed by \\bot[TAB].\n\nExamples\n\njulia> TruthTable([⊥])\n┌───┐\n│ ⊥ │\n├───┤\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#unary_operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identity\nnot","category":"page"},{"location":"manual/operators/#Base.identity","page":"Operators","title":"Base.identity","text":"identity(p)\n𝒾(p)\n\nLogical identity operator.\n\nExamples\n\njulia> @atomize TruthTable([𝒾(p)])\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"not(p)\n¬p\n\nLogical negation operator.\n\n¬ can be typed by \\neg[TAB].\n\nExamples\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#binary_operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tip: Tip\nEach binary operator bo has been curried such that bo(p) = Base.Fix2(bo, p) and bo(p)(q) == bo(q, p).","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nnand\nnor\nor\nxor\nxnor\nimply\nnot_imply\nconverse_imply\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"and(p, q)\np ∧ q\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∧ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nand","page":"Operators","title":"Base.nand","text":"nand(p, q)\np ⊼ q\n\nLogical non-conjunction operator.\n\n⊼ can be typed by \\nand[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊼ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊼ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nor","page":"Operators","title":"Base.nor","text":"nor(p, q)\np ⊽ q\n\nLogical non-disjunction operator.\n\n⊽ can be typed by \\nor[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊽ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊽ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"or(p, q)\np ∨ q\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∨ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∨ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.xor","page":"Operators","title":"Base.xor","text":"xor(p, q)\np ⊻ q\n\nLogical exclusive disjunction operator.\n\n⊻ can be typed by \\xor[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ⊻ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊻ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.xnor","page":"Operators","title":"PAndQ.xnor","text":"xnor(p, q)\np ↔ q\n\nLogical exclusive non-disjunction operator.\n\n↔ can be typed by \\leftrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↔ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↔ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"imply(p, q)\np → q\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p → q])\n┌───┬───┬───────┐\n│ p │ q │ p → q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"not_imply(p, q)\np ↛ q\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↛ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↛ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"converse_imply(p, q)\np ← q\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ← q])\n┌───┬───┬───────┐\n│ p │ q │ p ← q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"not_converse_imply(p, q)\np ↚ q\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↚ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↚ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#nary_operators","page":"Operators","title":"Nary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"conjunction\ndisjunction","category":"page"},{"location":"manual/operators/#PAndQ.conjunction","page":"Operators","title":"PAndQ.conjunction","text":"conjunction(ps)\n⋀(ps)\n\nEquivalent to foldl(∧, ps; init = ⊤).\n\n⋀ can be typed by \\bigwedge[TAB].\n\nSee also and and tautology.\n\nExamples\n\njulia> @atomize ⋀((p, q, r, s))\n(((⊤ ∧ p) ∧ q) ∧ r) ∧ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.disjunction","page":"Operators","title":"PAndQ.disjunction","text":"disjunction(ps)\n⋁(ps)\n\nEquivalent to foldl(∨, ps; init = ⊥).\n\n⋁ can be typed by \\bigvee[TAB].\n\nSee also or and contradiction.\n\nExamples\n\njulia> @atomize ⋁((p, q, r, s))\n(((⊥ ∨ p) ∨ q) ∨ r) ∨ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Utilities","page":"Operators","title":"Utilities","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"arity","category":"page"},{"location":"manual/operators/#PAndQ.arity","page":"Operators","title":"PAndQ.arity","text":"arity(::Operator)\n\nReturn the arity of the given operator.\n\nExamples\n\njulia> arity(tautology)\n0\n\njulia> arity(not)\n1\n\njulia> arity(and)\n2\n\njulia> arity(conjunction)\nInf\n\n\n\n\n\n","category":"function"}]
}
