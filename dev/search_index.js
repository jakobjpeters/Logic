var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.union_typeof","category":"page"},{"location":"manual/internals/#PAndQ.union_typeof","page":"Internals","title":"PAndQ.union_typeof","text":"union_typeof(xs)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PicoSAT","page":"Internals","title":"PicoSAT","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT","page":"Internals","title":"PAndQ.PicoSAT","text":"PicoSAT\n\nThis module provides an interface to libpicosat_jll.jl.\n\n\n\n\n\n","category":"module"},{"location":"manual/internals/#libpicosat","page":"Internals","title":"libpicosat","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT.picosat_init\nPAndQ.PicoSAT.picosat_reset\nPAndQ.PicoSAT.picosat_add\nPAndQ.PicoSAT.picosat_variables\nPAndQ.PicoSAT.picosat_print\nPAndQ.PicoSAT.picosat_sat\nPAndQ.PicoSAT.picosat_deref","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_init","page":"Internals","title":"PAndQ.PicoSAT.picosat_init","text":"picosat_init()\n\nConstruct a new PicoSAT instance and return a pointer to it.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_reset","page":"Internals","title":"PAndQ.PicoSAT.picosat_reset","text":"picosat_reset(pico_sat)\n\nDestruct the pico_sat instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_add","page":"Internals","title":"PAndQ.PicoSAT.picosat_add","text":"picosat_add(pico_sat, literal)\n\nAppend the literal to the pico_sat instance's current disjunctive clause.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_variables","page":"Internals","title":"PAndQ.PicoSAT.picosat_variables","text":"picosat_variables(pico_sat)\n\nReturn the number of unique atoms in the pico_sat instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_print","page":"Internals","title":"PAndQ.PicoSAT.picosat_print","text":"picosat_print(pico_sat, file)\n\nWrite the DIMACS format of the pico_sat instance's proposition to the given file.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_sat","page":"Internals","title":"PAndQ.PicoSAT.picosat_sat","text":"picosat_sat(pico_sat, limit)\n\nSearch for a satisfiable assignment of the pico_sat instance's proposition and return 0, 10, or 20 if the status is unknown, satisfiable, or unsatisfiable, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_deref","page":"Internals","title":"PAndQ.PicoSAT.picosat_deref","text":"picosat_deref(pico_sat, atom)\n\nReturn the assignment of the atom, where 1, -1, and 0 indicate true, false, and unknown, respectively.\n\nThis function must be called after verifying that the status of picosat_sat is satisfiable.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT.add_clause\nPAndQ.PicoSAT.initialize\nPAndQ.PicoSAT.finalize!\nPAndQ.PicoSAT.Solutions\nPAndQ.PicoSAT.eltype\nPAndQ.PicoSAT.IteratorSize\nPAndQ.PicoSAT.is_satisfiable\nPAndQ.PicoSAT.isdone\nPAndQ.PicoSAT.iterate\nPAndQ.PicoSAT.dimacs","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT.add_clause","page":"Internals","title":"PAndQ.PicoSAT.add_clause","text":"add_clause(pico_sat, clause)\n\nModify the pico_sat instance's proposition to be the conjunction of itself and the disjunctive clause.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.initialize","page":"Internals","title":"PAndQ.PicoSAT.initialize","text":"initialize(clauses)\n\nReturn a PicoSAT pointer with its proposition being a conjunction of the disjunctive clauses.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.finalize!","page":"Internals","title":"PAndQ.PicoSAT.finalize!","text":"finalize!(solutions)\n\nIf the argument has not been finalized, call picosat_reset on its PicoSAT pointer and then set the pointer equal to C_NULL.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.Solutions","page":"Internals","title":"PAndQ.PicoSAT.Solutions","text":"Solutions\nSolutions(clauses)\n\nA stateful iterator of valuations that satisfy the given proposition.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Base.eltype","page":"Internals","title":"Base.eltype","text":"eltype(::Type{Solutions})\n\nExamples\n\njulia> eltype(PAndQ.PicoSAT.Solutions)\nBase.Generator{Base.Iterators.Enumerate{Base.Iterators.Filter{Base.Fix2{typeof(!=), Int64}, Vector{Int32}}}, Base.Splat{typeof(*)}}\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.IteratorSize","page":"Internals","title":"Base.IteratorSize","text":"IteratorSize(::Type{Solutions})\n\nSince counting the number of Solutions to a proposition is intractable, its IteratorSize is Base.SizeUnknown.\n\nExamples\n\njulia> Base.IteratorSize(PAndQ.PicoSAT.Solutions)\nBase.SizeUnknown()\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.PicoSAT.is_satisfiable","page":"Internals","title":"PAndQ.PicoSAT.is_satisfiable","text":"is_satisfiable(pico_sat)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.isdone","page":"Internals","title":"Base.isdone","text":"isdone(solutions::Solutions, pico_sat = solutions.pico_sat)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.iterate","page":"Internals","title":"Base.iterate","text":"iterate(solutions::Solutions, pico_sat = solutions.pico_sat)\n\nIf the status of pico_sat is_satisfiable, return a Tuple of the current solution and pico_sat. Otherwise, finalize! the solutions and return nothing.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.dimacs","page":"Internals","title":"PAndQ.PicoSAT.dimacs","text":"dimacs(io, clauses)\n\nExamples\n\njulia> PAndQ.PicoSAT.dimacs(stdout, ((-1, -2), (1, 2)))\np cnf 2 2\n-1 -2 0\n1 2 0\n\njulia> PAndQ.PicoSAT.dimacs(String, ((1, -2), (-1, 2)))\n\"p cnf 2 2\\n1 -2 0\\n-1 2 0\\n\"\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Interface","page":"Internals","title":"Interface","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Interface.InterfaceError\nInterface.showerror\nInterface.@interface","category":"page"},{"location":"manual/internals/#PAndQ.Interface.InterfaceError","page":"Internals","title":"PAndQ.Interface.InterfaceError","text":"InterfaceError{F, T} <: Exception\nInterfaceError(::F, ::T)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Base.showerror","page":"Internals","title":"Base.showerror","text":"showerror(::IO, ::InterfaceError)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.Interface.@interface","page":"Internals","title":"PAndQ.Interface.@interface","text":"@interface(f, xs...)\n\n\n\n\n\n","category":"macro"},{"location":"manual/internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.NaryOperator\nPAndQ.AndOr","category":"page"},{"location":"manual/internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of Nullary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of Unary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of Binary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.NaryOperator","page":"Internals","title":"PAndQ.NaryOperator","text":"NaryOperator\n\nThe Union of Nary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"manual/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"import AbstractTrees: children # hide\nusing AbstractTrees: print_tree # hide\nusing InteractiveUtils: subtypes # hide\nusing PAndQ: Proposition # hide\n\nchildren(x::Type) = subtypes(x) # hide\nprint_tree(Proposition) # hide","category":"page"},{"location":"manual/internals/#Abstract","page":"Internals","title":"Abstract","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Proposition\nPAndQ.Atom\nPAndQ.Compound","category":"page"},{"location":"manual/internals/#PAndQ.Proposition","page":"Internals","title":"PAndQ.Proposition","text":"Proposition\n\nA proposition.\n\nSupertype of Atom and Compound.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Atom","page":"Internals","title":"PAndQ.Atom","text":"Atom <: Proposition\n\nA proposition with no deeper propositional structure.\n\nSubtype of Proposition. Supertype of Constant and Variable.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Compound","page":"Internals","title":"PAndQ.Compound","text":"Compound <: Proposition\n\nA proposition composed from connecting Atoms with one or more Operators.\n\nSubtype of Proposition. Supertype of Tree, Clause, and Normal.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Concrete","page":"Internals","title":"Concrete","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Constant\nPAndQ.Variable\nPAndQ.Tree\nPAndQ.Literal\nPAndQ.Clause\nPAndQ.Normal","category":"page"},{"location":"manual/internals/#PAndQ.Constant","page":"Internals","title":"PAndQ.Constant","text":"Constant{T} <: Atom\nConstant(::T)\n\nAn atomic sentence.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Constant(1)\n$(1)\n\njulia> PAndQ.Constant(\"Logic is fun\")\n$(\"Logic is fun\")\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Variable","page":"Internals","title":"PAndQ.Variable","text":"Variable <: Atom\n\nAn atomic formula.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Variable(:p)\np\n\njulia> PAndQ.Variable(:q)\nq\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Tree","page":"Internals","title":"PAndQ.Tree","text":"Tree{O <: Operator, AT <: Union{Atom, Tree}, N} <: Compound\nTree(::NullaryOperator, ::Atom)\nTree(::Operator, ::Tree...)\nTree(::Proposition)\n\nA Proposition represented by an abstract syntax tree.\n\nSubtype of Compound. See also Atom, NullaryOperator, and Operator.\n\nExamples\n\njulia> PAndQ.Tree(⊤)\n⊤\n\njulia> @atomize PAndQ.Tree(¬, p)\n¬p\n\njulia> @atomize PAndQ.Tree(and, PAndQ.Tree(p), PAndQ.Tree(q))\np ∧ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Literal","page":"Internals","title":"PAndQ.Literal","text":"Literal <: Tree{<:Operator, <:Atom, 1}\n\nA proposition represented by an atomic formula or its negation.\n\nSee also Operator, Atom, and Tree.\n\nExamples\n\njulia> @atomize PAndQ.Literal(𝒾, p)\np\n\njulia> @atomize PAndQ.Literal(¬, p)\n¬p\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Clause","page":"Internals","title":"PAndQ.Clause","text":"Clause{AO <: AndOr, A <: AbstractVector{<:Atom}, L <: AbstractVector{Int}} <: Compound\nClause(::AO, ::A, ::L)\n\nA proposition represented as either a conjunction or disjunction of literals.\n\ninfo: Info\nAn empty Clause is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Atom, Literal, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Clause(∧, PAndQ.Atom[], Set{Int}())\n⊤\n\njulia> @atomize PAndQ.Clause(∧, [p], Set(1))\np\n\njulia> @atomize PAndQ.Clause(∨, [p, q], Set((1, -2)))\n¬q ∨ p\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Normal","page":"Internals","title":"PAndQ.Normal","text":"Normal{AO <: AndOr, A <: Atom, C <: AbstractVector{<:AbstractVector{Int}}} <: Compound\nNormal(::AO, ::A, ::C)\n\nA Proposition represented in conjunctive or disjunctive normal form.\n\ninfo: Info\nAn empty Normal is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also Clause, AndOr, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Normal(∧, PAndQ.Atom[], Set{Set{Int}}())\n⊤\n\njulia> @atomize PAndQ.Normal(∧, [p, q], Set(map(Set, ((1, 2), (-1, -2)))))\n(¬p ∨ ¬q) ∧ (p ∨ q)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.jl","page":"Internals","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.children\nPAndQ.nodevalue\nPAndQ.printnode\nPAndQ.NodeType\nPAndQ.nodetype","category":"page"},{"location":"manual/internals/#AbstractTrees.children","page":"Internals","title":"AbstractTrees.children","text":"children(::Proposition)\n\nReturn an iterator over the child nodes of the given Proposition.\n\nExamples\n\njulia> @atomize PAndQ.children(p)\n()\n\njulia> @atomize PAndQ.children(¬p)\n(PAndQ.Variable(:p),)\n\njulia> @atomize PAndQ.children(p ∧ q)\n(PAndQ.Variable(:p), PAndQ.Variable(:q))\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.nodevalue","page":"Internals","title":"AbstractTrees.nodevalue","text":"nodevalue(::Union{Tree{O}, Clause{O}, Normal{O}}) where O\n\nReturn O.instance.\n\nSee also Compound.\n\nExamples\n\njulia> @atomize PAndQ.nodevalue(¬p)\n¬\n\njulia> @atomize PAndQ.nodevalue(p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.printnode","page":"Internals","title":"AbstractTrees.printnode","text":"printnode(::IO, ::Union{NullaryOperator, Proposition}; kwargs...)\n\nSee also Proposition.\n\nExamples\n\njulia> @atomize PAndQ.printnode(stdout, p)\np\njulia> @atomize PAndQ.printnode(stdout, ¬p)\n¬\njulia> @atomize PAndQ.printnode(stdout, p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.NodeType","page":"Internals","title":"AbstractTrees.NodeType","text":"NodeType(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.nodetype","page":"Internals","title":"AbstractTrees.nodetype","text":"nodetype(::Type{<:Atom})\n\nSee also Atom.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.child\nPAndQ.atomize\nPAndQ.distribute\nPAndQ.flatten","category":"page"},{"location":"manual/internals/#PAndQ.child","page":"Internals","title":"PAndQ.child","text":"child(x)\n\nEquivalent to only ∘ children\n\nSee also children.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.atomize","page":"Internals","title":"PAndQ.atomize","text":"atomize(x)\n\nIf x is a symbol, return an expression that instantiates it as a Variable if it is undefined in the caller's scope. If isexpr(x, :$), return an expression that instantiates it as a Constant. If x is a different expression, traverse it with recursive calls to atomize. Otherise, return x.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.distribute","page":"Internals","title":"PAndQ.distribute","text":"distribute(p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.flatten","page":"Internals","title":"PAndQ.flatten","text":"flatten(p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"manual/internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.eval_doubles\nconvert(::Type{PAndQ.Atom}, ::PAndQ.Literal{typeof(𝒾)})\npromote_rule","category":"page"},{"location":"manual/internals/#PAndQ.eval_doubles","page":"Internals","title":"PAndQ.eval_doubles","text":"eval_doubles(f, doubles)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.convert-Tuple{Type{PAndQ.Atom}, PAndQ.Tree{PAndQ.Interface.Operator{:identical}, <:PAndQ.Atom, 1}}","page":"Internals","title":"Base.convert","text":"convert(::Type{<:Proposition}, p)\n\nSee also Proposition.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.promote_rule","page":"Internals","title":"Base.promote_rule","text":"promote_rule\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operators accept Bools, Nullary Operators, and Propositions. Operations on symbolic expressions are not simplified.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊤ is typed with \\top[TAB]. See also Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For those cases, you may need to use parentheses. For example, @atomize p → q == r parses as @atomize p → (q == r) rather than @atomize (p → q) == r.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion\ntautology ⊤ \\top\ncontradiction ⊥ \\bot\nidentical 𝒾 \\scri\nnot ¬ \\neg\nand ∧ \\wedge\nor ∨ \\vee\nimply → \\rightarrow\nexclusive_or ↮ \\nleftrightarrow\nconverse_imply ← \\leftarrow\nnot_and ↑ \\uparrow\nnot_or ↓ \\downarrow\nnot_imply ↛ \\nrightarrow\nnot_exclusive_or ↔ \\leftrightarrow\nnot_converse_imply ↚ \\nleftarrow\nconjunction ⋀ \\bigwedge\ndisjunction ⋁ \\bigvee","category":"page"},{"location":"manual/operators/#nullary_operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"tautology()\n⊤()\n\nLogical true operator.\n\n⊤ can be typed by \\top[TAB].\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"contradiction()\n⊥()\n\nLogical false operator.\n\n⊥ can be typed by \\bot[TAB].\n\nExamples\n\njulia> TruthTable([⊥])\n┌───┐\n│ ⊥ │\n├───┤\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#unary_operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identical\nnot","category":"page"},{"location":"manual/operators/#PAndQ.identical","page":"Operators","title":"PAndQ.identical","text":"identical(p)\n𝒾(p)\n\nLogical identity operator.\n\nExamples\n\njulia> @atomize TruthTable([𝒾(p)])\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"not(p)\n¬p\n\nLogical negation operator.\n\n¬ can be typed by \\neg[TAB].\n\nExamples\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#binary_operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tip: Tip\nEach binary operator bo has been curried such that bo(p) = Base.Fix2(bo, p) and bo(p)(q) == bo(q, p).","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nor\nimply\nexclusive_or\nconverse_imply\nnot_and\nnot_or\nnot_imply\nnot_exclusive_or\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"and(p, q)\np ∧ q\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∧ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"or(p, q)\np ∨ q\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ∨ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∨ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"imply(p, q)\np → q\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p → q])\n┌───┬───┬───────┐\n│ p │ q │ p → q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.exclusive_or","page":"Operators","title":"PAndQ.exclusive_or","text":"exclusive_or(p, q)\np ↮ q\n\nLogical exclusive disjunction operator.\n\n↮ can be typed by \\nleftrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↮ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↮ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"converse_imply(p, q)\np ← q\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ← q])\n┌───┬───┬───────┐\n│ p │ q │ p ← q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_and","page":"Operators","title":"PAndQ.not_and","text":"not_and(p, q)\np ↑ q\n\nLogical non-conjunction operator.\n\n↑ can be typed by \\uparrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↑ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↑ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_or","page":"Operators","title":"PAndQ.not_or","text":"not_or(p, q)\np ↓ q\n\nLogical non-disjunction operator.\n\n↓ can be typed by \\downarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↓ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↓ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"not_imply(p, q)\np ↛ q\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↛ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↛ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_exclusive_or","page":"Operators","title":"PAndQ.not_exclusive_or","text":"not_exclusive_or(p, q)\np ↔ q\n\nLogical exclusive non-disjunction operator.\n\n↔ can be typed by \\leftrightarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↔ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↔ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"not_converse_imply(p, q)\np ↚ q\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow[TAB].\n\nExamples\n\njulia> @atomize TruthTable([p ↚ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↚ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#nary_operators","page":"Operators","title":"Nary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"conjunction\ndisjunction","category":"page"},{"location":"manual/operators/#PAndQ.conjunction","page":"Operators","title":"PAndQ.conjunction","text":"conjunction(ps)\n⋀(ps)\n\nEquivalent to something(foldl(∧, ps; init = Some(⊤))).\n\n⋀ can be typed by \\bigwedge[TAB].\n\nSee also and and tautology.\n\nExamples\n\njulia> @atomize ⋀((p, q, r, s))\n((p ∧ q) ∧ r) ∧ s\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.disjunction","page":"Operators","title":"PAndQ.disjunction","text":"disjunction(ps)\n⋁(ps)\n\nEquivalent to something(foldl(∨, ps; init = Some(⊥))).\n\n⋁ can be typed by \\bigvee[TAB].\n\nSee also or and contradiction.\n\nExamples\n\njulia> @atomize ⋁((p, q, r, s))\n((p ∨ q) ∨ r) ∨ s\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#Utilities","page":"Operators","title":"Utilities","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"fold","category":"page"},{"location":"manual/operators/#PAndQ.fold","page":"Operators","title":"PAndQ.fold","text":"fold(f, pairs...)\n\nA generalization of mapreduce with an arbitrary number of nested folds and traits to determine the Associativity and initial_value.\n\nThe function f must accept as many arguments as there are pairs. Each pair must be an two element iterable where the first element is a binary operator and the second element is an iterable.\n\nGiven a single pair, this function is similar to mapreduce and other related functions. Giving additional pairs will generalize the following pattern:\n\nmapreduce(a, xs) do x\n    mapreduce(b, ys) do y\n        ...\n    end\nend\n\nThis can be rewritten as:\n\nfold(a => xs, b => ys, ...) do (x, y, ...)\n    ...\nend\n\nExamples\n\njulia> fold(⊤)\n⊤\n\njulia> @atomize fold(¬, (∧) => (p, q))\n¬p ∧ ¬q\n\njulia> @atomize fold(↔, (∧) => (p, q), (∨) => (r, s))\n((p ↔ r) ∨ (p ↔ s)) ∧ ((q ↔ r) ∨ (q ↔ s))\n\n\n\n\n\n","category":"function"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/#Markdown","page":"Extensions","title":"Markdown","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"pretty_table(::Type{Markdown.MD}, ::TruthTable)","category":"page"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{Markdown.MD}, TruthTable}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Type{Markdown.MD},\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    alignment = :l\n)\n\nSee also Nullary Operators, Proposition, TruthTable, and formatter.\n\nExamples\n\njulia> @atomize pretty_table(Markdown.MD, p ∧ q)\n  p q p ∧ q\n  – – –––––\n  ⊤ ⊤ ⊤\n  ⊥ ⊤ ⊥\n  ⊤ ⊥ ⊥\n  ⊥ ⊥ ⊥\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#Latexify","page":"Extensions","title":"Latexify","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nA @latexrecipe has been defined for Operators, Proposition, and TruthTable.","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"formatter(::Type{Latexify.LaTeXString})\npretty_table(::Type{Latexify.LaTeXString}, ::Union{PAndQ.Proposition, TruthTable})","category":"page"},{"location":"manual/extensions/#PAndQ.formatter-Tuple{Type{LaTeXStrings.LaTeXString}}","page":"Extensions","title":"PAndQ.formatter","text":"formatter(::Latexify.LaTeXString)\n\nExamples\n\njulia> formatter(Latexify.LaTeXString)(true, nothing, nothing)\nL\"$\\top$\"\n\njulia> formatter(Latexify.LaTeXString)(false, nothing, nothing)\nL\"$\\bot$\"\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Latexify.LaTeXString))\n┌─────────┬─────────┬─────────┐\n│ p       │ q       │ p ∧ q   │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\top$ │ $\\\\top$ │\n│ $\\\\bot$ │ $\\\\top$ │ $\\\\bot$ │\n├─────────┼─────────┼─────────┤\n│ $\\\\top$ │ $\\\\bot$ │ $\\\\bot$ │\n│ $\\\\bot$ │ $\\\\bot$ │ $\\\\bot$ │\n└─────────┴─────────┴─────────┘\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{LaTeXStrings.LaTeXString}, Union{PAndQ.Proposition, TruthTable}}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Latexify.LaTexString,\n    x::Union{Proposition, TruthTable};\n    backend = Val(:latex),\n    kwargs...\n)\n\nEquivalent to Latexify.LaTeXString(pretty_table(String, x; backend, kwargs...)).\n\nSee also Proposition and TruthTable.\n\nExamples\n\njulia> pretty_table(Latexify.LaTeXString, @atomize p ∧ q)\nL\"\\begin{tabular}{|l|l|l|}\n  \\hline\n  \\textbf{$p$} & \\textbf{$q$} & \\textbf{$p \\wedge q$} \\\\\\hline\n  $\\top$ & $\\top$ & $\\top$ \\\\\n  $\\bot$ & $\\top$ & $\\bot$ \\\\\\hline\n  $\\top$ & $\\bot$ & $\\bot$ \\\\\n  $\\bot$ & $\\bot$ & $\\bot$ \\\\\\hline\n\\end{tabular}\n\"\n\n\n\n\n\n","category":"method"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/#Truths","page":"Semantics","title":"Truths","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"valuations\nmap\ninterpret\ninterpretations\nsolutions","category":"page"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuations(atoms)\nvaluations(::Union{NullaryOperator, Proposition})\n\nReturn an iterator of every possible valuation.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> collect(valuations(⊤))\n0-dimensional Array{Vector{Union{}}, 0}:\n[]\n\njulia> @atomize collect(valuations(p))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n [PAndQ.Variable(:p) => 0]\n\njulia> @atomize collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.Variable, Bool}}}:\n [Variable(:p)=>1, Variable(:q)=>1]  [Variable(:p)=>1, Variable(:q)=>0]\n [Variable(:p)=>0, Variable(:q)=>1]  [Variable(:p)=>0, Variable(:q)=>0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.map","page":"Semantics","title":"Base.map","text":"map(::Function, ::Union{NullaryOperator, Proposition})\n\nApply the given function to each Atom in the given argument.\n\nAlternatively, propositions are callable with the function as an argument.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize map(atom -> ⊤, p ↔ q)\n⊤ ↔ ⊤\n\njulia> @atomize map(atom -> $(something(value(atom)) + 1), $1 ∧ $2)\n$(2) ∧ $(3)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(valuation, p)\n\nSubstitute each Atom in the given Proposition with values from the valuation.\n\nThe valuation can be a Function with the signature valuation(::Atom)::Union{Bool, NullaryOperator, Proposition}, a Dict, or an iterable that can construct a Dict. No substitution is performed if an Atom from the Proposition is not one of the dictionary's keys.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize interpret(p -> true, ¬p)\nfalse\n\njulia> @atomize interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(valuations, p)\ninterpretations(p)\n\nReturn an iterator of truth values given by interpreting p with each valuation in valuations.\n\nExamples\n\njulia> collect(interpretations(⊤))\n0-dimensional Array{Bool, 0}:\n1\n\njulia> @atomize collect(interpretations(p))\n2-element Vector{Bool}:\n 1\n 0\n\njulia> @atomize collect(interpretations(p ∧ q))\n2×2 Matrix{Bool}:\n 1  0\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solutions","page":"Semantics","title":"PAndQ.solutions","text":"solutions(p)\n\nReturn a stateful iterator of valuations such that interpret(valuation, p) == ⊤.\n\nTo find every valuation that results in a true interpretation, convert the proposition to conjunctive normal form using normalize. Otherwise, a subset of those valuations will be identified using the tseytin transformation.\n\nSee also interpret and tautology.\n\nExamples\n\njulia> map(collect, solutions(⊤))\n1-element Vector{Vector{Any}}:\n []\n\njulia> @atomize map(collect, solutions(p))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n\njulia> map(collect, solutions(⊥))\nAny[]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Predicates","page":"Semantics","title":"Predicates","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"is_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable\nis_equisatisfiable","category":"page"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturn a boolean indicating whether the given proposition is logically equivalent to a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @atomize is_tautology(p)\nfalse\n\njulia> @atomize is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturn a boolean indicating whether the given proposition is logically equivalent to a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @atomize is_contradiction(p)\nfalse\n\njulia> @atomize is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturn a boolean indicating whether given proposition is logically equivalent to a nullary operator.\n\nSee also Proposition.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @atomize is_truth(p ∧ ¬p)\ntrue\n\njulia> @atomize is_truth(p)\nfalse\n\njulia> @atomize is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturn a boolean indicating whether p is a contingency (not logically equivalent to a nullary operator).\n\nSee also Proposition.\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @atomize is_contingency(p ∧ ¬p)\nfalse\n\njulia> @atomize is_contingency(p)\ntrue\n\njulia> @atomize is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturn a boolean indicating whether p is satisfiable (not logically equivalent to a contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @atomize is_satisfiable(p)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturns a boolean indicating whether p is falsifiable (not logica equivalent to a tautology).\n\nSee also Proposition.\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @atomize is_falsifiable(p ∨ ¬p)\nfalse\n\njulia> @atomize is_falsifiable(p)\ntrue\n\njulia> @atomize is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_equisatisfiable","page":"Semantics","title":"PAndQ.is_equisatisfiable","text":"is_equisatisfiable(p, q)\n\nReturn a boolean indicating whether the predicate is_satisfiable is congruent for both propositions.\n\nExamples\n\njulia> is_equisatisfiable(⊤, ⊥)\nfalse\n\njulia> @atomize is_equisatisfiable(p, q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Ordering","page":"Semantics","title":"Ordering","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Propositions and their truth values have a strict partial order. The truth values tautology and contradiction are the top and bottom of this order, respectively. A proposition that satisfies the predicate is_tautology or is_contradiction is also at the top or bottom of the order, respectively. Propositions that satisfy the predicate is_contingency occupy the middle of this order. More specifically, ⊥ <= p <= ⊤ for some proposition p. The ordering is partial because the predicates == and is_truth may both be false for two given propositions.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"note: Note\nThe implementations for == and < also define the semantics of isequal, >, <=, and >=. This does not define the semantics of isless, which is used for total orders.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"warning: Warning\nThe assumption that isequal(p, q) implies hash(p) == hash(q) is currently being violated. The implementation of hash for propositions is in-progress.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"==\n<","category":"page"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"==(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\np == q\n\nReturn a boolean indicating whether p and q are logically equivalent.\n\nConstants are equivalent only if their values are equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize ⊥ == p ∧ ¬p\ntrue\n\njulia> @atomize (p ↔ q) == ¬(p ↮ q)\ntrue\n\njulia> @atomize $1 == $1\ntrue\n\njulia> @atomize p == ¬p\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.:<","page":"Semantics","title":"Base.:<","text":"<(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\n\nReturn a boolean indicating whether the arguments are ordered such that p < q < r, where p, q, and r satisfy is_contradiction, is_contingency, and is_tautology, respectively.\n\nSee also Nullary Operators and Proposition.\n\nExamples\n\njulia> @atomize ⊥ < p < ⊤\ntrue\n\njulia> @atomize p ∧ ¬p < p < p ∨ ¬p\ntrue\n\njulia> ⊤ < ⊥\nfalse\n\njulia> @atomize p < p\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Utilities","page":"Semantics","title":"Utilities","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Bool(::PAndQ.NullaryOperator)","category":"page"},{"location":"manual/semantics/#Core.Bool-Tuple{Union{PAndQ.Interface.Operator{:tautology}, PAndQ.Interface.Operator{:contradiction}}}","page":"Semantics","title":"Core.Bool","text":"Bool(nullary_operator)\n\nReturn a Bool corresponding to the given nullary operator.\n\nExamples\n\njulia> Bool(⊤)\ntrue\n\njulia> Bool(⊥)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/propositions/#Propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/#Instantiation","page":"Propositions","title":"Instantiation","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"@atomize\n@variables\nconstants","category":"page"},{"location":"manual/propositions/#PAndQ.@atomize","page":"Propositions","title":"PAndQ.@atomize","text":"@atomize(expression)\n\nInstantiate Constants and Variables inline.\n\nConstants are instantiated with the $ interpolation syntax. Variables are instantiated with previously undefined symbols.\n\nwarning: Warning\nThis macro attempts to ignore symbols that are being assigned a value. For example, @atomize f(; x = p) = x ∧ q should be equivalent to f(; x = @atomize p)) = x ∧ @atomize q. However, this feature is in-progress and only works in some cases. The implementation is cautious to skip the parts of the expression that it cannot yet handle.\n\nExamples\n\njulia> @atomize x = p ∧ q\np ∧ q\n\njulia> @atomize x → r\n(p ∧ q) → r\n\njulia> @atomize $1 ∧ $(1 + 1)\n$(1) ∧ $(2)\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.@variables","page":"Propositions","title":"PAndQ.@variables","text":"@variables(ps...)\n\nDefine Variables and return a vector containing them.\n\nEach symbol p is defined as p = PAndQ.Variable(:p).\n\nExamples\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.constants","page":"Propositions","title":"PAndQ.constants","text":"constants(xs)\n\nInstantiate each element as a Constant.\n\nExamples\n\njulia> constants(1:2)\n2-element Vector{PAndQ.Constant{Int64}}:\n $(1)\n $(2)\n\njulia> constants([[1,2], [3,4]])\n2-element Vector{PAndQ.Constant{Vector{Int64}}}:\n $([1, 2])\n $([3, 4])\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Utilities","page":"Propositions","title":"Utilities","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"value\natoms\noperators\ninstall_atomize_mode","category":"page"},{"location":"manual/propositions/#PAndQ.value","page":"Propositions","title":"PAndQ.value","text":"value(p)\n\nIf p is logically equivalent to a Constant, return that value wrapped in Some. Otherwise, return nothing.\n\nValues wrapped in Some can be unwrapped using the something function.\n\nExamples\n\njulia> @atomize value(p)\n\njulia> @atomize value($1)\nSome(1)\n\njulia> @atomize something(value($2))\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.atoms","page":"Propositions","title":"PAndQ.atoms","text":"atoms(p)\n\nReturn an iterator of each Atom contained in p.\n\nExamples\n\njulia> @atomize collect(atoms(p ∧ q))\n2-element Vector{PAndQ.Variable}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.operators","page":"Propositions","title":"PAndQ.operators","text":"operators(p)\n\nReturn an iterator of each operator contained in p.\n\nExamples\n\njulia> @atomize collect(operators(¬p))\n1-element Vector{PAndQ.Interface.Operator{:not}}:\n ¬\n\njulia> @atomize collect(operators(¬p ∧ q))\n3-element Vector{PAndQ.Interface.Operator}:\n ∧\n ¬\n 𝒾\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.install_atomize_mode","page":"Propositions","title":"PAndQ.install_atomize_mode","text":"install_atomize_mode(;\n    start_key = \"\\M-a\", prompt_text = \"atomize> \", prompt_color = :cyan,\nkwargs...)\n\nInstall the atomize REPL mode, where input implicitly begins with @atomize.\n\nKeyword arguments are passed to ReplMaker.initrepl. The default start keys are pressing both the [Meta] (also known as [Alt]) and [a] keys at the same time. The available prompt_colors are in Base.text_colors.\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Normalization","page":"Propositions","title":"Normalization","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"normalize\ntseytin\ndimacs","category":"page"},{"location":"manual/propositions/#PAndQ.normalize","page":"Propositions","title":"PAndQ.normalize","text":"normalize(::Union{typeof(¬), typeof(∧), typeof(∨)}, p)\n\nConvert the given proposition to negation, conjunction, or disjunction normal form depending on whether the first argument is not, and, or or, respectively.\n\nConsidering the syntax tree of a normalized proposition, each leaf node is a literal; either an Atom or it's negation. Propositions in negation normal form are expanded such that the syntax tree branches only contain the operators and and or. Conjunction and disjunction normal forms are negated normal forms that have been flattened by recursively distributing either the and or or operator over the other. In other words, a collection of literals is a clause and a proposition in conjunctive or disjunctive normal form is a conjunction of disjunctive clauses or a disjunction of conjunctive clauses, respectively.\n\nConjunctive and disjunctive, but not negation, normal forms are called canonical. Distributing an operator during conversion increases the size of the syntax tree exponentially. Therefore, it is not possible to compute the canonical form for sufficiently large propositions. Use the tseytin transformation to find a proposition in conjunctive normal form which is_equisatisfiable.\n\nOperations between canonical propositions return another canonical proposition, while operations between canonical and non-canonical propositions return a non-canonical proposition. It is performant to apply the not operator to a proposition in canonical normal form and the and or or operator to two propositions in conjunction or disjunction normal form, respectively. It is not performant to convert a proposition between conjunction and disjunction normal form. Therefore, it is typically more performant to first perform operations on non-canonical propositions before converting them to a canonical form.\n\nExamples\n\njulia> @atomize normalize(∧, ¬(p ∨ q))\n(¬p) ∧ (¬q)\n\njulia> @atomize normalize(∨, p ↔ q)\n(¬q ∧ ¬p) ∨ (q ∧ p)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.tseytin","page":"Propositions","title":"PAndQ.tseytin","text":"tseytin(p)\n\nApply the Tseytin transformation to the given proposition.\n\nThe transformed proposition is normalized to conjunction form, contains introduced Variables, and is_equisatisfiable to p. The valuations of the transformed proposition that result in a true interpretation are a subset of the same for p.\n\nExamples\n\njulia> is_equisatisfiable(⊤, tseytin(⊤))\ntrue\n\njulia> @atomize is_equisatisfiable(p, tseytin(p))\ntrue\n\njulia> is_equisatisfiable(⊥, tseytin(⊥))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.dimacs","page":"Propositions","title":"PAndQ.dimacs","text":"dimacs(io = stdout, p)\n\nExamples\n\njulia> @atomize dimacs(p ↔ q)\np cnf 2 2\n1 -2 0\n-1 2 0\n\njulia> @atomize dimacs(String, p ↔ q)\n\"p cnf 2 2\\n1 -2 0\\n-1 2 0\\n\"\n\n\n\n\n\n","category":"function"},{"location":"tutorials/custom_operators/#custom_operators","page":"Custom Operators","title":"Custom Operators","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This tutorial will demonstrate how to implement custom operators using the operator Interface. This interface can be used to implement operators with custom behavior such as:","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Number of parameters\nLazy and eager evaluation\nSemantics\nAssociativity\nInitial value\nPretty printing\nSide-effects","category":"page"},{"location":"tutorials/custom_operators/#Setup","page":"Custom Operators","title":"Setup","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Implementing an operator requires defining methods for that operator. To do so, their function names must be imported or prefixed by the Interface module. This module also exports several other required and useful functions.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"import PAndQ:\n    Associativity, Evaluation,\n    arity, dual, evaluate, initial_value, pretty_print, symbol_of\nusing PAndQ\nusing .Interface","category":"page"},{"location":"tutorials/custom_operators/#Nullary","page":"Custom Operators","title":"Nullary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is a renamed tautology operator. First, define an Operator. If possible, this should be a constant whose name corresponds to the operator name.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"julia> const truth = Operator{:truth}()\nError showing value of type Operator{:truth}:\nERROR: InterfaceError: implement `symbol_of` for `Operator{:truth}()`","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"If a required method is not implemented, a runtime error will display the function and operator that a method must be implemented for. The error says to implement symbol_of. This function is used to represent an operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const truth = Operator{:truth}()","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"symbol_of(::typeof(truth)) = \"truth\";\ntruth\ntruth()","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement Evaluation. This function is used to specify whether an operator lazily or eagerly evaluates its arguments.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Evaluation(::typeof(truth)) = Lazy();\ntruth()","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement arity. This function is used to construct a node in a syntax tree.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"arity(::typeof(truth)) = 0;","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"truth","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement pretty_print. This function is used to represent a node of a syntax tree. The show_proposition function is used to represent the propositions in a node.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"pretty_print(io, o::typeof(truth)) = show(io, MIME\"text/plain\"(), o);\nTruthTable([truth])","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement evaluate. This function is used to specify the semantics of an operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"evaluate(::typeof(truth)) = ⊤;\nTruthTable([truth])","category":"page"},{"location":"tutorials/custom_operators/#Unary","page":"Custom Operators","title":"Unary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is an eagerly evaluated not operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const negate = Operator{:negate}();\nsymbol_of(::typeof(negate)) = \"negate\";\nnegate\nEvaluation(::typeof(negate), p) = Eager();\nevaluate(::typeof(negate), p) = evaluate(¬, p);\n@atomize negate(¬p)\n@atomize TruthTable([negate(p)])","category":"page"},{"location":"tutorials/custom_operators/#Binary","page":"Custom Operators","title":"Binary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is an imply operator represented by the --> symbol.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const if_then = --> = Operator{:if_then}();\nsymbol_of(::typeof(-->)) = \"-->\";\n-->\nEvaluation(::typeof(-->), p, q) = Lazy();\narity(::typeof(-->)) = 2;\nfunction pretty_print(io, o::typeof(-->), p, q)\n    root = io[:root]\n    root || print(io, \"(\")\n    show_proposition(io, p)\n    print(io, \" \")\n    show(io, MIME\"text/plain\"(), o)\n    print(io, \" \")\n    show_proposition(io, q)\n    root || print(io, \")\")\nend\n@atomize p --> q\nevaluate(::typeof(-->), p, q) = p → q;\n@atomize TruthTable([p --> q])\n@atomize fold(𝒾, (-->) => ())","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This error says to implement Associativity. This function is used to determine which direction to fold.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Associativity(::typeof(-->)) = Left();\n@atomize fold(𝒾, (-->) => ())","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This error says to implement initial_value. This function is used to determine the init parameter when folding.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"initial_value(::typeof(-->)) = Some(⊤);\n@atomize fold(𝒾, (-->) => ())\n@atomize fold(𝒾, (-->) => (p, q, r))","category":"page"},{"location":"tutorials/custom_operators/#Ternary","page":"Custom Operators","title":"Ternary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is a lazily evaluated conditional operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const conditional = Operator{:conditional}();\nsymbol_of(::typeof(conditional)) = \"?\";\nconditional\nEvaluation(::typeof(conditional), p, q, r) = Lazy();\narity(::typeof(conditional)) = 3;\nfunction pretty_print(io, o::typeof(conditional), p, q, r)\n    root = io[:root]\n    root || print(io, \"(\")\n    show_proposition(io, p)\n    print(io, \" ? \")\n    show_proposition(io, q)\n    print(io, \" : \")\n    show_proposition(io, r)\n    root || print(io, \")\")\nend;\n@atomize ¬conditional(p, q, r)\nevaluate(::typeof(conditional), p, q, r) = (p → q) ∧ (p ∨ r);\n@atomize TruthTable([conditional(p, q, r)])","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"julia> @atomize ❓(truth, negate(p), ampersand(p, q))\n(true ❓ !p : p & q)","category":"page"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nshow\nformatter\npretty_table(::IO, ::TruthTable)\nprint_tree","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(::Vector{String}, ::Matrix{Bool})\nTruthTable(ps)\n\nConstruct a truth table for the given Propositions.\n\nThe header is a vector containing vectors of logically equivalent propositions. The body is a matrix where the rows contain interpretations of each proposition in the given column.\n\nSee also Nullary Operators.\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\njulia> @atomize TruthTable([p ∧ ¬p, p → q, ¬p ∨ q])\n┌────────┬───┬───┬───────────────┐\n│ p ∧ ¬p │ p │ q │ p → q, ¬p ∨ q │\n├────────┼───┼───┼───────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊤             │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤             │\n├────────┼───┼───┼───────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥             │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤             │\n└────────┴───┴───┴───────────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#Base.show","page":"Printing","title":"Base.show","text":"show(::IO, ::MIME\"text/plain\", ::Operator)\n\nRepresent the given Operator as specified by symbol_of\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::Proposition)\n\nRepresent the given Proposition as a propositional formula.\n\nThe value of a Constant is shown with an IOContext whose :compact and :limit keys are individually set to true if they have not already been set.\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), p ∧ q)\np ∧ q\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), (p ∨ q) ∧ (r ∨ s))\n(p ∨ q) ∧ (r ∨ s)\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::TruthTable)\n\nRepresent the TruthTable in its default format.\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), TruthTable([p ∧ q]))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\nshow(::IO, ::Proposition)\n\nRepresent the Proposition verbosely.\n\nExamples\n\njulia> @atomize show(stdout, p ∧ q)\nand(PAndQ.Variable(:p), PAndQ.Variable(:q))\n\njulia> and(PAndQ.Variable(:p), PAndQ.Variable(:q))\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.formatter","page":"Printing","title":"PAndQ.formatter","text":"formatter(type)\n\nUse as the formatters keyword argument in pretty_table.\n\ntype formatter(type)(true, _, _) formatter(type)(false, _, _)\nNullaryOperator \"⊤\" \"⊥\"\nString \"tautology\" \"contradiction\"\nChar \"T\" \"F\"\nBool \"true\" \"false\"\nInt \"1\" \"0\"\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q; formatters = formatter(Int))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ 1 │ 1 │ 1     │\n│ 0 │ 1 │ 0     │\n├───┼───┼───────┤\n│ 1 │ 0 │ 0     │\n│ 0 │ 0 │ 0     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PrettyTables.pretty_table-Tuple{IO, TruthTable}","page":"Printing","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Union{IO, Type{<:Union{String, Docs.HTML}}} = stdout,\n    ::Union{NullaryOperator, Proposition, TruthTable};\n    formatters = formatter(NullaryOperator),\n    kwargs...\n)\n\nSee also Nullary Operators, Proposition, TruthTable, formatter, and PrettyTables.pretty_table.\n\nExamples\n\njulia> @atomize pretty_table(p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\njulia> @atomize pretty_table(p ∧ q; backend = Val(:markdown))\n| **p** | **q** | **p ∧ q** |\n|:------|:------|:----------|\n| ⊤     | ⊤     | ⊤         |\n| ⊥     | ⊤     | ⊥         |\n| ⊤     | ⊥     | ⊥         |\n| ⊥     | ⊥     | ⊥         |\n\njulia> @atomize print(pretty_table(String, p ∧ q; backend = Val(:html)))\n<table>\n  <thead>\n    <tr class = \"header headerLastRow\">\n      <th style = \"text-align: left;\">p</th>\n      <th style = \"text-align: left;\">q</th>\n      <th style = \"text-align: left;\">p ∧ q</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n\n\n","category":"method"},{"location":"manual/printing/#AbstractTrees.print_tree","page":"Printing","title":"AbstractTrees.print_tree","text":"print_tree(::IO = stdout, ::Proposition; kwargs...)\n\nPrints a tree diagram of the given Proposition.\n\nSee also AbstractTrees.print_tree.\n\njulia> @atomize print_tree(p ∧ q ∨ ¬s)\n∨\n├─ ∧\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ 𝒾\n│     └─ q\n└─ ¬\n   └─ s\n\njulia> @atomize print_tree(normalize(∧, p ∧ q ∨ ¬s))\n∧\n├─ ∨\n│  ├─ ¬\n│  │  └─ s\n│  └─ 𝒾\n│     └─ p\n└─ ∨\n   ├─ ¬\n   │  └─ s\n   └─ 𝒾\n      └─ q\n\n\n\n\n\n","category":"function"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page demonstrates the basic functionality of this package. For additional features and documentation, see the Tutorials and Manual.","category":"page"},{"location":"getting_started/#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Operators are functions represented by a symbol that return a symbolic expression.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The operators tautology and contradiction are similar to the boolean values true and false, respectively. These operators are represented with the symbols ⊤ and ⊥ and return themselves when called.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ⊤()\n⊤\n\njulia> ⊥()\n⊥","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The symbols ! and ¬ both represent the unary operator not. The symbols & and ∧ represent the binary operator and.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> !true\nfalse\n\njulia> true & false\nfalse\n\njulia> ¬⊤\n¬⊤\n\njulia> ⊤ ∧ ⊥\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/#Propositions","page":"Getting Started","title":"Propositions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A proposition is a statement that can be either true or false. For example, \"Logic is fun\". This proposition has a known value, so it is a constant. Note that the proposition exists independently of whether it is known to be true or false. Constants can be instantiated inline with the @atomize macro and unwrapped with the value function.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p = @atomize $\"Logic is fun\"\n$(\"Logic is fun\")\n\njulia> q = @atomize $\"Julia is awesome\"\n$(\"Julia is awesome\")\n\njulia> map(something ∘ value, [p, q])\n2-element Vector{String}:\n \"Logic is fun\"\n \"Julia is awesome\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A proposition can be negated, such as \"Logic is not fun\". Propositions can be connected, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ¬p\n¬$(\"Logic is fun\")\n\njulia> p ∧ q\n$(\"Logic is fun\") ∧ $(\"Julia is awesome\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Variables represent a proposition with an arbitrary value. Use the @atomize macro to instantiate them inline or the @variables macro to define multiple variables at once.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> ¬p\n¬p\n\njulia> p ∧ q\np ∧ q","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The tautology and contradiction operators can interoperate with both booleans and propositions. However, booleans and propositions cannot interoperate.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> Bool(⊤)\ntrue\n\njulia> true ∧ ⊤\ntrue\n\njulia> ⊤ ∧ p\n⊤ ∧ p","category":"page"},{"location":"getting_started/#Semantics","page":"Getting Started","title":"Semantics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Constants and variables are atomic propositions. Operators construct compound propositions from one or more atomic propositions. Each atom in a proposition can be assigned the valuation true or false. This results in an interpretation, which determines the truth value of the overall proposition. For example, assigning the valuation true to the atomic proposition \"Logic is fun\" determines that the compound proposition \"Logic is not fun\" is interpreted as false. Use the interpret function to assign truth values to atomic propositions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> interpret(p => ⊤, p ∧ q)\n⊤ ∧ q\n\njulia> interpret([p => ⊤, q => ⊥], p ∧ q)\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. Use == to check if two propositions are logically equivalent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p ∧ ¬p == ⊥\ntrue\n\njulia> p ∧ ¬p === ⊥\nfalse","category":"page"},{"location":"getting_started/#Printing","page":"Getting Started","title":"Printing","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"TruthTables are used to enumerate the interpretations of propositions. The header contains propositions and the atoms composing them. Each column corresponds to the truth values of the proposition in the header. Each row represents an interpretation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> TruthTable([⊤, ¬p, p ∧ q])\n┌───┬───┬───┬────┬───────┐\n│ ⊤ │ p │ q │ ¬p │ p ∧ q │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊤ │ ⊥  │ ⊤     │\n│ ⊤ │ ⊥ │ ⊤ │ ⊤  │ ⊥     │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊥ │ ⊥  │ ⊥     │\n│ ⊤ │ ⊥ │ ⊥ │ ⊤  │ ⊥     │\n└───┴───┴───┴────┴───────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is a computer algebra system for propositional logic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First-class propositions\nSyntax and pretty-printing corresponding to written logic\nEasy instantiation\nCustom REPL mode\nNormalization\nNegated, conjunctive, and disjunctive forms\nTseytin transformation\nDIMACS format\nInterface for custom operators\nSatisfiability solving\nLogical equivalence\nPartial interpretation\nDiagrams\nSyntax trees\nTruth tables\nPlain text, HTML, Markdown, and LaTeX output\nConvert propositions to LaTeX","category":"page"},{"location":"#Planned","page":"Home","title":"Planned","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interfaces\nOperators\nPropositions\nSimplification\nSubstitution\nProofs\nGenerate propositions\nNormal forms\nAlgebraic, Blake\nMinimization\nDiagrams\nDecision trees\nCircuits\nModal logic\nFirst order logic\nLambda calculus\nElectronic circuits\nSatisfiability modulo theories","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊤\n¬⊤\n\njulia> @atomize p ∧ q → $1\n(p ∧ q) → $(1)\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> r = p ↔ q\np ↔ q\n\njulia> interpret(p => ⊤, r)\n⊤ ↔ q\n\njulia> valuation = collect(only(solutions(p ∧ q)))\n2-element Vector{Pair{PAndQ.Variable, Bool}}:\n PAndQ.Variable(:p) => 1\n PAndQ.Variable(:q) => 1\n\njulia> interpret(valuation, p ∧ q)\ntrue\n\njulia> s = normalize(∧, r)\n(¬p ∨ q) ∧ (¬q ∨ p)\n\njulia> TruthTable([p ∧ ¬p, ¬p, r, s])\n┌────────┬───┬───┬────┬────────────────────────────┐\n│ p ∧ ¬p │ p │ q │ ¬p │ p ↔ q, (¬p ∨ q) ∧ (¬q ∨ p) │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥  │ ⊤                          │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤  │ ⊥                          │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥  │ ⊥                          │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤  │ ⊤                          │\n└────────┴───┴───┴────┴────────────────────────────┘","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#Logic","page":"Home","title":"Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nImplements a Prolog-like logic programming language for propositional and first-order logic\nLogicCircuits.jl\nImplements propositional logic with support for SIMD and CUDA\nSoleLogics.jl\nImplements propositional and modal logic\nTruthTables.jl\nImplements a macro that prints a truth table\nPAndQ.jl implements a superset of the features in this package\nMathematicalPredicates.jl\nImplements propositional logic\nPAndQ.jl, Julog.jl, and SoleLogics.jl implement a superset of the features in this package\nSatifsiability.jl\nAn interface to satisfiability modulo theory solvers\nSolvers must be installed on the user's system","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PicoSat.jl\nAn interface to the PicoSAT solver using PicoSAT_jll.jl\nZ3.jl\nAn interface to the Z3 Theorem Prover using z3_jll.jl\nCommits type piracy","category":"page"},{"location":"#Binaries","page":"Home","title":"Binaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These packages are generated by BinaryBuilder.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"libpicosat_jll.jl\nPicoSAT_jll.jl\nz3_jll.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Metatheory.jl\nSymbolicUtils.jl\nSymbolics.jl\nOscar.jl\nCatlab.jl","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl\nConstraintSolver.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed.jl\nCPLEXCP.jl\nBeeEncoder.jl\n3+ years since last update","category":"page"},{"location":"tutorials/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"This tutorial will demonstrate how to solve a Sudoku puzzle by encoding the rules sudoku into propositional logic. Although it is more computationally efficient to frame Sudoku as an optimization problem, it is a good example of a non-trivial logic problem.","category":"page"},{"location":"tutorials/sudoku/#Setup","page":"Sudoku","title":"Setup","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"using PAndQ\nusing PrettyTables: pretty_table","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Grid","page":"Sudoku","title":"Creating a Grid","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is traditionally played on a 9x9 grid.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"lines = collect(0:3:9);\ngrid = zeros(Int, 9, 9);\nprint_grid(grid) = pretty_table(\n    map(cell -> cell == 0 ? \"⋅\" : string(cell), grid);\n    vlines = lines, hlines = lines, show_header = false\n);\nprint_grid(grid)","category":"page"},{"location":"tutorials/sudoku/#Encoding-the-Rules","page":"Sudoku","title":"Encoding the Rules","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The grid is currently empty. Placing random numbers in some of the cells has a very high probability of generating an unsolvable board. Knowing which numbers to place in each cell requires the same functionality that it takes to solve the board in the first place. Encoding the rules of Sudoku into a proposition means that any solution to that proposition can be decoded into a solution of Sudoku.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given the predicate p(row, column, number) is true when the given row and column of the grid contains the given number:","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"p(row, column, number) = @atomize $((row, column) => number);","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"1. Each row contains each number from 1 to 9. This proposition can be read as \"for each row and for each number, one of the cells in that row contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_n = 1^9 bigveelimits_j = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"one = fold((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do i, n, j\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"2. Each column contains each number from 1 to 9. This proposition can be read as \"for each column and for each number, one of the cells of that column contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^9 bigveelimits_i = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"two = fold((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do j, n, i\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"3. Each 3x3 subgrid contains each number from 1 to 9. This proposition can be read as \"for each 3x3 subgrid and for each number, one of the cells of that subgrid contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_r = 0^2 bigwedgelimits_c = 0^2 bigwedgelimits_n = 1^9 bigveelimits_i = 1^3 bigveelimits_j = 1^3 P(3r + i 3c + j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"three = fold(\n    (∧) => 0:2, (∧) => 0:2, (∧) => 1:9, (∨) => 1:3, (∨) => 1:3\n) do r, c, n, i, j\n    p(3r + i, 3c + j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"4. Each cell contains a single number. This proposition can be read as \"for each cell and for pair of unique numbers, that cell does not contain both numbers\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^8 bigwedgelimits_m = n + 1^9 P(i j n)  P(i j m)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"four = fold((∧) => 1:9, (∧) => 1:9, (∧) => 1:8) do i, j, n\n    fold((∧) => n + 1:9) do m\n        ¬p(i, j, n) ∨ ¬p(i, j, m)\n    end\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The conjunction of these rules represent the encoding.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"rules = ⋀((one, two, three, four));","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"note: Note\nSee also @atomize, fold, conjunction, and, and or.","category":"page"},{"location":"tutorials/sudoku/#Finding-a-Solution","page":"Sudoku","title":"Finding a Solution","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given a proposition, valuations that result in a true interpretation can be found using the solutions function. Since the encoding does not specify any initial values of the cells, there will be many possible solutions to the proposition. Each solution contains 729 assignments of a Constants to a Bool, which makes sense because the 9x9 grid has 81 cells and each cell contains one of 9 possible numbers.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"first_solution(p) = collect(first(solutions(p)));\nsolution = first_solution(rules)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The assignments from a Constant to true correspond to cells that contain the given numbers. There are 81 such constants, with each value corresponding to a cell in the grid.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"extract(solution) = map(something ∘ value ∘ first, filter(last, solution));\ncells = extract(solution)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Each cell is a Pair in the form (row, column) => number, which maps from the row and column of the grid to its corresponding number.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"function decode!(grid, cells)\n    for ((row, column), value) in cells\n        grid[row, column] = value\n    end\n\n    grid\nend;\nprint_grid(decode!(grid, cells))","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Puzzle","page":"Sudoku","title":"Creating a Puzzle","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now that a solution has been found, it can be used to create a puzzle by removing some of the known values.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"print_grid(grid .*= rand(Bool, 9, 9))","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Since the rules represent an empty Sudoku grid, finding a solution to this puzzle means encoding the initial values as additional rules and finding a solution to the combined ruleset. If a grid has no solutions, then it contains a contradiction to the rules.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"print_grid(decode!(grid, extract(first_solution(rules ∧ ⋀(map(\n    i -> p(i.I..., grid[i]), filter(i -> grid[i] != 0, CartesianIndices(grid))))))))","category":"page"},{"location":"manual/interface/#interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"This interface is used to implement the built-in operators and can be used to implement custom operators.","category":"page"},{"location":"manual/interface/#Methods","page":"Interface","title":"Methods","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"These methods are required to be implemented for some functionalities. If a required method is not implemented, a runtime error will display the function and operator that a method must be implemented for. Default implementations of are not provided so as to avoid correctness bugs.","category":"page"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Operator\nInterface.arity","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Operator","page":"Interface","title":"PAndQ.Interface.Operator","text":"Operator{O}\nOperator{O}()\n\nReturn an operator named O.\n\nOperators are uniquely identified by their name. If possible, an operator should be defined as const o = ℴ = Operator{:o}() where symbol_of(ℴ) == \"ℴ\".\n\nThis method is required to instantiate an operator.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.arity","page":"Interface","title":"PAndQ.Interface.arity","text":"arity(::Operator)\n\nReturn the number of propositions accepted by the Operator.\n\nThis method is required for Lazy operators.\n\nExamples\n\njulia> Interface.arity(⊤)\n0\n\njulia> Interface.arity(¬)\n1\n\njulia> Interface.arity(∧)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Evaluation","page":"Interface","title":"Evaluation","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Evaluation\nInterface.evaluate","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Evaluation","page":"Interface","title":"PAndQ.Interface.Evaluation","text":"Evaluation(::Operator, ps...)\n\nA trait to specify the behavior of calling an Operator with the given propositions.\n\nThis method is required to call the given operator.\n\nSupertype of Eager and Lazy.\n\nExamples\n\njulia> @atomize Interface.Evaluation(𝒾, p)\nPAndQ.Interface.Eager()\n\njulia> @atomize Interface.Evaluation(¬, p)\nPAndQ.Interface.Lazy()\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.evaluate","page":"Interface","title":"PAndQ.Interface.evaluate","text":"evaluate(::Operator, ps...)\n\nDefine the semantics of the Operator.\n\nThis method is required to normalize a proposition containing the given operator.\n\nExamples\n\njulia> @atomize Interface.evaluate(¬, ¬p)\np\n\njulia> @atomize Interface.evaluate(→, p, q)\n¬p ∨ q\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Folding","page":"Interface","title":"Folding","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Associativity\nInterface.initial_value","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Associativity","page":"Interface","title":"PAndQ.Interface.Associativity","text":"Associativity(ℴ::Operator)\n\nA trait to specify the associativity of an Operator.\n\nnote: Note\nThis trait is used internally and does not override how expressions are parsed.\n\nThis method is required for calling fold over ℴ.\n\nSupertype of Left and Right.\n\nExamples\n\njulia> Interface.Associativity(→)\nPAndQ.Interface.Left()\n\njulia> Interface.Associativity(←)\nPAndQ.Interface.Right()\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.initial_value","page":"Interface","title":"PAndQ.Interface.initial_value","text":"initial_value(ℴ::Operator)\n\nSpecify a neutral value, v, of a binary Operator such that ℴ(v, p) == p.\n\nTo distinguish between an initial value and the absense of a neutral value, return Some(v) or nothing, respectively.\n\nThis method is required for calling fold over ℴ.\n\nSee also ==.\n\nExamples\n\njulia> Interface.initial_value(∧)\nSome(PAndQ.Interface.Operator{:tautology}())\n\njulia> Interface.initial_value(∨)\nSome(PAndQ.Interface.Operator{:contradiction}())\n\njulia> Interface.initial_value(↑)\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Printing","page":"Interface","title":"Printing","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.pretty_print\nInterface.symbol_of","category":"page"},{"location":"manual/interface/#PAndQ.Interface.pretty_print","page":"Interface","title":"PAndQ.Interface.pretty_print","text":"pretty_print(io, ::Operator, ps...)\n\nRepresent the node of a syntax tree containing the Operator and its propositions.\n\nNodes of a syntax tree may either be a root or a branch. Some branches need to be parenthesized to avoid ambiguity. This context can be obtained using io[:root].\n\nEach proposition should be represented using show_proposition.\n\nThis method is required for calling show(::IO, ::MIME\"text/plain, p) for a proposition p containing the given operator.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.symbol_of","page":"Interface","title":"PAndQ.Interface.symbol_of","text":"symbol_of(ℴ::Operator)\n\nReturn the Unicode symbol of the Operator.\n\nIf possible, this should be implemented as symbol_of(::typeof(ℴ)) = \"ℴ\".\n\nThis method is required for calling show(::IO, ::MIME\"text/plain\", ::typeof(ℴ)).\n\nSee also show.\n\nExamples\n\njulia> Interface.symbol_of(⊤)\n\"⊤\"\n\njulia> Interface.symbol_of(¬)\n\"¬\"\n\njulia> Interface.symbol_of(∧)\n\"∧\"\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Utilities","page":"Interface","title":"Utilities","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"These functions may be necessary or useful for implementing the operator interface.","category":"page"},{"location":"manual/interface/#Evaluation-2","page":"Interface","title":"Evaluation","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Eager\nInterface.Lazy","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Eager","page":"Interface","title":"PAndQ.Interface.Eager","text":"Eager <: Evaluation\nEager()\n\nA trait to specify that an Operator is eagerly evaluated.\n\nEagerly evaluated operators return the expression specified by evaluate.\n\nSubtype of Evaluation.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.Lazy","page":"Interface","title":"PAndQ.Interface.Lazy","text":"Lazy <: Evaluation\nLazy()\n\nA trait to specify that an Operator is lazily evaluated.\n\nLazily evaluated operators return a syntax tree.\n\nSubtype of Evaluation.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Associativity","page":"Interface","title":"Associativity","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Left\nInterface.Right","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Left","page":"Interface","title":"PAndQ.Interface.Left","text":"Left <: Associativity\n\nA trait to specify that an Operator is left-associative.\n\nSubtype of Associativity.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.Right","page":"Interface","title":"PAndQ.Interface.Right","text":"Right <: Associativity\n\nA trait to specify that an Operator is right-associative.\n\nSubtype of Associativity.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Printing-2","page":"Interface","title":"Printing","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.name_of\nInterface.show_proposition","category":"page"},{"location":"manual/interface/#PAndQ.Interface.name_of","page":"Interface","title":"PAndQ.Interface.name_of","text":"name_of(::Operator{O})\n\nReturn O, the name of an Operator.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.show_proposition","page":"Interface","title":"PAndQ.Interface.show_proposition","text":"show_proposition(io, p)\n\nRepresent the given proposition with the IOContext that :root => false.\n\nShould be called from pretty_print.\n\nExamples\n\njulia> @atomize show_proposition(stdout, ¬p)\n¬p\n\njulia> @atomize show_proposition(stdout, p ∧ q)\n(p ∧ q)\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Properties","page":"Interface","title":"Properties","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.converse\nInterface.dual","category":"page"},{"location":"manual/interface/#PAndQ.Interface.converse","page":"Interface","title":"PAndQ.Interface.converse","text":"converse(ℴ::Operator)\n\nReturn a function, 𝒸, such that converse(ℴ)(p, q) == 𝒸(q, p).\n\nIf possible, this method should be overloaded to return an Operator.\n\nSee also ==.\n\nExamples\n\njulia> Interface.converse(∧)\n∧\n\njulia> Interface.converse(→)\n←\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.dual","page":"Interface","title":"PAndQ.Interface.dual","text":"dual(ℴ::Operator)\n\nReturn a function, 𝒹, such that ¬ℴ(ps...) == 𝒹(map(¬, ps)...).\n\nIf possible, this method should be overloaded to return an Operator.\n\nSee also not and ==.\n\nExamples\n\njulia> Interface.dual(and)\n∨\n\njulia> Interface.dual(imply)\n↚\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Predicates","page":"Interface","title":"Predicates","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.is_associative\nInterface.is_commutative","category":"page"},{"location":"manual/interface/#PAndQ.Interface.is_associative","page":"Interface","title":"PAndQ.Interface.is_associative","text":"is_associative(ℴ::Operator)\n\nReturn a boolean indicating whether has the associative property such that ℴ(ℴ(p, q), r) == ℴ(p, ℴ(q, r)).\n\nSee also ==.\n\nExamples\n\njulia> Interface.is_associative(∧)\ntrue\n\njulia> Interface.is_associative(→)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.is_commutative","page":"Interface","title":"PAndQ.Interface.is_commutative","text":"is_commutative(ℴ::Operator)\n\nReturn a boolean indicating whether has the commutative property such that ℴ(p, q) == ℴ(q, p).\n\nSee also ==.\n\nExamples\n\njulia> Interface.is_commutative(∧)\ntrue\n\njulia> Interface.is_commutative(→)\nfalse\n\n\n\n\n\n","category":"function"}]
}
