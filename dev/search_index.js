var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.union_typeof","category":"page"},{"location":"manual/internals/#PAndQ.union_typeof","page":"Internals","title":"PAndQ.union_typeof","text":"union_typeof(xs)\n\nEquivalent to Union{map(typeof, xs)...}.\n\nExamples\n\njulia> PAndQ.union_typeof((⊤, ¬, ∧))\nUnion{PAndQ.Interface.Operator{:tautology}, PAndQ.Interface.Operator{:not}, PAndQ.Interface.Operator{:and}}\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Solvers","page":"Internals","title":"Solvers","text":"","category":"section"},{"location":"manual/internals/#Z3","page":"Internals","title":"Z3","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Z3\nPAndQ.Z3.Library\nPAndQ.Z3.add_clause\nPAndQ.Z3.Solutions\nPAndQ.Z3.IteratorSize(::Type{PAndQ.Z3.Solutions})\nPAndQ.Z3.eltype(::Type{PAndQ.Z3.Solutions})\nPAndQ.Z3.isdone(::PAndQ.Z3.Solutions)\nPAndQ.Z3.iterate(::PAndQ.Z3.Solutions, ::Any)","category":"page"},{"location":"manual/internals/#PAndQ.Z3","page":"Internals","title":"PAndQ.Z3","text":"Z3\n\nThis module provides an interface to z3_jll.jl.\n\n\n\n\n\n","category":"module"},{"location":"manual/internals/#PAndQ.Z3.Library","page":"Internals","title":"PAndQ.Z3.Library","text":"Library\n\n\n\n\n\n","category":"module"},{"location":"manual/internals/#PAndQ.Z3.add_clause","page":"Internals","title":"PAndQ.Z3.add_clause","text":"add_clause(context, solver, clause)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.Z3.Solutions","page":"Internals","title":"PAndQ.Z3.Solutions","text":"Solutions\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Base.IteratorSize-Tuple{Type{PAndQ.Z3.Solutions}}","page":"Internals","title":"Base.IteratorSize","text":"IteratorSize(::Type{Solutions})\n\nExamples\n\njulia> Base.IteratorSize(PAndQ.Z3.Solutions)\nBase.SizeUnknown()\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.eltype-Tuple{Type{PAndQ.Z3.Solutions}}","page":"Internals","title":"Base.eltype","text":"eltype(::Type{Solutions})\n\nThe type of the elements generated by a Solutions iterator.\n\nExamples\n\njulia> eltype(PAndQ.Z3.Solutions)\nVector{Bool} (alias for Array{Bool, 1})\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.isdone-Tuple{PAndQ.Z3.Solutions}","page":"Internals","title":"Base.isdone","text":"isdone\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.iterate-Tuple{PAndQ.Z3.Solutions, Any}","page":"Internals","title":"Base.iterate","text":"iterate\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#PicoSAT","page":"Internals","title":"PicoSAT","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT","page":"Internals","title":"PAndQ.PicoSAT","text":"PicoSAT\n\nThis module provides an interface to libpicosat_jll.jl.\n\n\n\n\n\n","category":"module"},{"location":"manual/internals/#Library","page":"Internals","title":"Library","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT.picosat_init\nPAndQ.PicoSAT.picosat_reset\nPAndQ.PicoSAT.picosat_add\nPAndQ.PicoSAT.picosat_adjust\nPAndQ.PicoSAT.picosat_variables\nPAndQ.PicoSAT.picosat_print\nPAndQ.PicoSAT.picosat_sat\nPAndQ.PicoSAT.picosat_deref","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_init","page":"Internals","title":"PAndQ.PicoSAT.picosat_init","text":"picosat_init()\n\nConstruct a new PicoSAT instance and return a pointer to it.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_reset","page":"Internals","title":"PAndQ.PicoSAT.picosat_reset","text":"picosat_reset(pico_sat)\n\nDestruct the pico_sat instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_add","page":"Internals","title":"PAndQ.PicoSAT.picosat_add","text":"picosat_add(pico_sat, literal)\n\nAppend the literal to the pico_sat instance's current disjunctive clause.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_adjust","page":"Internals","title":"PAndQ.PicoSAT.picosat_adjust","text":"picosat_adjust\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_variables","page":"Internals","title":"PAndQ.PicoSAT.picosat_variables","text":"picosat_variables(pico_sat)\n\nReturn the number of unique atoms in the pico_sat instance.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_print","page":"Internals","title":"PAndQ.PicoSAT.picosat_print","text":"picosat_print(pico_sat, file)\n\nWrite the DIMACS format of the pico_sat instance's proposition to the given file.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_sat","page":"Internals","title":"PAndQ.PicoSAT.picosat_sat","text":"picosat_sat(pico_sat, limit)\n\nSearch for a satisfiable assignment of the pico_sat instance's proposition and return 0, 10, or 20 if the status is unknown, satisfiable, or unsatisfiable, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.picosat_deref","page":"Internals","title":"PAndQ.PicoSAT.picosat_deref","text":"picosat_deref(pico_sat, atom)\n\nReturn the assignment of the atom, where 1, -1, and 0 indicate true, false, and unknown, respectively.\n\nThis function must be called after verifying that the status of picosat_sat is satisfiable.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.PicoSAT.add_clause\nPAndQ.PicoSAT.initialize\nPAndQ.PicoSAT.Solutions\nPAndQ.PicoSAT.eltype(::Type{PAndQ.PicoSAT.Solutions})\nPAndQ.PicoSAT.IteratorSize(::Type{PAndQ.PicoSAT.Solutions})\nPAndQ.PicoSAT.isdone(::PAndQ.PicoSAT.Solutions)\nPAndQ.PicoSAT.iterate(::PAndQ.PicoSAT.Solutions, ::Any)\nPAndQ.PicoSAT.print_dimacs","category":"page"},{"location":"manual/internals/#PAndQ.PicoSAT.add_clause","page":"Internals","title":"PAndQ.PicoSAT.add_clause","text":"add_clause(pico_sat, clause)\n\nMutate the pico_sat instance's proposition to be the conjunction of itself and the disjunctive clause.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.initialize","page":"Internals","title":"PAndQ.PicoSAT.initialize","text":"initialize(clauses, n)\n\nReturn a PicoSAT pointer with its proposition being a conjunction of the disjunctive clauses.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.PicoSAT.Solutions","page":"Internals","title":"PAndQ.PicoSAT.Solutions","text":"Solutions\nSolutions(clauses)\n\nA stateful iterator of valuations that satisfy the given proposition.\n\nCalling finalize on this iterator will first check whether it has already been finalized. If not, it will call picosat_reset on its PicoSAT pointer and set the pointer equal to C_NULL.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Base.eltype-Tuple{Type{PAndQ.PicoSAT.Solutions}}","page":"Internals","title":"Base.eltype","text":"eltype(::Type{Solutions})\n\nThe type of the elements generated by a Solutions iterator.\n\nExamples\n\njulia> eltype(PAndQ.PicoSAT.Solutions)\nVector{Bool} (alias for Array{Bool, 1})\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.IteratorSize-Tuple{Type{PAndQ.PicoSAT.Solutions}}","page":"Internals","title":"Base.IteratorSize","text":"IteratorSize(::Type{Solutions})\n\nSince counting the number of Solutions to a proposition is intractable, its IteratorSize is Base.SizeUnknown.\n\nExamples\n\njulia> Base.IteratorSize(PAndQ.PicoSAT.Solutions)\nBase.SizeUnknown()\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.isdone-Tuple{PAndQ.PicoSAT.Solutions}","page":"Internals","title":"Base.isdone","text":"isdone(solutions::Solutions, pico_sat = solutions.pico_sat)\n\nReturn a Boolean whether the pico_sat instance can yield any more solutions without advancing the Solutions iterator.\n\nFinalize the iterator if it has not yet been finalized and is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#Base.iterate-Tuple{PAndQ.PicoSAT.Solutions, Any}","page":"Internals","title":"Base.iterate","text":"iterate(solutions::Solutions, pico_sat = solutions.pico_sat)\n\nIf the status of pico_sat is satisfiable, return a Tuple of the current solution and pico_sat. Otherwise, finalize the solutions and return nothing.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#PAndQ.PicoSAT.print_dimacs","page":"Internals","title":"PAndQ.PicoSAT.print_dimacs","text":"print_dimacs(io, clauses, n)\n\nPrint the DIMACS format of the conjunctive clauses.\n\nExamples\n\njulia> PAndQ.PicoSAT.print_dimacs(stdout, [[-1, -2], [1, 2]], 2)\np cnf 2 2\n-1 -2 0\n1 2 0\n\njulia> PAndQ.PicoSAT.print_dimacs(stdout, [[1, -2], [-1, 2]], 2)\np cnf 2 2\n1 -2 0\n-1 2 0\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Interface","page":"Internals","title":"Interface","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Interface.InterfaceError\nInterface.showerror\nInterface.@interface","category":"page"},{"location":"manual/internals/#PAndQ.Interface.InterfaceError","page":"Internals","title":"PAndQ.Interface.InterfaceError","text":"InterfaceError{F <: Function, O <: Operator} <: Exception\nInterfaceError(::F, ::O)\n\nAn Exception indicating that the function of type F has not been implemented for the value of type T.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Base.showerror","page":"Internals","title":"Base.showerror","text":"showerror(::IO, ::InterfaceError)\n\nPrint a message indicating to implement a method of an interface.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.Interface.@interface","page":"Internals","title":"PAndQ.Interface.@interface","text":"@interface(f, xs...)\n\nDefine a fallback method that throws an InterfaceError.\n\n\n\n\n\n","category":"macro"},{"location":"manual/internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.NaryOperator\nPAndQ.AndOr","category":"page"},{"location":"manual/internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of Nullary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of Unary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of Binary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.NaryOperator","page":"Internals","title":"PAndQ.NaryOperator","text":"NaryOperator\n\nThe Union of Nary Operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Kind","category":"page"},{"location":"manual/internals/#PAndQ.Kind","page":"Internals","title":"PAndQ.Kind","text":"Kind\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.AbstractSyntaxTree","category":"page"},{"location":"manual/internals/#PAndQ.AbstractSyntaxTree","page":"Internals","title":"PAndQ.AbstractSyntaxTree","text":"AbstractSyntaxTree\n\nA proposition represented by an abstract syntax tree.\n\nSee also Operator.\n\nExamples\n\njulia> PAndQ.AbstractSyntaxTree(⊤)\n⊤\n\njulia> @atomize PAndQ.AbstractSyntaxTree(¬, [p])\n¬p\n\njulia> @atomize PAndQ.AbstractSyntaxTree(and, [PAndQ.AbstractSyntaxTree(p), PAndQ.AbstractSyntaxTree(q)])\np ∧ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.jl","page":"Internals","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.children\nPAndQ.nodevalue\nPAndQ.printnode","category":"page"},{"location":"manual/internals/#AbstractTrees.children","page":"Internals","title":"AbstractTrees.children","text":"children(::AbstractSyntaxTree)\n\nReturn an iterator over the child nodes of the given proposition.\n\nSee also AbstractSyntaxTree.\n\nExamples\n\njulia> @atomize PAndQ.children(¬p)\n1-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n\njulia> @atomize PAndQ.children(p ∧ q)\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.nodevalue","page":"Internals","title":"AbstractTrees.nodevalue","text":"nodevalue(::AbstractSyntaxTree)\n\nReturn the Operator of the proposition's root node.\n\nSee also AbstractSyntaxTree.\n\nExamples\n\njulia> @atomize PAndQ.nodevalue(¬p)\n¬\n\njulia> @atomize PAndQ.nodevalue(p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.printnode","page":"Internals","title":"AbstractTrees.printnode","text":"printnode(::IO, ::Union{Operator, AbstractSyntaxTree}; kwargs...)\n\nPrint the representation of the proposition's root node.\n\nSee also Operator and AbstractSyntaxTree.\n\nExamples\n\njulia> @atomize PAndQ.printnode(stdout, p)\np\njulia> @atomize PAndQ.printnode(stdout, ¬p)\n¬\njulia> @atomize PAndQ.printnode(stdout, p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.deconstruct\nPAndQ.child\nPAndQ.atomize\nPAndQ.distribute\nPAndQ.prune\nPAndQ.reconstruct","category":"page"},{"location":"manual/internals/#PAndQ.deconstruct","page":"Internals","title":"PAndQ.deconstruct","text":"deconstruct(p)\n\nReturn (nodevalue(p), children(p)).\n\nSee also nodevalue and children.\n\nExamples\n\njulia> @atomize PAndQ.deconstruct(p)\n(PAndQ.AbstractSyntaxTree(:p), PAndQ.AbstractSyntaxTree[])\n\njulia> @atomize PAndQ.deconstruct(¬p)\n(not, PAndQ.AbstractSyntaxTree[PAndQ.AbstractSyntaxTree(:p)])\n\njulia> @atomize PAndQ.deconstruct(p ∧ q)\n(and, PAndQ.AbstractSyntaxTree[PAndQ.AbstractSyntaxTree(:p), PAndQ.AbstractSyntaxTree(:q)])\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.child","page":"Internals","title":"PAndQ.child","text":"child(x)\n\nEquivalent to only ∘ children.\n\nSee also children.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.atomize","page":"Internals","title":"PAndQ.atomize","text":"atomize(x)\n\nIf x is a symbol, return an expression that instantiates it as a variable if it is undefined in the caller's scope. If isexpr(x, :$), return an expression that instantiates it as a constant. If x is a different expression, traverse it with recursive calls to atomize. Otherise, return x.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.distribute","page":"Internals","title":"PAndQ.distribute","text":"distribute(p)\n\nGiven a proposition in negation normal form, return that proposition in conjunction normal form.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.prune","page":"Internals","title":"PAndQ.prune","text":"prune(p, atoms = AbstractSyntaxTree[], mapping = Dict{AbstractSyntaxTree, Int}())\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.reconstruct","page":"Internals","title":"PAndQ.reconstruct","text":"reconstruct(clauses, atoms)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"manual/internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.eval_pairs\nconvert\npromote_rule","category":"page"},{"location":"manual/internals/#PAndQ.eval_pairs","page":"Internals","title":"PAndQ.eval_pairs","text":"eval_pairs(f, pairs)\n\nDefine f(::typeof(left)) = right and f(::typeof(right)) = left for each pair left and right in pairs.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.convert","page":"Internals","title":"Base.convert","text":"convert(::Type{<:AbstractSytnaxTree}, p)\n\nSee also AbstractSyntaxTree.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Base.promote_rule","page":"Internals","title":"Base.promote_rule","text":"promote_rule\n\n\n\n\n\n","category":"function"},{"location":"tutorials/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"This tutorial will demonstrate how to solve a Sudoku puzzle by encoding its rules into propositional logic, which is a good example of a non-trivial logic problem.","category":"page"},{"location":"tutorials/sudoku/#Setup","page":"Sudoku","title":"Setup","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"using PAndQ, PrettyTables","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Grid","page":"Sudoku","title":"Creating a Grid","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is traditionally played on a 9x9 grid.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"lines = collect(0:3:9);\ngrid = zeros(Int, 9, 9);\nprint_grid(grid) = pretty_table(\n    map(cell -> cell == 0 ? \"⋅\" : string(cell), grid);\n    vlines = lines, hlines = lines, show_header = false\n);\nprint_grid(grid)","category":"page"},{"location":"tutorials/sudoku/#Encoding-the-Rules","page":"Sudoku","title":"Encoding the Rules","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The grid is currently empty. Placing random numbers in some of the cells has a very high probability of generating an unsolvable board. Knowing which numbers to place in each cell requires the same functionality that it takes to solve the board in the first place. Encoding the rules of Sudoku into a proposition means that any solution to that proposition can be decoded into a solution of Sudoku.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given the predicate p(row, column, number) is true when the given row and column of the grid contains the given number:","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"p(row, column, number) = @atomize $((row, column) => number);","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"1. Each row contains each number from 1 to 9. This proposition can be read as \"for each row and for each number, one of the cells in that row contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_n = 1^9 bigveelimits_j = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"one = fold((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do i, n, j\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"2. Each column contains each number from 1 to 9. This proposition can be read as \"for each column and for each number, one of the cells in that column contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^9 bigveelimits_i = 1^9 P(i j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"two = fold((∧) => 1:9, (∧) => 1:9, (∨) => 1:9) do j, n, i\n    p(i, j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"3. Each 3x3 subgrid contains each number from 1 to 9. This proposition can be read as \"for each 3x3 subgrid and for each number, one of the cells in that subgrid contains that number\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_r = 0^2 bigwedgelimits_c = 0^2 bigwedgelimits_n = 1^9 bigveelimits_i = 1^3 bigveelimits_j = 1^3 P(3r + i 3c + j n) ","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"three = fold(\n    (∧) => 0:2, (∧) => 0:2, (∧) => 1:9, (∨) => 1:3, (∨) => 1:3\n) do r, c, n, i, j\n    p(3r + i, 3c + j, n)\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"4. Each cell contains a single number. This proposition can be read as \"for each cell and for each pair of unique numbers, that cell does not contain both numbers\".","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"bigwedgelimits_i = 1^9 bigwedgelimits_j = 1^9 bigwedgelimits_n = 1^8 bigwedgelimits_m = n + 1^9 P(i j n)  P(i j m)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"four = fold((∧) => 1:9, (∧) => 1:9, (∧) => 1:8) do i, j, n\n    fold((∧) => n + 1:9) do m\n        ¬p(i, j, n) ∨ ¬p(i, j, m)\n    end\nend;","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The conjunction of these rules represent the encoding.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"rules = ⋀(one, two, three, four);","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"note: Note\nSee also @atomize, fold, conjunction, and, and or.","category":"page"},{"location":"tutorials/sudoku/#Finding-a-Solution","page":"Sudoku","title":"Finding a Solution","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Given a proposition, valuations that result in a true interpretation can be found using the solutions function. Since the encoding does not specify any initial values of the cells, there will be many possible solutions to the proposition. Each solution contains 729 assignments of a constant to a Bool, which makes sense because the 9x9 grid has 81 cells and each cell contains one of 9 possible numbers.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"first_solution(p) = collect(first(solutions(p)));\nsolution = first_solution(rules)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"The assignments from a constant to true correspond to cells that contain the given numbers. There are 81 such constants, with each value corresponding to a cell in the grid.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"extract(solution) = map(something ∘ value ∘ first, filter(last, solution));\ncells = extract(solution)","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Each cell is a Pair in the form (row, column) => number, which maps from the row and column of the grid to its corresponding number.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"function decode!(grid, cells)\n    for ((row, column), number) in cells\n        grid[row, column] = number\n    end\n\n    grid\nend;\nprint_grid(decode!(grid, cells))","category":"page"},{"location":"tutorials/sudoku/#Creating-a-Puzzle","page":"Sudoku","title":"Creating a Puzzle","text":"","category":"section"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now that a solution has been found, it can be used to create a puzzle by removing some of the known values.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"print_grid(grid .*= rand(Bool, 9, 9))","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"Since the rules represent an empty Sudoku grid, finding a solution to this puzzle means encoding the initial values as additional rules and finding a solution to the combined ruleset. If a grid has no solutions, then it contains a contradiction to the rules.","category":"page"},{"location":"tutorials/sudoku/","page":"Sudoku","title":"Sudoku","text":"print_grid(decode!(grid, extract(first_solution(rules ∧ ⋀(map(\n    i -> p(i.I..., grid[i]), filter(i -> grid[i] != 0, CartesianIndices(grid))))))))","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/#Latexify","page":"Extensions","title":"Latexify","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"This extension defines a @latexrecipe for operators, propositions, and TruthTables. Further, calling print_table with the LaTeX backend will latexify the truth table.","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"julia> using Latexify\n\njulia> @atomize latexify(p ∧ q)\nL\"$p \\wedge q$\"\n\njulia> @atomize latexify(TruthTable([p ∧ q]))\nL\"\\begin{tabular}{|l|l|l|}\n  \\hline\n  \\textbf{$p$} & \\textbf{$q$} & \\textbf{$p \\wedge q$} \\\\\\hline\n  $\\top$ & $\\top$ & $\\top$ \\\\\n  $\\bot$ & $\\top$ & $\\bot$ \\\\\\hline\n  $\\top$ & $\\bot$ & $\\bot$ \\\\\n  $\\bot$ & $\\bot$ & $\\bot$ \\\\\\hline\n\\end{tabular}\n\"","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"formatter(::Type{Latexify.LaTeXString})","category":"page"},{"location":"manual/extensions/#PAndQ.formatter-Tuple{Type{LaTeXStrings.LaTeXString}}","page":"Extensions","title":"PAndQ.formatter","text":"formatter(::Latexify.LaTeXString)\n\nExamples\n\njulia> formatter(Latexify.LaTeXString)(true, nothing, nothing)\nL\"$\\top$\"\n\njulia> formatter(Latexify.LaTeXString)(false, nothing, nothing)\nL\"$\\bot$\"\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This benchmark measures encoding, solving, and decoding a single solution to Sudoku. The times are given by the median of ten samples using BenchmarkTools.jl. Each package may have multiple implementations, so the minimum time of those is used. The implementation for PAndQ.jl corresponds to that of the Sudoku tutorial. The implementation for JuMP.jl is taken from their tutorial with minor modifications to satisfy the requirements of the benchmark.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"See also the repository benchmarks folder.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: benchmarks)","category":"page"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/#Truths","page":"Semantics","title":"Truths","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"valuations\ninterpret\ninterpretations\nsolutions","category":"page"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuations(atoms)\nvaluations(p)\n\nReturn an iterator of every possible valuation of the given atoms or the atoms contained in p.\n\nExamples\n\njulia> collect(valuations(⊤))\n0-dimensional Array{Vector{Union{}}, 0}:\n[]\n\njulia> @atomize collect(valuations(p))\n2-element Vector{Vector{Pair{PAndQ.AbstractSyntaxTree, Bool}}}:\n [PAndQ.AbstractSyntaxTree(:p) => 1]\n [PAndQ.AbstractSyntaxTree(:p) => 0]\n\njulia> @atomize collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.AbstractSyntaxTree, Bool}}}:\n [AbstractSyntaxTree(:p)=>1, AbstractSyntaxTree(:q)=>1]  …  [AbstractSyntaxTree(:p)=>1, AbstractSyntaxTree(:q)=>0]\n [AbstractSyntaxTree(:p)=>0, AbstractSyntaxTree(:q)=>1]     [AbstractSyntaxTree(:p)=>0, AbstractSyntaxTree(:q)=>0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(valuation, p)\n\nSubstitute each atom in p with values given by the valuation.\n\nThe valuation can be a Function that accepts an atom and returns a logical value, a Dictionary mapping from atoms to logical values, or an iterable that can construct such a dictionary. No substitution is performed if an atom is not one of the dictionary's keys.\n\nExamples\n\njulia> @atomize interpret(atom -> ⊤, ¬p)\n¬⊤\n\njulia> @atomize interpret([p => ⊤], p ∧ q)\n⊤ ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(valuations, p)\ninterpretations(p)\n\nReturn an Array{Bool} given by interpreting p with each of the valuations.\n\nExamples\n\njulia> collect(interpretations(⊤))\n0-dimensional Array{Bool, 0}:\n1\n\njulia> @atomize collect(interpretations(p))\n2-element Vector{Bool}:\n 1\n 0\n\njulia> @atomize collect(interpretations(p ∧ q))\n2×2 Matrix{Bool}:\n 1  0\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solutions","page":"Semantics","title":"PAndQ.solutions","text":"solutions(p; solver = Z3)\n\nReturn a stateful iterator of valuations such that interpret(valuation, p) == ⊤.\n\nTo find every valuation that results in a true interpretation, convert the proposition to conjunctive normal form using normalize. Otherwise, a subset of those valuations will be identified using the tseytin transformation.\n\nThe solver can be either Z3 or PicoSAT.\n\nSee also interpret and tautology.\n\nExamples\n\njulia> @atomize solutions(p ∧ q)[1]\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n q\n p\n\njulia> @atomize collect(only(solutions(p ∧ q)[2]))\n2-element Vector{Bool}:\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Predicates","page":"Semantics","title":"Predicates","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"is_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable\nis_equisatisfiable","category":"page"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturn a Boolean indicating whether the given proposition is logically equivalent to a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @atomize is_tautology(p)\nfalse\n\njulia> @atomize is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturn a Boolean indicating whether the given proposition is logically equivalent to a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @atomize is_contradiction(p)\nfalse\n\njulia> @atomize is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturn a Boolean indicating whether given proposition is logically equivalent to a truth value.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @atomize is_truth(p ∧ ¬p)\ntrue\n\njulia> @atomize is_truth(p)\nfalse\n\njulia> @atomize is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturn a Boolean indicating whether p is a contingency (not logically equivalent to a truth value).\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @atomize is_contingency(p ∧ ¬p)\nfalse\n\njulia> @atomize is_contingency(p)\ntrue\n\njulia> @atomize is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturn a Boolean indicating whether p is satisfiable (not logically equivalent to a contradiction).\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @atomize is_satisfiable(p)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturn a Boolean indicating whether p is falsifiable (not logically equivalent to a tautology).\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @atomize is_falsifiable(p ∨ ¬p)\nfalse\n\njulia> @atomize is_falsifiable(p)\ntrue\n\njulia> @atomize is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_equisatisfiable","page":"Semantics","title":"PAndQ.is_equisatisfiable","text":"is_equisatisfiable(p, q)\n\nReturn a Boolean indicating whether the predicate is_satisfiable is congruent for both propositions.\n\nExamples\n\njulia> is_equisatisfiable(⊤, ⊥)\nfalse\n\njulia> @atomize is_equisatisfiable(p, q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Ordering","page":"Semantics","title":"Ordering","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Propositions and their truth values have a strict partial order. The truth values tautology and contradiction are the top and bottom of this order, respectively. A proposition that satisfies the predicate is_tautology or is_contradiction is also at the top or bottom of the order, respectively. Propositions that satisfy the predicate is_contingency occupy the middle of this order. In other words, ⊥ < ⊤, ⊥ <= p, and p <= ⊤ for some proposition p. The ordering is partial because the predicates == and is_truth may both be false for two given propositions.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"note: Note\nThe implementations for == and < also define the semantics of isequal, >, <=, and >=. This does not define the semantics of isless, which is used for total orders.","category":"page"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"==\n<\nhash","category":"page"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"==(p, q)\np == q\n\nReturn a Boolean indicating whether p and q are logically equivalent.\n\nConstants are equivalent only if their values are equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it.\n\nExamples\n\njulia> @atomize ⊥ == p ∧ ¬p\ntrue\n\njulia> @atomize (p ↔ q) == ¬(p ↮ q)\ntrue\n\njulia> @atomize $1 == $1\ntrue\n\njulia> @atomize p == ¬p\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.:<","page":"Semantics","title":"Base.:<","text":"<(p, q)\np < q\n\nReturn a Boolean indicating whether the arguments are ordered such that r < s < t, where r, s, and t satisfy is_contradiction, is_contingency, and is_tautology, respectively.\n\nExamples\n\njulia> @atomize ⊥ < p < ⊤\ntrue\n\njulia> @atomize p ∧ ¬p < p < p ∨ ¬p\ntrue\n\njulia> @atomize p < p\nfalse\n\njulia> ⊤ < ⊥\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.hash","page":"Semantics","title":"Base.hash","text":"hash(::Union{AbstractSyntaxTree, Operator}, ::UInt)\n\nReturn zero(UInt).\n\nSince p == q implies hash(p) == hash(q), obtaining a better hash value would require finding the solutions in some form. Instead of using an NP-complete hash time, this instead opts for linear lookup time. An Operator may be logically equivalent to a proposition, and so is also in this case.\n\nExamples\n\njulia> @atomize hash(p)\n0x0000000000000000\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Utilities","page":"Semantics","title":"Utilities","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"Bool(::PAndQ.NullaryOperator)","category":"page"},{"location":"manual/semantics/#Core.Bool-Tuple{Union{PAndQ.Interface.Operator{:tautology}, PAndQ.Interface.Operator{:contradiction}}}","page":"Semantics","title":"Core.Bool","text":"Bool(truth_value)\n\nReturn a Boolean corresponding to the given truth value.\n\nExamples\n\njulia> Bool(⊤)\ntrue\n\njulia> Bool(⊥)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/propositions/#propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/#Instantiation","page":"Propositions","title":"Instantiation","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"@atomize\n@variables\nconstants","category":"page"},{"location":"manual/propositions/#PAndQ.@atomize","page":"Propositions","title":"PAndQ.@atomize","text":"@atomize(x)\n\nInstantiate constants and variables inline.\n\nConstants are instantiated with the $ interpolation syntax. Variables are instantiated with previously undefined symbols.\n\nwarning: Warning\nThis macro attempts to ignore symbols that are being assigned a value. For example, @atomize f(; x = p) = x ∧ q should be equivalent to f(; x = @atomize p) = x ∧ @atomize q. However, this feature is in-progress and only works in some cases. The implementation is cautious to skip the parts of the expression that it cannot yet handle.\n\nExamples\n\njulia> @atomize x = p ∧ q\np ∧ q\n\njulia> @atomize x → r\n(p ∧ q) → r\n\njulia> @atomize $1 ∧ $(1 + 1)\n$(1) ∧ $(2)\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.@variables","page":"Propositions","title":"PAndQ.@variables","text":"@variables(ps...)\n\nDefine variables and return a Vector containing them.\n\nExamples\n\njulia> @variables p q\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.constants","page":"Propositions","title":"PAndQ.constants","text":"constants(f = identity, xs)\n\nEquivalent to map(x -> @atomize $(f(x)), xs).\n\nSee also identical.\n\nExamples\n\njulia> constants(1:2)\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n $(1)\n $(2)\n\njulia> constants(string, 1:2)\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n $(\"1\")\n $(\"2\")\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Utilities","page":"Propositions","title":"Utilities","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"value\nmap\natoms\ninstall_atomize_mode","category":"page"},{"location":"manual/propositions/#PAndQ.value","page":"Propositions","title":"PAndQ.value","text":"value(T = Any, p)\n\nIf p is logically equivalent to a constant, return that constant's value wrapped in Some. Otherwise, return nothing.\n\nValues wrapped in Some can be unwrapped using the something function.\n\ntip: Tip\nTo reduce compilation latency, constants do not store the type of the wrapped value. Therefore, the type of this value cannot be inferred and can result in run-time dispatch. If this type is known at compile-time, pass it as the first parameter. See also the performance tip to Annotate values taken from untyped locations.\n\nExamples\n\njulia> @atomize value(p)\n\njulia> @atomize value($1)\nSome(1)\n\njulia> @atomize something(value(Int, $2))\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Base.map","page":"Propositions","title":"Base.map","text":"map(f, p)\n\nApply the function f to each atom in p.\n\nExamples\n\njulia> @atomize map(¬, p ∧ q)\n¬p ∧ ¬q\n\njulia> @atomize map(atom -> $(something(value(atom)) + 1), $1 ∧ $2)\n$(2) ∧ $(3)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.atoms","page":"Propositions","title":"PAndQ.atoms","text":"atoms(p)\n\nReturn an iterator of each atomic proposition contained in p.\n\nExamples\n\njulia> @atomize collect(atoms(p ∧ q))\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.install_atomize_mode","page":"Propositions","title":"PAndQ.install_atomize_mode","text":"install_atomize_mode(;\n    start_key = \"\\M-a\", prompt_text = \"atomize> \", prompt_color = :cyan,\nkwargs...)\n\nInstall the atomize REPL mode, where input implicitly begins with @atomize.\n\nKeyword arguments are passed to ReplMaker.initrepl. The default start keys are pressing both the [Meta] (also known as [Alt]) and [a] keys at the same time. The available prompt_colors are in Base.text_colors.\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Normalization","page":"Propositions","title":"Normalization","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"normalize\ntseytin","category":"page"},{"location":"manual/propositions/#PAndQ.normalize","page":"Propositions","title":"PAndQ.normalize","text":"normalize(::typeof(¬), p)\nnormalize(::Union{typeof(∧), typeof(∨)}, p; canonical = false)\n\nConvert the given proposition to negation, conjunction, or disjunction normal form depending on whether the first argument is not, and, or or, respectively.\n\nConsidering the syntax tree of a normalized proposition, each leaf node is a literal; either an atom or it's negation. Propositions in negation normal form are expanded such that the syntax tree branches only contain the operators and and or. Conjunction and disjunction normal forms are negated normal forms that have been flattened by recursively distributing either the and or or operator over the other. In other words, a collection of literals is a clause and a proposition in conjunctive or disjunctive normal form is a conjunction of disjunctive clauses or a disjunction of conjunctive clauses, respectively.\n\nConjunction and disjunction, but not negation, normal forms are called canonical. Distributing an operator during conversion may increase the size of the syntax tree exponentially. Therefore, it may be intractable to compute a canonical form for sufficiently large propositions. Instead, use the tseytin transformation to find a proposition in conjunctive normal form which is_equisatisfiable to the given proposition.\n\ntip: Tip\nConverting a proposition between conjunction and disjunction normal form is not performant due to the exponential increase in the size of the proposition. It is most performant to apply all operations to propositions and normalizing the resulting proposition once.\n\nExamples\n\njulia> @atomize normalize(∧, ¬(p ∨ q))\n¬q ∧ ¬p\n\njulia> @atomize normalize(∨, p ↔ q)\n(¬q ∧ ¬p) ∨ (p ∧ q)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.tseytin","page":"Propositions","title":"PAndQ.tseytin","text":"tseytin(p)\n\nApply the Tseytin transformation to the given proposition.\n\nUsing the normalize function to convert a proposition to conjunction normal form may result in an exponentially larger proposition, which can be intractable for sufficiently large propositions. The Tseytin transformation results in a linearly larger proposition that is in conjunction normal form and is_equisatisfiable to the original. However, it contains introduced variables and yields a subset of the solutions to the original proposition.\n\nExamples\n\njulia> is_equisatisfiable(⊤, tseytin(⊤))\ntrue\n\njulia> @atomize is_equisatisfiable(p, tseytin(p))\ntrue\n\njulia> is_equisatisfiable(⊥, tseytin(⊥))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"tutorials/custom_operators/#custom_operators","page":"Custom Operators","title":"Custom Operators","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This tutorial will demonstrate how to implement custom operators using the operator Interface. This interface can be used to implement operators with custom behavior such as:","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Number of parameters\nLazy and eager evaluation\nSemantics\nAssociativity\nInitial value\nPretty printing\nSide-effects","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"warning: Warning\nThis tutorial is not yet polished. This interface is incomplete and will be changed in v0.4.","category":"page"},{"location":"tutorials/custom_operators/#Setup","page":"Custom Operators","title":"Setup","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Implementing an operator requires defining methods for that operator. To do so, their function names must be imported or prefixed by the Interface module. This module also exports several other required and useful functions.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"import PAndQ:\n    Associativity, Evaluation, dual, evaluate,\n    initial_value, parenthesize, print_expression, symbol\nusing PAndQ, .Interface","category":"page"},{"location":"tutorials/custom_operators/#Nullary","page":"Custom Operators","title":"Nullary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is a renamed tautology operator. First, define an Operator. If possible, this should be a constant whose name corresponds to the operator name.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"julia> const truth = Operator{:truth}()\nError showing value of type Operator{:truth}:\nERROR: InterfaceError: implement `symbol` for `Operator{:truth}()`","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"If a required method is not implemented, a runtime error will display the function and operator that a method must be implemented for. The error says to implement symbol. This function is used to print an operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const truth = Operator{:truth}()","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"symbol(::typeof(truth)) = \"truth\";\ntruth\ntruth()","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement Evaluation. This function is used to specify whether an operator lazily or eagerly evaluates its arguments.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Evaluation(::typeof(truth)) = Lazy","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"julia> Evaluation(::typeof(truth)) = Lazy;\n\njulia> truth()\nError showing value of type PAndQ.Tree{0}:\nERROR: InterfaceError: implement `print_expression` for `Operator{:truth}()` with `0` propositions","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement print_expression. This function is used to print a node of a syntax tree.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"print_expression(io, o::typeof(truth), ps) = show(io, \"text/plain\", o);\ntruth()\nprint_table(truth())","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"The error says to implement evaluate. This function is used to specify the semantics of an operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"evaluate(::typeof(truth), ps) = ⊤;\nprint_table(truth())","category":"page"},{"location":"tutorials/custom_operators/#Unary","page":"Custom Operators","title":"Unary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is an eagerly evaluated not operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const negate = Operator{:negate}();\nsymbol(::typeof(negate)) = \"negate\";\nnegate\nEvaluation(::typeof(negate)) = Eager;\nevaluate(::typeof(negate), ps) = evaluate(¬, ps);\n@atomize negate(¬p)\n@atomize print_table(negate(p))","category":"page"},{"location":"tutorials/custom_operators/#Binary","page":"Custom Operators","title":"Binary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is an imply operator represented by the --> symbol.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const if_then = --> = Operator{:if_then}();\nsymbol(::typeof(-->)) = \"-->\";\n-->\nEvaluation(::typeof(-->)) = Lazy;","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"If a node in a syntax tree is not the root node, it may be necessary to parenthesize it to avoid ambiguity. The parenthesize function is used to print parentheses around a node if it is not the root node. The print_proposition function is used to print the propositions in a node.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"print_expression(io, o::typeof(-->), ps) = parenthesize(io) do\n    print_proposition(io, first(ps))\n    print(io, \" \")\n    show(io, \"text/plain\", o)\n    print(io, \" \")\n    print_proposition(io, last(ps))\nend;\n@atomize p --> q\nevaluate(::typeof(-->), ps) = first(ps) → last(ps);\n@atomize print_table(p --> q)\n@atomize fold(𝒾, (-->) => ())","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This error says to implement Associativity. This function is used to determine which direction to fold.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"Associativity(::typeof(-->)) = Left;\n@atomize fold(𝒾, (-->) => ())","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This error says to implement initial_value. This function is used to determine the init parameter when folding.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"initial_value(::typeof(-->)) = ⊤;\n@atomize fold(𝒾, (-->) => ())\n@atomize fold(𝒾, (-->) => (p, q, r))","category":"page"},{"location":"tutorials/custom_operators/#Ternary","page":"Custom Operators","title":"Ternary","text":"","category":"section"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"This is a lazily evaluated conditional operator.","category":"page"},{"location":"tutorials/custom_operators/","page":"Custom Operators","title":"Custom Operators","text":"const conditional = Operator{:conditional}();\nsymbol(::typeof(conditional)) = \"?\";\nconditional\nEvaluation(::typeof(conditional)) = Lazy;\nprint_expression(io, o::typeof(conditional), ps) = parenthesize(io) do\n    print_proposition(io, ps[1])\n    print(io, \" ? \")\n    print_proposition(io, ps[2])\n    print(io, \" : \")\n    print_proposition(io, ps[3])\nend;\n@atomize conditional(p, q, r)\nfunction evaluate(::typeof(conditional), ps)\n    p, q, r = ps\n    (p → q) ∧ (p ∨ r)\nend;\n@atomize print_table(conditional(p, q, r))","category":"page"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nformatter\nprint_table\nprint_tree\nprint_dimacs\nshow","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(ps)\n\nConstruct a truth table for the given propositions.\n\nThe header is a sequence of propositions. The body is a matrix where the rows are interpretations of each proposition in the header.\n\nPropositions logically equivalent to a truth value will be grouped on the left, followed by those equivalent to an atomic proposition, and then by all other propositions. Logically equivalent propositions will be grouped together. Propositions that have the same text representation will only be shown once.\n\nExamples\n\njulia> TruthTable([⊤])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\njulia> @atomize TruthTable([p ∧ ¬p, p → q, ¬p ∨ q])\n┌────────┬───┬───┬───────────────┐\n│ p ∧ ¬p │ p │ q │ p → q, ¬p ∨ q │\n├────────┼───┼───┼───────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊤             │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤             │\n├────────┼───┼───┼───────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥             │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤             │\n└────────┴───┴───┴───────────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#PAndQ.formatter","page":"Printing","title":"PAndQ.formatter","text":"formatter(T)\n\nUse as the formatters keyword parameter in print_table.\n\nT formatter(T)(true, _, _) formatter(T)(false, _, _)\nNullaryOperator \"⊤\" \"⊥\"\nString \"tautology\" \"contradiction\"\nChar \"T\" \"F\"\nBool \"true\" \"false\"\nInt \"1\" \"0\"\n\nSee also Nullary Operators.\n\nExamples\n\njulia> @atomize print_table(p ∧ q; formatters = formatter(Bool))\n┌───────┬───────┬───────┐\n│ p     │ q     │ p ∧ q │\n├───────┼───────┼───────┤\n│ true  │ true  │ true  │\n│ false │ true  │ false │\n├───────┼───────┼───────┤\n│ true  │ false │ false │\n│ false │ false │ false │\n└───────┴───────┴───────┘\n\njulia> @atomize print_table(p ∧ q; formatters = formatter(Int))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ 1 │ 1 │ 1     │\n│ 0 │ 1 │ 0     │\n├───┼───┼───────┤\n│ 1 │ 0 │ 0     │\n│ 0 │ 0 │ 0     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_table","page":"Printing","title":"PAndQ.print_table","text":"print_table(::IO = stdout, xs...; kwargs...)\n\nPrint a TruthTable.\n\nThe parameters can be a TruthTable, iterable of propositions, or sequence of propositions.\n\nKeyword parameters are passed to PrettyTables.pretty_table.\n\nExamples\n\njulia> print_table(TruthTable([⊤]))\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize print_table([p])\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\njulia> @atomize print_table(p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_tree","page":"Printing","title":"PAndQ.print_tree","text":"print_tree(::IO = stdout, p; kwargs...)\n\nPrint a tree diagram of the given proposition.\n\nKeyword parameters are passed to AbstractTrees.print_tree.\n\njulia> @atomize print_tree(p ∧ q ∨ ¬s)\n∨\n├─ ∧\n│  ├─ p\n│  └─ q\n└─ ¬\n   └─ s\n\njulia> @atomize print_tree(normalize(∧, p ∧ q ∨ ¬s))\n∧\n├─ ∨\n│  ├─ q\n│  └─ ¬\n│     └─ s\n└─ ∨\n   ├─ ¬\n   │  └─ s\n   └─ p\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_dimacs","page":"Printing","title":"PAndQ.print_dimacs","text":"print_dimacs(::IO = stdout, p)\n\nPrint the DIMACS format of p.\n\nExamples\n\njulia> @atomize print_dimacs(p ∧ q)\np cnf 2 2\n1 0\n2 0\n\njulia> @atomize print_dimacs(p ↔ q)\np cnf 2 2\n1 -2 0\n-1 2 0\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#Base.show","page":"Printing","title":"Base.show","text":"show(::IO, ::MIME\"text/plain\", ::Operator)\n\nPrint the operator's symbol.\n\nExamples\n\njulia> show(stdout, \"text/plain\", ⊤)\n⊤\n\njulia> show(stdout, \"text/plain\", ¬)\n¬\n\njulia> show(stdout, \"text/plain\", ∧)\n∧\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", p)\n\nPrint the proposition in logical syntax format.\n\nThe value of a constant is shown with an IOContext whose :compact and :limit keys are individually set to true if they have not already been set.\n\nExamples\n\njulia> @atomize show(stdout, \"text/plain\", p ∧ q)\np ∧ q\n\njulia> @atomize show(stdout, \"text/plain\", (p ∨ q) ∧ (r ∨ s))\n(p ∨ q) ∧ (r ∨ s)\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::TruthTable)\n\nPrint the TruthTable's default format.\n\nExamples\n\njulia> @atomize show(stdout, \"text/plain\", TruthTable([p ∧ q]))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\nshow(::IO, ::Operator)\n\n\n\n\n\nshow(::IO, p)\n\nPrint the proposition verbosely.\n\nExamples\n\njulia> @atomize show(stdout, p ∧ q)\nand(PAndQ.AbstractSyntaxTree(:p), PAndQ.AbstractSyntaxTree(:q))\n\njulia> and(PAndQ.AbstractSyntaxTree(:p), PAndQ.AbstractSyntaxTree(:q))\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page demonstrates the basic functionality of this package. For additional features and documentation, see the Tutorials and Manual.","category":"page"},{"location":"getting_started/#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Operators are functions represented by a symbol that return a logical value.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The tautology and contradiction operators are truth values similar to the Boolean values true and false, respectively. These operators are represented with the symbols ⊤ and ⊥ and return themselves when called.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ⊤()\n⊤\n\njulia> ⊥()\n⊥","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The symbols ! and ¬ both represent the unary operator not. The symbols & and ∧ represent the binary operator and.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> !true\nfalse\n\njulia> true & false\nfalse\n\njulia> ¬⊤\n¬⊤\n\njulia> ⊤ ∧ ⊥\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/#Propositions","page":"Getting Started","title":"Propositions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Propositions are statements that can be either true or false. For example, \"Logic is fun\". This proposition has a known value, so it is a constant. Note that the proposition exists independently of whether it is known to be true or false. Constants can be instantiated inline with the @atomize macro and unwrapped with the value function.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p = @atomize $\"Logic is fun\"\n$(\"Logic is fun\")\n\njulia> q = @atomize $\"Julia is awesome\"\n$(\"Julia is awesome\")\n\njulia> map(something ∘ value, [p, q])\n2-element Vector{String}:\n \"Logic is fun\"\n \"Julia is awesome\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A proposition can be negated, such as \"Logic is not fun\". Multiple propositions can be connected, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ¬p\n¬$(\"Logic is fun\")\n\njulia> p ∧ q\n$(\"Logic is fun\") ∧ $(\"Julia is awesome\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Variables represent a proposition with an unknown value. Use the @atomize macro to instantiate them inline or the @variables macro to define multiple variables at once.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> @variables p q\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n q\n\njulia> ¬p\n¬p\n\njulia> p ∧ q\np ∧ q","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Operators always eagerly evaluate boolean values. Boolean values cannot interoperate with truth values and propositions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> true ∧ true\ntrue\n\njulia> ⊤ ∧ p\n⊤ ∧ p","category":"page"},{"location":"getting_started/#Semantics","page":"Getting Started","title":"Semantics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Constants and variables are atomic propositions. Operators construct compound propositions from one or more atomic propositions. Each atom in a proposition can be assigned the valuation true or false. This results in an interpretation, which determines the truth value of the overall proposition. For example, assigning the valuation true to the atomic proposition \"Logic is fun\" determines that the compound proposition \"Logic is not fun\" is interpreted as false. Use the interpret function to assign truth values to atomic propositions.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> interpret([p => ⊤], p ∧ q)\n⊤ ∧ q\n\njulia> interpret([p => ⊤, q => ⊥], p ∧ q)\n⊤ ∧ ⊥","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The solutions of a proposition are the valuations that result in a true interpretation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.AbstractSyntaxTree, Bool}}}:\n [AbstractSyntaxTree(:p)=>1, AbstractSyntaxTree(:q)=>1]  …  [AbstractSyntaxTree(:p)=>1, AbstractSyntaxTree(:q)=>0]\n [AbstractSyntaxTree(:p)=>0, AbstractSyntaxTree(:q)=>1]     [AbstractSyntaxTree(:p)=>0, AbstractSyntaxTree(:q)=>0]\n\njulia> solutions(p ∧ q)[1]\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n q\n p\n\njulia> collect(only(solutions(p ∧ q)[2]))\n2-element Vector{Bool}:\n 1\n 1","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. Use == to check if two propositions are logically equivalent.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> p ∧ ¬p == ⊥\ntrue\n\njulia> p ∧ ¬p === ⊥\nfalse","category":"page"},{"location":"getting_started/#Printing","page":"Getting Started","title":"Printing","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"TruthTables are used to enumerate the interpretations of propositions. The header contains propositions and the atoms composing them. Each column corresponds to the truth values of the proposition in the header. Each row represents an interpretation. Use the print_table function to print a truth table.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> print_table(⊤, ¬p, p ∧ q)\n┌───┬───┬───┬────┬───────┐\n│ ⊤ │ p │ q │ ¬p │ p ∧ q │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊤ │ ⊥  │ ⊤     │\n│ ⊤ │ ⊥ │ ⊤ │ ⊤  │ ⊥     │\n├───┼───┼───┼────┼───────┤\n│ ⊤ │ ⊤ │ ⊥ │ ⊥  │ ⊥     │\n│ ⊤ │ ⊥ │ ⊥ │ ⊤  │ ⊥     │\n└───┴───┴───┴────┴───────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is a computer algebra system for propositional logic.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊤\n¬⊤\n\njulia> @atomize p ∧ q → $1 ∨ $(1 + 1)\n(p ∧ q) → ($(1) ∨ $(2))\n\njulia> @variables p q\n2-element Vector{PAndQ.AbstractSyntaxTree}:\n p\n q\n\njulia> r = p ↔ q\np ↔ q\n\njulia> interpret([p => ⊤], r)\n⊤ ↔ q\n\njulia> collect(only(solutions(p ∧ q)[2]))\n2-element Vector{Bool}:\n 1\n 1\n\njulia> s = normalize(∧, r)\n(¬p ∨ q) ∧ (¬q ∨ p)\n\njulia> print_table(p ∧ ¬p, ¬p, r, s)\n┌────────┬───┬───┬────┬────────────────────────────┐\n│ p ∧ ¬p │ p │ q │ ¬p │ p ↔ q, (¬p ∨ q) ∧ (¬q ∨ p) │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥  │ ⊤                          │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤  │ ⊥                          │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥  │ ⊥                          │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤  │ ⊤                          │\n└────────┴───┴───┴────┴────────────────────────────┘","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Operators\nInterface for custom operators\nPropositions\nSyntax and pretty-printing corresponding to written logic\nSimple instantiation\nCustom REPL mode\nNormalization\nNegation, conjunction, and disjunction forms\nTseytin transformation\nFunctor map\nSemantics\nSatisfiability solving\nLogical equivalence\nStrict partial ordering\nPartial interpretation\nPrinting\nDiagrams\nSyntax trees\nTruth tables\nPlain text, Markdown, HTML, and LaTeX formats\nDIMACS and LaTeX formats","category":"page"},{"location":"#Planned","page":"Home","title":"Planned","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Propositions\nSimplification\nSubstitution\nRandom generation\nNormal forms\nAlgebraic, Blake\nMinimization\nQuine-McCluskey algorithm\nSemantics\nProofs\nPrinting\nDiagrams\nDecision trees\nCircuits\nTypst format\nParse DIMACS\nLanguages\nModal logic\nFirst order logic\nLambda calculus\nElectronic circuits\nSatisfiability modulo theories","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#Logic","page":"Home","title":"Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nImplements a Prolog-like logic programming language for propositional and first-order logic\nSoleLogics.jl\nImplements several logics and algebras\nSatifsiability.jl\nAn interface to satisfiability modulo theory solvers\nSolvers must be installed on the user's system\nLogicCircuits.jl\nImplements propositional logic with support for SIMD and CUDA\nTruthTables.jl\nImplements a macro that prints a truth table\nPAndQ.jl implements a superset of the features in this package\nMathematicalPredicates.jl\nImplements propositional logic\nPAndQ.jl, Julog.jl, and SoleLogics.jl implement a superset of the features in this package","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PicoSat.jl\nAn interface to the PicoSAT solver using PicoSAT_jll.jl\nDoes not support the Windows operating system\nZ3.jl\nAn interface to the Z3 Theorem Prover using z3_jll.jl\nNo documentation","category":"page"},{"location":"#Binaries","page":"Home","title":"Binaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These packages are generated by BinaryBuilder.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"libpicosat_jll.jl\nPicoSAT_jll.jl\nz3_jll.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Metatheory.jl\nSymbolicUtils.jl\nSymbolics.jl\nOscar.jl\nCatlab.jl","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl\nConstraintSolver.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed.jl\nCPLEXCP.jl\nBeeEncoder.jl\n3+ years since last update","category":"page"},{"location":"manual/interface/#interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"This interface is used to implement the built-in operators and can be used to implement custom operators.","category":"page"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"warning: Warning\nThis interface is incomplete and will be changed in v0.4.","category":"page"},{"location":"manual/interface/#Methods","page":"Interface","title":"Methods","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"These methods are required to be implemented for some functionalities. If a required method is not implemented, a runtime error will display the function and operator that a method must be implemented for. Default implementations of are not provided so as to avoid correctness bugs.","category":"page"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Operator","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Operator","page":"Interface","title":"PAndQ.Interface.Operator","text":"Operator{O}\nOperator{O}()\n\nReturn an operator named O.\n\nOperators are uniquely identified by their name. If possible, an operator should be defined as const o = ℴ = Operator{:o}() where symbol(ℴ) == \"ℴ\".\n\nThis method is required to instantiate an operator.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Evaluation","page":"Interface","title":"Evaluation","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Evaluation\nInterface.evaluate","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Evaluation","page":"Interface","title":"PAndQ.Interface.Evaluation","text":"Evaluation(::Operator)\n\nA trait to specify the behavior of calling an Operator.\n\nThis method is required to call the given operator.\n\nSupertype of Eager and Lazy.\n\nExamples\n\njulia> @atomize Interface.Evaluation(𝒾)\nPAndQ.Interface.Eager\n\njulia> @atomize Interface.Evaluation(¬)\nPAndQ.Interface.Lazy\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.evaluate","page":"Interface","title":"PAndQ.Interface.evaluate","text":"evaluate(::Operator, ps)\n\nDefine the semantics of the Operator.\n\nThis method is required to normalize a proposition containing the given operator.\n\nExamples\n\njulia> @atomize Interface.evaluate(¬, [¬p])\np\n\njulia> @atomize Interface.evaluate(→, [p, q])\n¬p ∨ q\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Folding","page":"Interface","title":"Folding","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Associativity\nInterface.initial_value","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Associativity","page":"Interface","title":"PAndQ.Interface.Associativity","text":"Associativity(::Operator)\n\nA trait to specify the associativity of an Operator.\n\nThis method is required for calling fold over the operator.\n\nnote: Note\nThis trait is used internally and does not override how expressions are parsed.\n\nSupertype of Left and Right.\n\nExamples\n\njulia> Interface.Associativity(→)\nPAndQ.Interface.Left\n\njulia> Interface.Associativity(←)\nPAndQ.Interface.Right\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.initial_value","page":"Interface","title":"PAndQ.Interface.initial_value","text":"initial_value(ℴ::Operator)\n\nSpecify a neutral value, v, of a binary Operator such that ℴ(v, p) == p.\n\nIf there is no such neutral value, return nothing.\n\nThis method is required for calling fold over the operator.\n\nSee also ==.\n\nExamples\n\njulia> Interface.initial_value(∧)\n⊤\n\njulia> Interface.initial_value(∨)\n⊥\n\njulia> Interface.initial_value(↑)\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Printing","page":"Interface","title":"Printing","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.print_expression\nInterface.symbol","category":"page"},{"location":"manual/interface/#PAndQ.Interface.print_expression","page":"Interface","title":"PAndQ.Interface.print_expression","text":"print_expression(io, ::Operator, ps)\n\nPrint the node of a syntax tree containing the Operator and its propositions.\n\nIf a node in a syntax tree is not the root node, it may be necessary to parenthesize it to avoid ambiguity. This context can be obtained using is_root.\n\nEach proposition should be represented using print_proposition.\n\nThis method is required for calling show(::IO, ::MIME\"text/plain, p) for a proposition p containing the given operator.\n\nExamples\n\njulia> @atomize Interface.print_expression(stdout, ⊤, [])\n⊤\n\njulia> @atomize Interface.print_expression(stdout, ¬, [p])\n¬p\n\njulia> @atomize Interface.print_expression(stdout, ∧, [p, q])\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.symbol","page":"Interface","title":"PAndQ.Interface.symbol","text":"symbol(ℴ::Operator)\n\nReturn the Unicode symbol of the Operator.\n\nIf possible, this should be implemented as symbol(::typeof(ℴ)) = \"ℴ\".\n\nThis method is required for calling show(::IO, ::MIME\"text/plain\", ::typeof(ℴ)).\n\nSee also show.\n\nExamples\n\njulia> Interface.symbol(⊤)\n\"⊤\"\n\njulia> Interface.symbol(¬)\n\"¬\"\n\njulia> Interface.symbol(∧)\n\"∧\"\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Utilities","page":"Interface","title":"Utilities","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"These functions may be necessary or useful for implementing the operator interface.","category":"page"},{"location":"manual/interface/#Evaluation-2","page":"Interface","title":"Evaluation","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Eager\nInterface.Lazy","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Eager","page":"Interface","title":"PAndQ.Interface.Eager","text":"Eager <: Evaluation\n\nA trait to specify that an Operator is eagerly evaluated.\n\nEagerly evaluated operators return the expression specified by evaluate.\n\nSubtype of Evaluation.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.Lazy","page":"Interface","title":"PAndQ.Interface.Lazy","text":"Lazy <: Evaluation\n\nA trait to specify that an Operator is lazily evaluated.\n\nLazily evaluated operators return a syntax tree with the operator and its propositions as the root node.\n\nSubtype of Evaluation.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Associativity","page":"Interface","title":"Associativity","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.Left\nInterface.Right","category":"page"},{"location":"manual/interface/#PAndQ.Interface.Left","page":"Interface","title":"PAndQ.Interface.Left","text":"Left <: Associativity\n\nA trait to specify that an Operator is left-associative.\n\nSubtype of Associativity.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#PAndQ.Interface.Right","page":"Interface","title":"PAndQ.Interface.Right","text":"Right <: Associativity\n\nA trait to specify that an Operator is right-associative.\n\nSubtype of Associativity.\n\n\n\n\n\n","category":"type"},{"location":"manual/interface/#Printing-2","page":"Interface","title":"Printing","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.name\nInterface.is_root\nInterface.parenthesize\nInterface.print_proposition","category":"page"},{"location":"manual/interface/#PAndQ.Interface.name","page":"Interface","title":"PAndQ.Interface.name","text":"name(::Operator{O})\n\nReturn O, the name of the Operator.\n\nExamples\n\njulia> Interface.name(⊤)\n:tautology\n\njulia> Interface.name(¬)\n:not\n\njulia> Interface.name(∧)\n:and\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.is_root","page":"Interface","title":"PAndQ.Interface.is_root","text":"is_root(io)\n\nReturn a Boolean indicating whether the node being printed is the root of a syntax tree.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.parenthesize","page":"Interface","title":"PAndQ.Interface.parenthesize","text":"parenthesize(f, io)\n\nCall f. If not is_root, print opening and closing parentheses before and after, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.print_proposition","page":"Interface","title":"PAndQ.Interface.print_proposition","text":"print_proposition(io, p)\n\nPrint the given proposition with the IOContext that :root => false.\n\nShould be called from print_expression.\n\nExamples\n\njulia> @atomize print_proposition(stdout, ¬p)\n¬p\n\njulia> @atomize print_proposition(stdout, p ∧ q)\n(p ∧ q)\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Properties","page":"Interface","title":"Properties","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.arity\nInterface.converse\nInterface.dual","category":"page"},{"location":"manual/interface/#PAndQ.Interface.arity","page":"Interface","title":"PAndQ.Interface.arity","text":"arity(::Operator)\n\nReturn the number of propositions accepted by the Operator.\n\nExamples\n\njulia> Interface.arity(⊤)\n0\n\njulia> Interface.arity(¬)\n1\n\njulia> Interface.arity(∧)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.converse","page":"Interface","title":"PAndQ.Interface.converse","text":"converse(ℴ::Operator)\n\nReturn a function such that converse(ℴ)(p, q) == ℴ(q, p).\n\nIf possible, this method should be implemented to return another Operator.\n\nSee also ==.\n\nExamples\n\njulia> Interface.converse(∧)\n∧\n\njulia> Interface.converse(→)\n←\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.dual","page":"Interface","title":"PAndQ.Interface.dual","text":"dual(ℴ::Operator)\n\nReturn a function such that dual(ℴ)(ps...) == ¬(ℴ(map(¬, ps)...)).\n\nIf possible, this method should be implemented to return another Operator.\n\nSee also not and ==.\n\nExamples\n\njulia> Interface.dual(and)\n∨\n\njulia> Interface.dual(imply)\n↚\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#Predicates","page":"Interface","title":"Predicates","text":"","category":"section"},{"location":"manual/interface/","page":"Interface","title":"Interface","text":"Interface.is_associative\nInterface.is_commutative","category":"page"},{"location":"manual/interface/#PAndQ.Interface.is_associative","page":"Interface","title":"PAndQ.Interface.is_associative","text":"is_associative(ℴ::Operator)\n\nReturn a Boolean indicating whether the operator has the associative property such that ℴ(ℴ(p, q), r) == ℴ(p, ℴ(q, r)).\n\nSee also ==.\n\nExamples\n\njulia> Interface.is_associative(∧)\ntrue\n\njulia> Interface.is_associative(→)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/interface/#PAndQ.Interface.is_commutative","page":"Interface","title":"PAndQ.Interface.is_commutative","text":"is_commutative(ℴ::Operator)\n\nReturn a Boolean indicating whether operator has the commutative property such that ℴ(p, q) == ℴ(q, p).\n\nSee also ==.\n\nExamples\n\njulia> Interface.is_commutative(∧)\ntrue\n\njulia> Interface.is_commutative(→)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operators accept Bools, truth values, and propositions. However, boolean values cannot interoperate with truth values and propositions. Operations on boolean values is always eagerly evaluated, whereas operations on truth values and propositions is evaluated according to the operator's Evaluation trait.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\nOperations on propositions that have each been normalized eagerly evaluate to another normalized proposition. This behavior is likely to be removed in v0.4.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊤ is typed with \\top[TAB]. See also Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\nThis associativity is determined by Julia's parser and is distinct from the Associativity trait used to specify the direction an operator folds.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For those cases, you may need to use parentheses. For example, p → q == r parses as p → (q == r) rather than (p → q) == r.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion Associativity Precedence\ntautology ⊤ \\top none 0\ncontradiction ⊥ \\bot none 0\nidentical 𝒾 \\scri none 0\nnot ¬ \\neg right 0\nand ∧ \\wedge left 12\nor ∨ \\vee left 11\nimply → \\rightarrow right 4\nexclusive_or ↮ \\nleftrightarrow right 4\nconverse_imply ← \\leftarrow right 4\nnot_and ↑ \\uparrow right 15\nnot_or ↓ \\downarrow right 15\nnot_imply ↛ \\nrightarrow right 4\nnot_exclusive_or ↔ \\leftrightarrow right 4\nnot_converse_imply ↚ \\nleftarrow right 4\nconjunction ⋀ \\bigwedge none 0\ndisjunction ⋁ \\bigvee none 0","category":"page"},{"location":"manual/operators/#nullary_operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"tautology()\n⊤()\n\nLogical true operator.\n\n⊤ can be typed by \\top[TAB].\n\nExamples\n\njulia> print_table(⊤)\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"contradiction()\n⊥()\n\nLogical false operator.\n\n⊥ can be typed by \\bot[TAB].\n\nExamples\n\njulia> print_table(⊥)\n┌───┐\n│ ⊥ │\n├───┤\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#unary_operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identical\nnot","category":"page"},{"location":"manual/operators/#PAndQ.identical","page":"Operators","title":"PAndQ.identical","text":"identical(p)\n𝒾(p)\n\nLogical identity operator.\n\nExamples\n\njulia> @atomize print_table(𝒾(p))\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"not(p)\n¬p\n\nLogical negation operator.\n\n¬ can be typed by \\neg[TAB].\n\nExamples\n\njulia> @atomize print_table(¬p)\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#binary_operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nor\nimply\nexclusive_or\nconverse_imply\nnot_and\nnot_or\nnot_imply\nnot_exclusive_or\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"and(p, q)\np ∧ q\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge[TAB].\n\nExamples\n\njulia> @atomize print_table(p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"or(p, q)\np ∨ q\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee[TAB].\n\nExamples\n\njulia> @atomize print_table(p ∨ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∨ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"imply(p, q)\np → q\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p → q)\n┌───┬───┬───────┐\n│ p │ q │ p → q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.exclusive_or","page":"Operators","title":"PAndQ.exclusive_or","text":"exclusive_or(p, q)\np ↮ q\n\nLogical exclusive disjunction operator.\n\n↮ can be typed by \\nleftrightarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↮ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↮ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"converse_imply(p, q)\np ← q\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ← q)\n┌───┬───┬───────┐\n│ p │ q │ p ← q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_and","page":"Operators","title":"PAndQ.not_and","text":"not_and(p, q)\np ↑ q\n\nLogical non-conjunction operator.\n\n↑ can be typed by \\uparrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↑ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↑ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_or","page":"Operators","title":"PAndQ.not_or","text":"not_or(p, q)\np ↓ q\n\nLogical non-disjunction operator.\n\n↓ can be typed by \\downarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↓ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↓ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"not_imply(p, q)\np ↛ q\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↛ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↛ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_exclusive_or","page":"Operators","title":"PAndQ.not_exclusive_or","text":"not_exclusive_or(p, q)\np ↔ q\n\nLogical exclusive non-disjunction operator.\n\n↔ can be typed by \\leftrightarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↔ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↔ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"not_converse_imply(p, q)\np ↚ q\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow[TAB].\n\nExamples\n\njulia> @atomize print_table(p ↚ q)\n┌───┬───┬───────┐\n│ p │ q │ p ↚ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#nary_operators","page":"Operators","title":"Nary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"conjunction\ndisjunction","category":"page"},{"location":"manual/operators/#PAndQ.conjunction","page":"Operators","title":"PAndQ.conjunction","text":"conjunction(ps...)\n⋀(ps...)\n\nEquivalent to fold(𝒾, (∧) => ps).\n\n⋀ can be typed by \\bigwedge[TAB].\n\nSee also identical, and, and fold.\n\nExamples\n\njulia> ⋀()\n⊤\n\njulia> @atomize ⋀(p, q, r, s)\np ∧ q ∧ r ∧ s\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#PAndQ.disjunction","page":"Operators","title":"PAndQ.disjunction","text":"disjunction(ps...)\n⋁(ps...)\n\nEquivalent to fold(𝒾, (∨) => ps).\n\n⋁ can be typed by \\bigvee[TAB].\n\nSee also identical, or, and fold.\n\nExamples\n\njulia> ⋁()\n⊥\n\njulia> @atomize ⋁(p, q, r, s)\np ∨ q ∨ r ∨ s\n\n\n\n\n\n","category":"constant"},{"location":"manual/operators/#Utilities","page":"Operators","title":"Utilities","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"fold","category":"page"},{"location":"manual/operators/#PAndQ.fold","page":"Operators","title":"PAndQ.fold","text":"fold(f, pairs...)\n\nA generalization of mapreduce with an arbitrary number of nested folds and traits to determine each operator's Associativity and initial_value.\n\nThe function f must accept as many parameters as there are pairs. Each pair must be a two element iterable where the first element is a binary operator and the second element is an iterable to be folded over.\n\nGiven a single pair, this function is similar to mapreduce and other similar functions. Giving additional pairs will generalize the following pattern:\n\nmapreduce(a, xs) do x\n    mapreduce(b, ys) do y\n        ...\n    end\nend\n\nThis can be rewritten as:\n\nfold(a => xs, b => ys, ...) do x, y, ...\n    ...\nend\n\nExamples\n\njulia> fold(⊤)\n⊤\n\njulia> @atomize fold(¬, (∧) => (p, q))\n¬p ∧ ¬q\n\njulia> @atomize fold(↔, (∧) => (p, q), (∨) => (r, s))\n((p ↔ r) ∨ (p ↔ s)) ∧ ((q ↔ r) ∨ (q ↔ s))\n\n\n\n\n\n","category":"function"}]
}
