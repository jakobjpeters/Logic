var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Everything that is not exported is considered internal.","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.union_typeof","category":"page"},{"location":"manual/internals/#PAndQ.union_typeof","page":"Internals","title":"PAndQ.union_typeof","text":"union_typeof\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"manual/internals/#Union-Types","page":"Internals","title":"Union Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.LogicalOperator\nPAndQ.AndOr","category":"page"},{"location":"manual/internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of logical operators that take zero arguments.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of logical unary operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of logical binary operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.LogicalOperator","page":"Internals","title":"PAndQ.LogicalOperator","text":"LogicalOperator\n\nThe Union of logical operators.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"manual/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"import AbstractTrees: children # hide\nusing AbstractTrees: print_tree # hide\nusing InteractiveUtils: subtypes # hide\nusing PAndQ: Proposition # hide\n\nchildren(x::Type) = subtypes(x) # hide\nprint_tree(Proposition) # hide","category":"page"},{"location":"manual/internals/#Abstract","page":"Internals","title":"Abstract","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Proposition\nPAndQ.Atom\nPAndQ.Compound\nPAndQ.Expressive","category":"page"},{"location":"manual/internals/#PAndQ.Proposition","page":"Internals","title":"PAndQ.Proposition","text":"Proposition\n\nA logical proposition.\n\nSupertype of Atom and Compound.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Atom","page":"Internals","title":"PAndQ.Atom","text":"Atom <: Proposition\n\nA proposition with no deeper propositional structure.\n\nSubtype of Proposition. Supertype of Constant and Variable.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Compound","page":"Internals","title":"PAndQ.Compound","text":"Compound{LO} <: Proposition\n\nA proposition composed from connecting atomic propositions with logical operators.\n\nSubtype of Proposition. Supertype of Literal, Clause, and Expressive.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Expressive","page":"Internals","title":"PAndQ.Expressive","text":"Expressive{LO} <: Compound{LO}\n\nA proposition that is expressively complete.\n\nSubtype of Compound. Supertype of Tree and Normal.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Concrete","page":"Internals","title":"Concrete","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.Constant\nPAndQ.Variable\nPAndQ.Literal\nPAndQ.Tree\nPAndQ.Clause\nPAndQ.Normal","category":"page"},{"location":"manual/internals/#PAndQ.Constant","page":"Internals","title":"PAndQ.Constant","text":"Constant{T} <: Atom\nConstant(value::T)\n\nAn atomic sentence.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Constant(1)\n$(1)\n\njulia> PAndQ.Constant(\"Logic is fun\")\n$(\"Logic is fun\")\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Variable","page":"Internals","title":"PAndQ.Variable","text":"Variable <: Atom\n\nAn atomic formula.\n\nSubtype of Atom.\n\nExamples\n\njulia> PAndQ.Variable(:p)\np\n\njulia> PAndQ.Variable(:q)\nq\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Literal","page":"Internals","title":"PAndQ.Literal","text":"Literal{UO <: UnaryOperator, A <: Atom} <: Compound{UO}\nLiteral(::UO, ::A)\nLiteral(::Union{Atom, Literal})\n\nA proposition represented by an atomic formula or its negation.\n\nSubtype of Compound. See also UnaryOperator and Atom.\n\nExamples\n\njulia> @atomize PAndQ.Literal(𝒾, p)\np\n\njulia> @atomize PAndQ.Literal(¬, p)\n¬p\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Tree","page":"Internals","title":"PAndQ.Tree","text":"Tree{LO <: LogicalOperator, AT <: Union{Atom, Tree}} <: Expressive{LO}\nTree(::NullaryOperator, ::Atom)\nTree(::LogicalOperator, ::Tree...)\nTree(::Proposition)\n\nA proposition represented by an abstract syntax tree.\n\nSubtype of Expressive. See also LogicalOperator.\n\nExamples\n\njulia> PAndQ.Tree(⊤)\n⊤\n\njulia> @atomize PAndQ.Tree(¬, p)\n¬p\n\njulia> @atomize PAndQ.Tree(and, PAndQ.Tree(p), PAndQ.Tree(q))\np ∧ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Clause","page":"Internals","title":"PAndQ.Clause","text":"Clause{AO <: AndOr, L <: Literal} <: Compound{AO}\nClause(::AO, ps = Literal[])\nClause(::AO, p::Proposition)\nClause(::Union{NullaryOperator, Atom, Literal})\n\nA proposition represented as either a conjunction or disjunction of literals.\n\ninfo: Info\nAn empty Clause is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Compound. See also AndOr, Literal, and NullaryOperator.\n\nExamples\n\njulia> PAndQ.Clause(∧)\n⊤\n\njulia> @atomize PAndQ.Clause(p)\np\n\njulia> @atomize PAndQ.Clause(∨, [¬p, q])\n¬p ∨ q\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#PAndQ.Normal","page":"Internals","title":"PAndQ.Normal","text":"Normal{AO <: AndOr, C <: Clause} <: Expressive{AO}\nNormal(::typeof(and), ps = Clause{typeof(or)}[])\nNormal(::typeof(or), ps = Clause{typeof(and)}[])\nNormal(::AO, ::Proposition)\nNormal(::Union{NullaryOperator, Proposition})\n\nA proposition represented in conjunctive or disjunctive normal form.\n\ninfo: Info\nAn empty Normal is logically equivalent to the neutral element of it's binary operator.\n\nSubtype of Expressive. See also AndOr, Clause, NullaryOperator, and Proposition.\n\nExamples\n\njulia> PAndQ.Normal(⊤)\n⊤\n\njulia> @atomize PAndQ.Normal(∧, p ⊻ q)\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#AbstractTrees.jl","page":"Internals","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.children\nPAndQ.nodevalue\nPAndQ.printnode","category":"page"},{"location":"manual/internals/#AbstractTrees.children","page":"Internals","title":"AbstractTrees.children","text":"children(::Proposition)\n\nReturn an iterator over the child nodes of the given Proposition.\n\nExamples\n\njulia> @atomize PAndQ.children(p)\n()\n\njulia> @atomize PAndQ.children(¬p)\n(PAndQ.Variable(:p),)\n\njulia> @atomize PAndQ.children(p ∧ q)\n2-element Vector{PAndQ.Tree{typeof(identity), PAndQ.Variable}}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.nodevalue","page":"Internals","title":"AbstractTrees.nodevalue","text":"nodevalue(::Compound)\n\nSee also Compound.\n\nExamples\n\njulia> @atomize PAndQ.nodevalue(¬p)\nnot (generic function with 19 methods)\n\njulia> @atomize PAndQ.nodevalue(p ∧ q)\nand (generic function with 18 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#AbstractTrees.printnode","page":"Internals","title":"AbstractTrees.printnode","text":"printnode(::IO, ::Proposition; kwargs...)\n\nSee also Proposition.\n\nExamples\n\njulia> @atomize PAndQ.printnode(stdout, p)\np\njulia> @atomize PAndQ.printnode(stdout, ¬p)\n¬\njulia> @atomize PAndQ.printnode(stdout, p ∧ q)\n∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.child\nPAndQ.union_all_type\nPAndQ.symbol_value\nPAndQ.atomize","category":"page"},{"location":"manual/internals/#PAndQ.child","page":"Internals","title":"PAndQ.child","text":"child(x)\n\nEquivalent to only(children(x))\n\nSee also children\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.union_all_type","page":"Internals","title":"PAndQ.union_all_type","text":"union_all_type(::Proposition)\n\nReturn the UnionAll type of a Proposition.\n\nExamples\n\njulia> @atomize PAndQ.union_all_type(p)\nPAndQ.Variable\n\njulia> @atomize PAndQ.union_all_type(p ∧ q)\nPAndQ.Tree\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.symbol_value","page":"Internals","title":"PAndQ.symbol_value","text":"symbol_value\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.atomize","page":"Internals","title":"PAndQ.atomize","text":"atomize(x)\n\nIf x is a symbol, return an expression that instantiates it as a Variable if it is undefined in the caller's scope. If isexpr(x, :$), return an expression that instantiates it as a Constant. If x is another expression, traverse it with recursive calls to atomize Otherise, return x.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.alias_of\nPAndQ.symbol_of\nPAndQ.parenthesize\nPAndQ.print_node\nPAndQ.show_atom","category":"page"},{"location":"manual/internals/#PAndQ.alias_of","page":"Internals","title":"PAndQ.alias_of","text":"alias_of(::LogicalOperator)\n\nReturn the written name of the given LogicalOperator.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.symbol_of","page":"Internals","title":"PAndQ.symbol_of","text":"symbol_of(::LogicalOperator)\n\nReturn the Unicode symbol of the given LogicalOperator.\n\nExamples\n\njulia> PAndQ.symbol_of(⊤)\n:⊤\n\njulia> PAndQ.symbol_of(¬)\n:¬\n\njulia> PAndQ.symbol_of(∧)\n:∧\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.parenthesize","page":"Internals","title":"PAndQ.parenthesize","text":"parenthesize(::IO, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.print_node","page":"Internals","title":"PAndQ.print_node","text":"print_node(io, p)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.show_atom","page":"Internals","title":"PAndQ.show_atom","text":"show_atom(io, ::Atom)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"PAndQ.neutral_operator\nPAndQ.eval_doubles","category":"page"},{"location":"manual/internals/#PAndQ.neutral_operator","page":"Internals","title":"PAndQ.neutral_operator","text":"neutral_operator(::NullaryOperator)\n\nReturn a subtype of AndOr that is the neutral element of the given NullaryOperator.\n\nSee also left_neutrals and right_neutrals.\n\nExamples\n\njulia> PAndQ.neutral_operator(⊤)\nand (generic function with 18 methods)\n\njulia> PAndQ.neutral_operator(⊥)\nor (generic function with 18 methods)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#PAndQ.eval_doubles","page":"Internals","title":"PAndQ.eval_doubles","text":"eval_doubles(f, doubles)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/#Macros","page":"Propositions","title":"Macros","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"@atomize\n@variables","category":"page"},{"location":"manual/propositions/#PAndQ.@atomize","page":"Propositions","title":"PAndQ.@atomize","text":"@atomize(expression)\n\nInstantiate undefined symbols as Variables and interpolated values as Constants inline.\n\nwarning: Warning\nThis macro attempts to ignore symbols that are being assigned a value. For example, @atomize f(; x = p) = x ∧ q should be equivalent to f(; x = @atomize p)) = x ∧ @atomize q. However, this feature is in-progress and only works in some cases. The implementation is cautious to skip the parts of the expression that it cannot yet handle.\n\nExamples\n\njulia> @atomize x = p ∧ q\np ∧ q\n\njulia> @atomize x → r\n(p ∧ q) → r\n\njulia> @atomize $1 ∧ $(1 + 1)\n$(1) ∧ $(2)\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#PAndQ.@variables","page":"Propositions","title":"PAndQ.@variables","text":"@variables(ps...)\n\nDefine variables and return a vector containing them.\n\nEach symbol p is defined as @atomize p = p\n\nSee also @atomize.\n\nExamples\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/propositions/#Utilities","page":"Propositions","title":"Utilities","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"atoms\noperators\nmap","category":"page"},{"location":"manual/propositions/#PAndQ.atoms","page":"Propositions","title":"PAndQ.atoms","text":"atoms(p)\n\nReturn an iterator of each Atom contained in p.\n\nExamples\n\njulia> @atomize collect(atoms(p ∧ q))\n2-element Vector{PAndQ.Variable}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#PAndQ.operators","page":"Propositions","title":"PAndQ.operators","text":"operators(::Proposition)\n\nReturn an iterator of each logical operator contained in the given Proposition.\n\nExamples\n\njulia> @atomize collect(operators(¬p))\n1-element Vector{typeof(not)}:\n not (generic function with 19 methods)\n\njulia> @atomize collect(operators(¬p ∧ q))\n3-element Vector{Function}:\n and (generic function with 18 methods)\n not (generic function with 19 methods)\n identity (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Base.map","page":"Propositions","title":"Base.map","text":"map(f, ::Proposition)\n\nApply f to each Atom in the given Proposition.\n\nExamples\n\njulia> @atomize map(PAndQ.Tree ∘ ¬, p ∧ q)\n¬p ∧ ¬q\n\njulia> @atomize map(p ∧ q) do atom\n           println(atom)\n           atom\n       end\nPAndQ.Variable(:p)\nPAndQ.Variable(:q)\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/#Markdown","page":"Extensions","title":"Markdown","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"pretty_table(::Type{Markdown.MD}, ::TruthTable)","category":"page"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{Markdown.MD}, TruthTable}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Type{Markdown.MD}, ::Union{Proposition, TruthTable};\n    formatters = formatter(NullaryOperator), alignment = :l\n)\n\nExamples\n\njulia> @atomize pretty_table(Markdown.MD, p ∧ q)\n  p q p ∧ q\n  – – –––––\n  ⊤ ⊤ ⊤\n  ⊥ ⊤ ⊥\n  ⊤ ⊥ ⊥\n  ⊥ ⊥ ⊥\n\njulia> @atomize print(pretty_table(String, p ∧ q; backend = Val(:markdown)))\n| p   | q   | p ∧ q |\n|:--- |:--- |:----- |\n| ⊤   | ⊤   | ⊤     |\n| ⊥   | ⊤   | ⊥     |\n| ⊤   | ⊥   | ⊥     |\n| ⊥   | ⊥   | ⊥     |\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#Latexify","page":"Extensions","title":"Latexify","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"tip: Tip\nA @latexrecipe has been defined for LogicalOperator, Proposition, and TruthTable.","category":"page"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"formatter(::Type{Latexify.LaTeXString})\npretty_table(::Type{Latexify.LaTeXString}, ::Union{PAndQ.Proposition, TruthTable})","category":"page"},{"location":"manual/extensions/#PAndQ.formatter-Tuple{Type{LaTeXStrings.LaTeXString}}","page":"Extensions","title":"PAndQ.formatter","text":"formatter(t::Type{Latexify.LaTeXString})\n\nt formatter(t)(⊤, _, _) formatter(t)(⊥, _, _)\nLatexify.LaTeXString \"$\\top$\" \"$\\bot$\"\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#PrettyTables.pretty_table-Tuple{Type{LaTeXStrings.LaTeXString}, Union{PAndQ.Proposition, TruthTable}}","page":"Extensions","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::LaTexify.LaTexString, x::Union{Proposition, TruthTable};\n    backend = Val(:latex), kwargs...\n)\n\nEquivalent to LaTeXString(pretty_table(String, x; backend, kwargs...)).\n\nExamples\n\njulia> pretty_table(Latexify.LaTeXString, @atomize p ∧ q)\nL\"\\begin{tabular}{|l|l|l|}\n  \\hline\n  \\textbf{$p$} & \\textbf{$q$} & \\textbf{$p \\wedge q$} \\\\\\hline\n  $\\top$ & $\\top$ & $\\top$ \\\\\n  $\\bot$ & $\\top$ & $\\bot$ \\\\\\hline\n  $\\top$ & $\\bot$ & $\\bot$ \\\\\n  $\\bot$ & $\\bot$ & $\\bot$ \\\\\\hline\n\\end{tabular}\n\"\n\n\n\n\n\n","category":"method"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"warning: Warning\nThe algorithm to solve propositions currently has a naive implementation with a runtime of O(2 ^ n) where n = length(unique(atoms(p))).","category":"page"},{"location":"manual/semantics/#Truths","page":"Semantics","title":"Truths","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"valuations\ninterpret\ninterpretations\nsolve","category":"page"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuations(atoms)\nvaluations(::Proposition)\n\nReturn an iterator of every possible valuation of Atoms.\n\nSee also Proposition.\n\nExamples\n\njulia> @atomize collect(valuations(p))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n [PAndQ.Variable(:p) => 0]\n\njulia> @atomize collect(valuations(p ∧ q))\n2×2 Matrix{Vector{Pair{PAndQ.Variable, Bool}}}:\n [Variable(:p)=>1, Variable(:q)=>1]  [Variable(:p)=>1, Variable(:q)=>0]\n [Variable(:p)=>0, Variable(:q)=>1]  [Variable(:p)=>0, Variable(:q)=>0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(valuation, ::Proposition)\n\nSubstitute each Atom in the given Proposition with values from the valuation.\n\nThe valuation can be a function or function-like object with the signature valuation(::Atom)::Union{Bool, NullaryOperator}, a Dict, or an iterable that can construct a Dict. No substitution is performed if an Atom from the Proposition is not one of the dictionary's keys.\n\nSee also NullaryOperator.\n\nExamples\n\njulia> @atomize interpret(p -> true, ¬p)\nfalse\n\njulia> @atomize interpret(p => true, p ∧ q)\nq\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(p, valuations = valuations(p))\n\nReturn an iterator of truth values given by interpreting p with each valuation.\n\nExamples\n\njulia> @atomize collect(interpretations(p))\n2-element Vector{Bool}:\n 1\n 0\n\njulia> @atomize collect(interpretations(p ⊻ q, [p => true]))\n1-element Vector{PAndQ.Literal{typeof(not), PAndQ.Variable}}:\n ¬q\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solve","page":"Semantics","title":"PAndQ.solve","text":"solve(p)\n\nReturn a vector containing all valuations such that interpret(p, valuation) == ⊤.\n\nSee also interpret and tautology.\n\nExamples\n\njulia> @atomize collect(solve(p))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n\njulia> @atomize collect(solve(p ⊻ q))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 0, PAndQ.Variable(:q) => 1]\n [PAndQ.Variable(:p) => 1, PAndQ.Variable(:q) => 0]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Predicates","page":"Semantics","title":"Predicates","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"is_commutative\nis_associative\n==\nis_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable","category":"page"},{"location":"manual/semantics/#PAndQ.is_commutative","page":"Semantics","title":"PAndQ.is_commutative","text":"is_commutative(::BinaryOperator)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_associative","page":"Semantics","title":"PAndQ.is_associative","text":"is_associative(::BinaryOperator)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"==(::Union{Bool, NullaryOperator, Proposition}, ::Union{Bool, NullaryOperator, Proposition})\np == q\n\nReturns a boolean indicating whether p and q are logically equivalent.\n\nConstants are equivalent if and only if their values are equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it.\n\nSee also NullaryOperator and Proposition.\n\nExamples\n\njulia> @atomize p == ¬p\nfalse\n\njulia> @atomize ¬(p ⊻ q) == (p → q) ∧ (p ← q)\ntrue\n\njulia> @atomize ¬(p ⊻ q) === (p → q) ∧ (p ← q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturns a boolean on whether p is a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @atomize is_tautology(p)\nfalse\n\njulia> @atomize is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturns a boolean on whether p is a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @atomize is_contradiction(p)\nfalse\n\njulia> @atomize is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturns a boolean on whether p is a truth value (either a tautology or contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @atomize is_truth(p ∧ ¬p)\ntrue\n\njulia> @atomize is_truth(p)\nfalse\n\njulia> @atomize is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturns a boolean on whether p is a contingency (neither a tautology or contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @atomize is_contingency(p ∧ ¬p)\nfalse\n\njulia> @atomize is_contingency(p)\ntrue\n\njulia> @atomize is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturns a boolean on whether p is satisfiable (not a contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @atomize is_satisfiable(p)\ntrue\n\njulia> @atomize is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturns a boolean on whether p is falsifiable (not a tautology).\n\nSee also Proposition.\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @atomize is_falsifiable(p ∨ ¬p)\nfalse\n\njulia> @atomize is_falsifiable(p)\ntrue\n\njulia> @atomize is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Properties","page":"Semantics","title":"Properties","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"dual\nconverse\nleft_neutrals\nright_neutrals","category":"page"},{"location":"manual/semantics/#PAndQ.dual","page":"Semantics","title":"PAndQ.dual","text":"dual(::LogicalOperator)\n\nReturns the LogicalOperator that is the dual of the given boolean operator.\n\nExamples\n\njulia> dual(and)\nor (generic function with 18 methods)\n\njulia> @atomize and(p, q) == not(dual(and)(not(p), not(q)))\ntrue\n\njulia> dual(imply)\nnot_converse_imply (generic function with 3 methods)\n\njulia> @atomize imply(p, q) == not(dual(imply)(not(p), not(q)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.converse","page":"Semantics","title":"PAndQ.converse","text":"converse(::LogicalOperator)\n\nReturns the LogicalOperator that is the converse of the given boolean operator.\n\nExamples\n\njulia> converse(and)\nand (generic function with 18 methods)\n\njulia> @atomize and(p, q) == converse(and)(q, p)\ntrue\n\njulia> converse(imply)\nconverse_imply (generic function with 3 methods)\n\njulia> @atomize imply(p, q) == converse(imply)(q, p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.left_neutrals","page":"Semantics","title":"PAndQ.left_neutrals","text":"left_neutrals(::LogicalOperator)\n\nReturn the corresponding left identity elements of the operator. The identity elements can be tautology, contradiction, neither (empty set), or both.\n\nExamples\n\njulia> left_neutrals(or)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.contradiction\n\njulia> left_neutrals(imply)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.right_neutrals","page":"Semantics","title":"PAndQ.right_neutrals","text":"right_neutrals(::LogicalOperator)\n\nReturn the corresponding right identity elements of the operator. The identity elements can be tautology, contradiction, neither (empty set), or both.\n\nExamples\n\njulia> right_neutrals(or)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.contradiction\n\njulia> right_neutrals(converse_imply)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.tautology\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#Utilities","page":"Semantics","title":"Utilities","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"convert","category":"page"},{"location":"manual/semantics/#Base.convert","page":"Semantics","title":"Base.convert","text":"convert(::Type{<:Proposition}, ::Union{NullaryOperator, Proposition})\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nshow\nformatter\npretty_table(::IO, ::TruthTable)\nprint_tree","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(ps)\n\nConstruct a truth table for the given Propositions.\n\nThe header is a vector containing vectors of logically equivalent propositions. The body is a matrix where the rows contain interpretations of each proposition in the given column.\n\nSee also tautology and contradiction.\n\nExamples\n\njulia> TruthTable([PAndQ.Tree(⊤)])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\njulia> @atomize TruthTable([p ∧ ¬p, p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q)])\n┌────────┬───┬───┬───────────────────────────┐\n│ p ∧ ¬p │ p │ q │ p ⊻ q, ¬(p ∧ q) ∧ (p ∨ q) │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥                         │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤                         │\n├────────┼───┼───┼───────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊤                         │\n│ ⊥      │ ⊥ │ ⊥ │ ⊥                         │\n└────────┴───┴───┴───────────────────────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#Base.show","page":"Printing","title":"Base.show","text":"show(::IO, ::MIME\"text/plain\", ::Proposition)\n\nRepresent the given Proposition as a propositional formula.\n\nThe value of a Constant is shown with compact => true in its IOContext.\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), p ⊻ q)\np ⊻ q\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), PAndQ.Normal(p ⊻ q))\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\n\n\n\n\nshow(::IO, ::MIME\"text/plain\", ::TruthTable)\n\nExamples\n\njulia> @atomize show(stdout, MIME\"text/plain\"(), TruthTable([p ∧ q]))\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\nshow(::IO, ::Proposition)\n\nRepresent the given Proposition expanded as valid Julia code.\n\nExamples\n\njulia> @atomize repr(p ∧ q)\n\"PAndQ.Tree(and, PAndQ.Tree(identity, PAndQ.Variable(:p)), PAndQ.Tree(identity, PAndQ.Variable(:q)))\"\n\njulia> @atomize eval(Meta.parse(repr(p ∧ q)))\np ∧ q\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.formatter","page":"Printing","title":"PAndQ.formatter","text":"formatter(t::Type{<:Union{NullaryOperator, String, Char, Bool, Int}})\n\nSee also NullaryOperator.\n\nt formatter(t)(⊤, _, _) formatter(t)(⊥, _, _)\nPAndQ.NullaryOperator \"⊤\" \"⊥\"\nString \"tautology\" \"contradiction\"\nChar \"T\" \"F\"\nBool \"true\" \"false\"\nInt \"1\" \"0\"\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PrettyTables.pretty_table-Tuple{IO, TruthTable}","page":"Printing","title":"PrettyTables.pretty_table","text":"pretty_table(\n    ::Union{IO, Type{Union{String, Docs.HTML}}} = stdout, ::Union{Proposition, TruthTable};\n    formatters = formatter(NullaryOperator), kwargs...\n)\n\nSee also PrettyTables.pretty_table, Proposition, TruthTable, and formatter.\n\nExamples\n\njulia> pretty_table(@atomize p ∧ q)\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\njulia> print(pretty_table(Docs.HTML, @atomize p ∧ q).content)\n<table>\n  <thead>\n    <tr class = \"header headerLastRow\">\n      <th style = \"text-align: left;\">p</th>\n      <th style = \"text-align: left;\">q</th>\n      <th style = \"text-align: left;\">p ∧ q</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊤</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊤</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n    <tr>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n      <td style = \"text-align: left;\">⊥</td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n\n\n","category":"method"},{"location":"manual/printing/#AbstractTrees.print_tree","page":"Printing","title":"AbstractTrees.print_tree","text":"print_tree(::IO = stdout, ::Proposition; kwargs...)\n\nPrints a tree diagram of the given Proposition.\n\nSee also AbstractTrees.print_tree.\n\njulia> @atomize print_tree(p ∧ ¬q ⊻ s)\n⊻\n├─ ∧\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ ¬\n│     └─ q\n└─ 𝒾\n   └─ s\n\njulia> @atomize print_tree(PAndQ.Normal(p ∧ ¬q ⊻ s))\n∧\n├─ ∨\n│  ├─ 𝒾\n│  │  └─ p\n│  └─ 𝒾\n│     └─ s\n├─ ∨\n│  ├─ ¬\n│  │  └─ q\n│  └─ 𝒾\n│     └─ s\n└─ ∨\n   ├─ ¬\n   │  └─ p\n   ├─ 𝒾\n   │  └─ q\n   └─ ¬\n      └─ s\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is a computer algebra system for propositional logic.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Syntax and pretty-printing identical to symbolic propositional logic\nNormalization\nLogical equivalence checking\nBoolean satisfiability solving\nPartial interpretation\nConvert propositions to LaTeX\nTruth tables\nPlain text, HTML, Markdown, and LaTeX output\nTree diagrams","category":"page"},{"location":"#Planned","page":"Home","title":"Planned","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Canonical normal form\nFast solver backends\nGraph plotting\nSubstitution\nProofs\nGenerate propositions\nModal logic\nFirst order logic\nLambda calculus\nElectronic circuits","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊥()\ntrue\n\njulia> @atomize p ∧ q → $1\n(p ∧ q) → $(1)\n\njulia> @variables p q\n2-element Vector{PAndQ.Variable}:\n p\n q\n\njulia> r = ¬p\n¬p\n\njulia> r(p => true)\nfalse\n\njulia> s = (p ∨ q) ∧ (r ∨ ¬q)\n(p ∨ q) ∧ (¬p ∨ ¬q)\n\njulia> s(p => true, q => false)\ntrue\n\njulia> TruthTable([p ∧ ¬p, r, p ⊻ q, s])\n┌────────┬───┬───┬────┬────────────────────────────┐\n│ p ∧ ¬p │ p │ q │ ¬p │ p ⊻ q, (p ∨ q) ∧ (¬p ∨ ¬q) │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊤ │ ⊥  │ ⊥                          │\n│ ⊥      │ ⊥ │ ⊤ │ ⊤  │ ⊤                          │\n├────────┼───┼───┼────┼────────────────────────────┤\n│ ⊥      │ ⊤ │ ⊥ │ ⊥  │ ⊤                          │\n│ ⊥      │ ⊥ │ ⊥ │ ⊤  │ ⊥                          │\n└────────┴───┴───┴────┴────────────────────────────┘","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#Logic","page":"Home","title":"Logic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nImplements a Prolog-like logic programming language for propositional and first-order logic\nLogicCircuits.jl\nImplements propositional logic with support for SIMD and CUDA\nSoleLogics.jl\nImplements propositional and modal logic\nTruthTables.jl\nImplements a macro that prints a truth table\nPAndQ.jl implements a superset of the features in this package\nMathematicalPredicates.jl\nImplements propositional logic\nPAndQ.jl and Julog.jl implement a superset of the features in this package","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Satifsiability.jl\nAn interface to satisfiability modulo theory solvers\nSolvers must be installed on the user's system\nPicoSat.jl\nAn interface to the PicoSAT solver using PicoSAT_jll.jl\nZ3.jl\nAn interface to the Z3 Theorem Prover using z3_jll.jl","category":"page"},{"location":"#Binaries","page":"Home","title":"Binaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These packages are generated by BinaryBuilder.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PicoSAT_jll.jl\nz3_jll.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Symbolics.jl\nSymbolicUtils.jl\nMetatheory.jl","category":"page"},{"location":"#Constraints","page":"Home","title":"Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuMP.jl\nConstraintSolver.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed.jl\nCPLEXCP.jl\nBeeEncoder.jl\n3+ years since last update","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Truth-Values","page":"Tutorial","title":"Truth Values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A truth value is logic's version of a boolean true or false. These concepts can also be represented as a 1 or a 0. Similarly, we use tautology and contradiction. These are commonly represented with the symbols ⊤ and ⊥. These truth values have additional meaning, which will be discussed further on.","category":"page"},{"location":"tutorial/#tutorial_operators","page":"Tutorial","title":"Operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Just like with boolean values, we can perform operations on truth values. Both ! and the symbol ¬ represent the unary operator not.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> !true == false # boolean negation\ntrue\n\njulia> ¬⊤ == ⊥ # logical negation\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several operators that accept multiple arguments. Both & and the symbol ∧ represent the binary operator and. Both | and the symbol ∨ represent the binary operator or.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> true && false == false # boolean and\ntrue\n\njulia> true || false == true # boolean or\ntrue\n\njulia> ⊤ ∧ ⊥ == ⊥ # logical and\ntrue\n\njulia> ⊤ ∨ ⊥ == ⊤ # logical or\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several more operators, which will be discussed later. Use the arity function to determine the number of arguments for an operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> arity(contradiction)\n0\n\njulia> arity(not)\n1\n\njulia> arity(and)\n2","category":"page"},{"location":"tutorial/#Propositions","page":"Tutorial","title":"Propositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A Proposition is a statement that can be either true or false. For example, \"Logic is fun\" is a proposition because it may be true for you but false for someone else. This proposition has a known value, so it is a Constant. Note that the proposition exists independently of whether it is known to be true or false.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p = PAndQ.Constant(\"Logic is fun\")\n$(\"Logic is fun\")\n\njulia> q = PAndQ.Constant(\"Julia is awesome\")\n$(\"Julia is awesome\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also perform operations on propositions. In a written form, we can negate the above proposition by saying \"Logic is not fun\". We could combine two propositions using another operator, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ¬p\n¬$(\"Logic is fun\")\n\njulia> p ∧ q\n$(\"Logic is fun\") ∧ $(\"Julia is awesome\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In mathematics, it's useful to replace individual numbers with a symbolic Variable that can represent an unknown value. Since these atoms are for demonstration and represent an unknown value, we will do the same with our propositions p and q.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p = PAndQ.Variable(:p)\np\n\njulia> q = PAndQ.Variable(:q)\nq\n\njulia> ¬p\n¬p\n\njulia> p ∧ q\np ∧ q","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Propositions that do not contain any structure are called atomic. Constants and Variables are atomic propositions. Compound propositions are formed by connecting atomic propositions with logical operators. A Literal is a proposition that is either an atom or its negation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p isa PAndQ.Atom\ntrue\n\njulia> ¬p isa PAndQ.Literal && ¬p isa PAndQ.Compound\ntrue\n\njulia> p ∧ q isa PAndQ.Tree && p ∧ q isa PAndQ.Compound\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function atoms returns an iterator of each Atom in a proposition.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(atoms(¬p))\n1-element Vector{PAndQ.Variable}:\n p\n\njulia> collect(atoms(p ∧ q))\n2-element Vector{PAndQ.Variable}:\n p\n q","category":"page"},{"location":"tutorial/#Semantics","page":"Tutorial","title":"Semantics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We know that since these are propositions, they can be true or false. If you think that \"Logic is fun\", it would be invalid to assign it the valuation false. So the proposition p is true if you think that \"Logic is fun\" and is false otherwise. If we assign the value true to the proposition \"Logic is fun\", then we know that the validity of the proposition \"Logic is fun and Julia is awesome\" depends on whether or not \"Julia is awesome\". If \"Julia is awesome\" is assigned false, then the conjunction of the two propositions is false. Use the interpret function to assign meaning to atomic propositions and then simplify the proposition.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> interpret(a -> false, ¬p)\ntrue\n\njulia> (p ∧ q)(p => true, q => false)\nfalse","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Assigning meaning to any number of atomic propositions is called a valuation. Since p can only be true or false, those are it's possible valuations. An interpretation is the truth value of propositions that is determined by a given valuation. Since p is atomic, its valuation and interpretation are the same. ¬p doesn't depend on any other propositions, so it also has two possible valuations. However, the valuation and the interpretation are no longer the same. If p is assigned true, then ¬p is determined to be false, and vice versa.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(valuations(¬p))\n2-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1]\n [PAndQ.Variable(:p) => 0]\n\njulia> collect(interpretations(¬p))\n2-element Vector{Bool}:\n 0\n 1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since p ∧ q contains two atomic propositions, there are four valuations: p is true and q is true, p is false and q is true, p is true and q is false, and p is false and q is false. Each additional atomic proposition in a proposition doubles the number of possible valuations. Mathematically, there are 2 ^ n valuations where n = length(unique!(collect(atoms(p)))). Since each interpretation depends on a valuation, the number of valuations and interpretations are equal.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> n = length(unique!(collect(atoms(p ∧ q))))\n2\n\njulia> length(valuations(p ∧ q)) == length(interpretations(p ∧ q)) == 2 ^ n == 4\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is useful to find valuations that determine valid interpretations. This is accomplished with the solve function. The proposition p ∧ q is determined to be true with the valuation that both p and q are true. Each of the other three possible valuations are invalid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(solve(p ∧ q))\n1-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 1, PAndQ.Variable(:q) => 1]\n\njulia> collect(solve(¬(p ∧ q)))\n3-element Vector{Vector{Pair{PAndQ.Variable, Bool}}}:\n [PAndQ.Variable(:p) => 0, PAndQ.Variable(:q) => 1]\n [PAndQ.Variable(:p) => 1, PAndQ.Variable(:q) => 0]\n [PAndQ.Variable(:p) => 0, PAndQ.Variable(:q) => 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition is_satisfiable if there is at least one valid interpretation. A proposition is_falsifiable if there is at least one invalid interpretation. A proposition is_contingency if it is both satisfiable and falsifiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> is_satisfiable(p ∧ q) && is_falsifiable(p ∧ q) && is_contingency(p ∧ q)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition is a tautology if every possible interpretation is true. Likewise, a proposition is a contradiction if every possible interpretation is false. For example, p ∧ ¬p is always interpreted as false because either p or ¬p must be false. p ∨ ¬p is always interpreted as true because either p or ¬p must be true. Use the functions is_tautology, is_contradiction, and is_truth to check whether a proposition is logically equivalent to a truth value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(interpretations(p ∧ ¬p))\n2-element Vector{Bool}:\n 0\n 0\n\njulia> collect(interpretations(p ∨ ¬p))\n2-element Vector{Bool}:\n 1\n 1\n\njulia> is_contradiction(p ∧ ¬p) && is_tautology(p ∨ ¬p)\ntrue\n\njulia> is_truth(p ∧ ¬p) && is_truth(p ∨ ¬p)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. For example, the propositions ¬(¬p ∧ ¬q) and p ∨ q are logically equivalent. In fact, the or operator is implemented this way. Use == to test that two propositions are logically equivalent.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ¬(¬p ∧ ¬q) == p ∨ q\ntrue\n\njulia> ¬(¬p ∧ ¬q) === p ∨ q\nfalse","category":"page"},{"location":"tutorial/#Printing","page":"Tutorial","title":"Printing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It would also be helpful to enumerate each valuation and interpretation in a visual format. This is accomplished by creating a TruthTable. A truth table is a table where each column in the header identifies a proposition, and each row contains an interpretation (including the valuation of atomic propositions). To demonstrate these, we will use the xor operator, represented by the symbol ⊻. Try to understand the meaning of this operator as it is interpreted with different valuations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TruthTable([p ⊻ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊻ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operators accept values of type Bool, PAndQ.NullaryOperator, and PAndQ.Proposition.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊤ is typed with \\top[TAB]. See also Julia's documentation on Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For those cases, you may need to use parentheses. For example, @atomize p → q == r parses as @atomize p → (q == r) rather than @atomize (p → q) == r.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion Associativity Precedence\ntautology ⊤ \\top none 0\ncontradiction ⊥ \\bot none 0\nidentity 𝒾 \\scri none 0\nnot ¬ \\neg right 0\nand ∧ \\wedge left 12\nnand ⊼ \\nand left 12\nnor ⊽ \\nor left 11\nor ∨ \\vee left 11\nxor ⊻ \\xor left 11\nxnor ↔ \\leftrightarrow right 4\nimply → \\rightarrow right 4\nnot_imply ↛ \\nrightarrow right 4\nconverse_imply ← \\leftarrow right 4\nnot_converse_imply ↚ \\nleftarrow right 4","category":"page"},{"location":"manual/operators/#nullary_operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"tautology()\n⊤()\n\nLogical true operator.\n\n⊤ can be typed by \\top<tab>.\n\nExamples\n\njulia> TruthTable([PAndQ.Tree(⊤)])\n┌───┐\n│ ⊤ │\n├───┤\n│ ⊤ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"contradiction()\n⊥()\n\nLogical false operator.\n\n⊥ can be typed by \\bot<tab>.\n\nExamples\n\njulia> TruthTable([PAndQ.Tree(⊥)])\n┌───┐\n│ ⊥ │\n├───┤\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#unary_operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identity\nnot","category":"page"},{"location":"manual/operators/#Base.identity","page":"Operators","title":"Base.identity","text":"identity(p)\n𝒾(p)\n\nLogical identity operator.\n\nExamples\n\njulia> @atomize TruthTable([𝒾(p)])\n┌───┐\n│ p │\n├───┤\n│ ⊤ │\n│ ⊥ │\n└───┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"not(p)\n¬p\n\nLogical negation operator.\n\n¬ can be typed by \\neg<tab>.\n\nExamples\n\njulia> @atomize TruthTable([¬p])\n┌───┬────┐\n│ p │ ¬p │\n├───┼────┤\n│ ⊤ │ ⊥  │\n│ ⊥ │ ⊤  │\n└───┴────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#binary_operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tip: Tip\nEach binary operator bo has been curried such that bo(p) = Base.Fix2(bo, p) and bo(p)(q) == bo(p, q).","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nnand\nnor\nor\nxor\nxnor\nimply\nnot_imply\nconverse_imply\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"and(p, q)\np ∧ q\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ∧ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∧ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nand","page":"Operators","title":"Base.nand","text":"nand(p, q)\np ⊼ q\n\nLogical non-conjunction operator.\n\n⊼ can be typed by \\nand<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ⊼ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊼ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nor","page":"Operators","title":"Base.nor","text":"nor(p, q)\np ⊽ q\n\nLogical non-disjunction operator.\n\n⊽ can be typed by \\nor<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ⊽ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊽ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"or(p, q)\np ∨ q\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ∨ q])\n┌───┬───┬───────┐\n│ p │ q │ p ∨ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.xor","page":"Operators","title":"Base.xor","text":"xor(p, q)\np ⊻ q\n\nLogical exclusive disjunction operator.\n\n⊻ can be typed by \\xor<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ⊻ q])\n┌───┬───┬───────┐\n│ p │ q │ p ⊻ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.xnor","page":"Operators","title":"PAndQ.xnor","text":"xnor(p, q)\np ↔ q\n\nLogical exclusive non-disjunction operator.\n\n↔ can be typed by \\leftrightarrow<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ↔ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↔ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"imply(p, q)\np → q\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p → q])\n┌───┬───┬───────┐\n│ p │ q │ p → q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"not_imply(p, q)\np ↛ q\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ↛ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↛ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"converse_imply(p, q)\np ← q\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ← q])\n┌───┬───┬───────┐\n│ p │ q │ p ← q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊤     │\n│ ⊥ │ ⊤ │ ⊥     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊤     │\n│ ⊥ │ ⊥ │ ⊤     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"not_converse_imply(p, q)\np ↚ q\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow<tab>.\n\nExamples\n\njulia> @atomize TruthTable([p ↚ q])\n┌───┬───┬───────┐\n│ p │ q │ p ↚ q │\n├───┼───┼───────┤\n│ ⊤ │ ⊤ │ ⊥     │\n│ ⊥ │ ⊤ │ ⊤     │\n├───┼───┼───────┤\n│ ⊤ │ ⊥ │ ⊥     │\n│ ⊥ │ ⊥ │ ⊥     │\n└───┴───┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Reductions","page":"Operators","title":"Reductions","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"conjunction\ndisjunction","category":"page"},{"location":"manual/operators/#PAndQ.conjunction","page":"Operators","title":"PAndQ.conjunction","text":"conjunction(ps)\n⋀(ps)\n\nEquivalent to foldl(∧, ps; init = true).\n\n⋀ can be typed by \\bigwedge<tab>.\n\nSee also and.\n\nExamples\n\njulia> @atomize ⋀([p, q, r, s])\n((p ∧ q) ∧ r) ∧ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.disjunction","page":"Operators","title":"PAndQ.disjunction","text":"disjunction(ps)\n⋁(ps)\n\nEquivalent to foldl(∨, ps; init = false).\n\n⋁ can be typed by \\bigvee<tab>.\n\nSee also or.\n\nExamples\n\njulia> @atomize ⋁([p, q, r, s])\n((p ∨ q) ∨ r) ∨ s\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Utilities","page":"Operators","title":"Utilities","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"arity","category":"page"},{"location":"manual/operators/#PAndQ.arity","page":"Operators","title":"PAndQ.arity","text":"arity(lo)\n\nReturn the arity of the given logical operator.\n\nExamples\n\njulia> arity(tautology)\n0\n\njulia> arity(not)\n1\n\njulia> arity(and)\n2\n\n\n\n\n\n","category":"function"}]
}
