var documenterSearchIndex = {"docs":
[{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Language\nCompound\nPrimitive\nOperator\nBoolean\nNot\nAnd\nPropositional\nValuation\nTautology\nContradiction","category":"page"},{"location":"types/#PAQ.Language","page":"Types","title":"PAQ.Language","text":"Language\n\nSet of well-formed logical formulae.\n\nSupertype of Primitive, Compound, and Valuation.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Compound","page":"Types","title":"PAQ.Compound","text":"Compound <: Language\n\nCompound proposition.\n\nSubtype of Language. Supertype of Propositional and Modal.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Primitive","page":"Types","title":"PAQ.Primitive","text":"Primitive{S <: Union{String, Nothing}} <: Language\nPrimitive{S}([s = nothing])\n\nPrimitive proposition.\n\nSubtype of Language. See also Compound.\n\nExamples\n\njulia> p = Primitive(\"Logic is fun\")\nPrimitive(\"Logic is fun\")\n\njulia> ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(\"Logic is fun\")\n  ) \n)\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Operator","page":"Types","title":"PAQ.Operator","text":"Operator\n\nSet of functions that operate on well-formed formulae.\n\nSupertype of Boolean and Modal.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Boolean","page":"Types","title":"PAQ.Boolean","text":"Boolean <: Operator\n\nSet of functionally complete logical connectives.\n\nSubtype of Operator. Supertype of Not and And. See also Boolean Operators.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Not","page":"Types","title":"PAQ.Not","text":"Not <: Boolean <: Operator\n\nSingleton type representing logical negation that operates on a well-formed formulae.\n\nSubtype of Boolean and Operator. See also And.\n\nExamples\n\njulia> truth_table(PAQ.Not())\n2-element Vector{Pair}:\n ⊤ => ⊥\n ⊥ => ⊤\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.And","page":"Types","title":"PAQ.And","text":"And <: Boolean <: Operator\n\nSingleton type representing logical conjunction that operates on two well-formed formulae.\n\nSubtype of Boolean and Operator. See also Not.\n\nExamples\n\njulia> truth_table(PAQ.And())\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊥\n (⊥, ⊥) => ⊥\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊥\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Propositional","page":"Types","title":"PAQ.Propositional","text":"Propositional{\n    L <: Union{\n        Primitive,\n        Tuple{Not, Language},\n        Tuple{And, Language, Language}\n    }\n} <: Compound <: Language\nPropositional{L}(ϕ)\n\nAbstract syntax tree representing a compound proposition.\n\nSubtype of Compound and Language.\n\nSee also Primitive, Not, and And.\n\nExamples\n\njulia> p = Propositional(Primitive())\nPropositional(\n  Primitive(nothing)\n)\n\njulia> ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(nothing)\n  ) \n)\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Valuation","page":"Types","title":"PAQ.Valuation","text":"Valuation{V <: Union{Val{:⊥}, Val{:⊤}}} <: Language\nValuation(::V)\n\nContainer for Tautology and Contradiction. Subtype of Language.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Tautology","page":"Types","title":"PAQ.Tautology","text":"⊤\nTautology\n\nA constant which is true in every possible interpretation.\n\nOne of two valid instances of Valuation, the other instance being Contradiction.\n\n'⊤' can be typed by '\\top<tab>'.\n\nExamples\n\njulia> ¬⊤\n⊥\n\njulia> Tautology()\nPropositional(\n  Not(), Propositional(\n    And(), Propositional(\n      Primitive(nothing)\n    ) Propositional(\n      Not(), Propositional(\n        Primitive(nothing)\n      ) \n    ) \n  ) \n)\n\n\n\n\n\n","category":"constant"},{"location":"types/#PAQ.Contradiction","page":"Types","title":"PAQ.Contradiction","text":"⊥\nContradiction\n\nA constant which is false in every possible interpretation.\n\nOne of two valid instances of Valuation, the other instance being Tautology.\n\n'⊥' can be typed by '\\bot<tab>'.\n\nExamples\n\njulia> ¬⊥\n⊤\n\njulia> Contradiction()\nPropositional(\n  And(), Propositional(\n    Primitive(nothing)\n  ) Propositional(\n    Not(), Propositional(\n      Primitive(nothing)\n    ) \n  ) \n) \n\n\n\n\n\n","category":"constant"},{"location":"utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"@primitive\ntruth_table","category":"page"},{"location":"utility/#PAQ.@primitive","page":"Utility","title":"PAQ.@primitive","text":"@primitive\n\nInstantiates Primitive propositions.\n\nExamples\n\njulia> @primitive p q\n\njulia> p\nPrimitive(\"p\")\n\njulia> q\nPrimitive(\"q\")\n\n\n\n\n\n","category":"macro"},{"location":"utility/#PAQ.truth_table","page":"Utility","title":"PAQ.truth_table","text":"truth_table(operator)\n\nReturn a vector of every possible input => output pair where the inputs are Valuations.\n\njulia> truth_table(¬)\n2-element Vector{Pair}:\n ⊤ => ⊥\n ⊥ => ⊤\n\njulia> truth_table(∧)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊥\n (⊥, ⊥) => ⊥\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊥\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#Boolean-Operators","page":"Boolean Operators","title":"Boolean Operators","text":"","category":"section"},{"location":"boolean_operators/","page":"Boolean Operators","title":"Boolean Operators","text":"Name Symbol Tab completion\nnot ¬ \\neg\nand ∧ \\wedge\nPAQ.nand ⊼ \\nand\nPAQ.nor ⊽ \\nor\nor ∨ \\vee\nPAQ.xor ⊻ \\xor\nif_then → \\rightarrow\nthen_if ← \\leftarrow\nonly_if ↔ \\leftrightarrow","category":"page"},{"location":"boolean_operators/","page":"Boolean Operators","title":"Boolean Operators","text":"not\nand\nPAQ.nand\nPAQ.nor\nor\nPAQ.xor\nif_then\nthen_if\nonly_if","category":"page"},{"location":"boolean_operators/#PAQ.not","page":"Boolean Operators","title":"PAQ.not","text":"¬p\n¬(p)\nnot(p)\n\nLogical 'not' operator.\n\n'¬' can be typed by '\\neg<tab>'.\n\nSee also Not.\n\nExamples\n\njulia> truth_table(¬)\n2-element Vector{Pair}:\n ⊤ => ⊥\n ⊥ => ⊤\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.and","page":"Boolean Operators","title":"PAQ.and","text":"p ∧ q\n∧(p, q)\nand(p, q)\n\nLogical 'and' operator.\n\n'∧' can be typed by '\\wedge<tab>'.\n\nSee also And.\n\nExamples\n\njulia> truth_table(∧)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊥\n (⊥, ⊥) => ⊥\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊥\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.or","page":"Boolean Operators","title":"PAQ.or","text":"p ∨ q\n∨(p, q)\nor(p, q)\n\nLogical 'or' operator.\n\n'∨' can be typed by '\\vee<tab>'.\n\nExamples\n\njulia> truth_table(∨)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊤\n (⊥, ⊥) => ⊥\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊤\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#Base.xor","page":"Boolean Operators","title":"Base.xor","text":"p ⊻ q\n⊻(p, q)\nxor(p, q)\n\nLogical 'xor' operator.\n\n'⊻' can be typed by '\\xor<tab>'.\n\nExamples\n\njulia> truth_table(⊻)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊤\n (⊥, ⊥) => ⊥\n (⊤, ⊤) => ⊥\n (⊥, ⊤) => ⊤\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.if_then","page":"Boolean Operators","title":"PAQ.if_then","text":"p → q\n→(p, q)\nif_then(p, q)\n\nLogical 'if_then' operator.\n\n'→' can be typed by '\\rightarrow<tab>'.\n\nExamples\n\njulia> truth_table(→)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊥\n (⊥, ⊥) => ⊤\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊤\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.then_if","page":"Boolean Operators","title":"PAQ.then_if","text":"p ← q\n←(p, q)\nthen_if(p, q)\n\nLogical 'then_if' operator.\n\n'←' can be typed by '\\leftarrow<tab>'.\n\nExamples\n\njulia> truth_table(←)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊤\n (⊥, ⊥) => ⊤\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊥\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.only_if","page":"Boolean Operators","title":"PAQ.only_if","text":"p ↔ q\n↔(p, q)\nonly_if(p, q)\n\nLogical 'only_if' operator.\n\n'↔' can be typed by '\\leftrightarrow<tab>'.\n\nExamples\n\njulia> truth_table(↔)\n4-element Vector{Pair}:\n (⊤, ⊥) => ⊥\n (⊥, ⊥) => ⊤\n (⊤, ⊤) => ⊤\n (⊥, ⊤) => ⊥\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using PAQ\nend","category":"page"},{"location":"#PQ.jl","page":"Home","title":"P∧Q.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do you like logic? If so, then you've come to the right package! Check out the source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please mind your ps ∧ qs.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P∧Q.jl is designed to have an intuitive interface by enabling you to write code in logical symbols. This is thanks to Julia's support for Unicode and infix operators. Alternatively, every symbol has a written alias.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊥\n⊤\n\njulia> @primitive p q\n\njulia> r = ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(\"p\")\n  ) \n)\n\njulia> ¬r\nPrimitive(\"p\")\n\njulia> p ∨ ⊤\n⊤\n\njulia> ((⊥ ⊼ r) → ¬(q ⊻ ⊤)) ∨ (⊥ ∧ p)\nPrimitive(\"q\")","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url = \"https://github.com/jakobjpeters/PAQ.jl\")\n\njulia> using PAQ","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using PAQ\n    @primitive p q r\nend","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#something","page":"Tutorial","title":"something","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Remember, every infix operator is a function. They also each have a written alias.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p ∧ q == ∧(p, q) == and(p, q)\ntrue","category":"page"},{"location":"tutorial/#Minimization","page":"Tutorial","title":"Minimization","text":"","category":"section"},{"location":"tutorial/#Order-of-Operations","page":"Tutorial","title":"Order of Operations","text":"","category":"section"}]
}
