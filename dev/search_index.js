var documenterSearchIndex = {"docs":
[{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Language\nCompound\nPrimitive\nOperator\nBoolean\nNot\nAnd\nPropositional\nTruth\ntautology\ncontradiction","category":"page"},{"location":"types/#PAQ.Language","page":"Types","title":"PAQ.Language","text":"Language\n\nSet of well-formed logical formulae.\n\nSupertype of Primitive, Compound, and Truth.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Compound","page":"Types","title":"PAQ.Compound","text":"Compound <: Language\n\nCompound proposition.\n\nSubtype of Language. Supertype of Propositional.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Primitive","page":"Types","title":"PAQ.Primitive","text":"Primitive <: Language\nPrimitive([statement::String = \"\"])\n\nPrimitive proposition.\n\nSubtype of Language. See also Compound.\n\nExamples\n\njulia> p = Primitive(\"Logic is fun\")\nPrimitive(\"Logic is fun\")\n\njulia> ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(\"Logic is fun\")\n  )\n)\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Operator","page":"Types","title":"PAQ.Operator","text":"Operator\n\nSet of functions that operate on a logical Language.\n\nSupertype of Boolean.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Boolean","page":"Types","title":"PAQ.Boolean","text":"Boolean <: Operator\n\nSet of functionally complete logical connectives.\n\nSubtype of Operator. Supertype of Not and And. See also Boolean Operators.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Not","page":"Types","title":"PAQ.Not","text":"Not <: Boolean <: Operator\n\nSingleton type representing logical negation.\n\nSubtype of Boolean and Operator. See also And and Language.\n\nExamples\n\njulia> @truth_table PAQ.Not()(p)\n┌───────────┬────────────────┐\n│         p │ (PAQ.Not())(p) │\n│ Primitive │  Propositional │\n├───────────┼────────────────┤\n│         ⊤ │              ⊥ │\n│         ⊥ │              ⊤ │\n└───────────┴────────────────┘\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.And","page":"Types","title":"PAQ.And","text":"And <: Boolean <: Operator\n\nSingleton type representing logical conjunction.\n\nSubtype of Boolean and Operator. See also Not and Language.\n\nExamples\n\njulia> @truth_table PAQ.And()(p, q)\n┌───────────┬───────────┬───────────────────┐\n│         p │         q │ (PAQ.And())(p, q) │\n│ Primitive │ Primitive │     Propositional │\n├───────────┼───────────┼───────────────────┤\n│         ⊤ │         ⊤ │                 ⊤ │\n│         ⊤ │         ⊥ │                 ⊥ │\n├───────────┼───────────┼───────────────────┤\n│         ⊥ │         ⊤ │                 ⊥ │\n│         ⊥ │         ⊥ │                 ⊥ │\n└───────────┴───────────┴───────────────────┘\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Propositional","page":"Types","title":"PAQ.Propositional","text":"Propositional{\n    L <: Union{\n        Primitive,\n        Tuple{Not, Compound},\n        Tuple{And, Compound, Compound}\n    }\n} <: Compound <: Language\nPropositional(ϕ::L)\n\nAbstract syntax tree representing a compound proposition.\n\nSubtype of Compound and Language. See also Primitive, Not, and And.\n\nExamples\n\njulia> p = Propositional(Primitive(\"p\"))\nPropositional(\n  Primitive(\"p\")\n)\n\njulia> ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(\"p\")\n  )\n)\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.Truth","page":"Types","title":"PAQ.Truth","text":"Truth{V <: Union{Val{:⊥}, Val{:⊤}}} <: Language\nTruth(::V)\n\nContainer for the constants tautology and contradiction. Subtype of Language.\n\n\n\n\n\n","category":"type"},{"location":"types/#PAQ.tautology","page":"Types","title":"PAQ.tautology","text":"⊤\ntautology\n\nA constant which is true in every possible interpretation.\n\nOne of two valid instances of Truth, the other instance being contradiction.\n\n⊤ can be typed by \\top<tab>.\n\nExamples\n\njulia> ¬⊤\n⊥\n\njulia> tautology()\n⊤\n\n\n\n\n\n","category":"constant"},{"location":"types/#PAQ.contradiction","page":"Types","title":"PAQ.contradiction","text":"⊥\ncontradiction\n\nA constant which is false in every possible interpretation.\n\nOne of two valid instances of Truth, the other instance being tautology.\n\n⊥ can be typed by \\bot<tab>.\n\nExamples\n\njulia> ¬⊥\n⊤\n\njulia> contradiction()\n⊥\n\n\n\n\n\n","category":"constant"},{"location":"utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"primitives\n@primitive\n@truth_table\ninterpret","category":"page"},{"location":"utility/#PAQ.primitives","page":"Utility","title":"PAQ.primitives","text":"primitives(ps...)\n\nReturns a vector of Primitive propositions contained in p.\n\nNote that some primitives may optimized out of a statement, such as in p ∧ ⊥.\n\nExamples\n\njulia> primitives(p)\n1-element Vector{Primitive}:\n Primitive(\"p\")\n\njulia> primitives(p ∧ q, r)\n3-element Vector{Primitive}:\n Primitive(\"p\")\n Primitive(\"q\")\n Primitive(\"r\")\n\n\n\n\n\n","category":"function"},{"location":"utility/#PAQ.@primitive","page":"Utility","title":"PAQ.@primitive","text":"@primitive(ps...)\n\nInstantiates Primitive propositions.\n\nExamples\n\njulia> @primitive p q\n\njulia> p\nPrimitive(\"p\")\n\njulia> q\nPrimitive(\"q\")\n\n\n\n\n\n","category":"macro"},{"location":"utility/#PAQ.@truth_table","page":"Utility","title":"PAQ.@truth_table","text":"@truth_table(ps...)\n\nPrint a truth table for the given Compound propositions.\n\nSee also Primitive and Compound.\n\nExamples\n\njulia> @truth_table p∧q p→q\n┌───────────┬───────────┬───────────────┬───────────────┐\n│         p │         q │         p ∧ q │         p → q │\n│ Primitive │ Primitive │ Propositional │ Propositional │\n├───────────┼───────────┼───────────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊥ │             ⊥ │\n├───────────┼───────────┼───────────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊥ │             ⊤ │\n│         ⊥ │         ⊥ │             ⊥ │             ⊤ │\n└───────────┴───────────┴───────────────┴───────────────┘\n\n\n\n\n\n","category":"macro"},{"location":"utility/#PAQ.interpret","page":"Utility","title":"PAQ.interpret","text":"interpret(valuation, ϕ::Union{Primitive, Compound})\n\nGiven a valuation, \n\nA valuation is a function that maps from the Primitive propositions in ϕ to their respective Truth values.\n\nSee also Primitive, Compound, and Truth.\n\njulia> mapping = Dict(p => ⊥, q => ⊤);\n\njulia> valuation = r -> mapping[r];\n\njulia> interpret(valuation, p ∧ q)\n⊥\n\njulia> interpret(valuation, p → q)\n⊤\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#Boolean-Operators","page":"Boolean Operators","title":"Boolean Operators","text":"","category":"section"},{"location":"boolean_operators/","page":"Boolean Operators","title":"Boolean Operators","text":"Name Symbol Tab completion\nnot ¬ \\neg\nand ∧ \\wedge\nnand ⊼ \\nand\nnor ⊽ \\nor\nor ∨ \\vee\nxor ⊻ \\xor\nif_then → \\rightarrow\nthen_if ← \\leftarrow\nonly_if ↔ \\leftrightarrow","category":"page"},{"location":"boolean_operators/","page":"Boolean Operators","title":"Boolean Operators","text":"not\nand\nnand\nnor\nor\nxor\nif_then\nthen_if\nonly_if","category":"page"},{"location":"boolean_operators/#PAQ.not","page":"Boolean Operators","title":"PAQ.not","text":"¬p\n¬(p)\nnot(p)\n\nLogical not operator.\n\n¬ can be typed by \\neg<tab>.\n\nSee also Not.\n\nExamples\n\njulia> @truth_table ¬p\n┌───────────┬───────────────┐\n│         p │            ¬p │\n│ Primitive │ Propositional │\n├───────────┼───────────────┤\n│         ⊤ │             ⊥ │\n│         ⊥ │             ⊤ │\n└───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.and","page":"Boolean Operators","title":"PAQ.and","text":"p ∧ q\n∧(p, q)\nand(p, q)\n\nLogical and operator.\n\n∧ can be typed by \\wedge<tab>.\n\nSee also And.\n\nExamples\n\njulia> @truth_table p ∧ q\n┌───────────┬───────────┬───────────────┐\n│         p │         q │         p ∧ q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊥ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊥ │\n│         ⊥ │         ⊥ │             ⊥ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.or","page":"Boolean Operators","title":"PAQ.or","text":"p ∨ q\n∨(p, q)\nor(p, q)\n\nLogical or operator.\n\n∨ can be typed by \\vee<tab>.\n\nExamples\n\njulia> @truth_table p ∨ q\n┌───────────┬───────────┬───────────────┐\n│         p │         q │         p ∨ q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊤ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊤ │\n│         ⊥ │         ⊥ │             ⊥ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#Base.xor","page":"Boolean Operators","title":"Base.xor","text":"p ⊻ q\n⊻(p, q)\nxor(p, q)\n\nLogical xor operator.\n\n⊻ can be typed by \\xor<tab>.\n\nExamples\n\njulia> @truth_table p ⊻ q\n┌───────────┬───────────┬───────────────┐\n│         p │         q │         p ⊻ q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊥ │\n│         ⊤ │         ⊥ │             ⊤ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊤ │\n│         ⊥ │         ⊥ │             ⊥ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.if_then","page":"Boolean Operators","title":"PAQ.if_then","text":"p → q\n→(p, q)\nif_then(p, q)\n\nLogical if_then operator.\n\n→ can be typed by \\rightarrow<tab>.\n\nExamples\n\njulia> @truth_table p → q\n┌───────────┬───────────┬───────────────┐\n│         q │         p │         p → q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊤ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊥ │\n│         ⊥ │         ⊥ │             ⊤ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.then_if","page":"Boolean Operators","title":"PAQ.then_if","text":"p ← q\n←(p, q)\nthen_if(p, q)\n\nLogical then_if operator.\n\n← can be typed by \\leftarrow<tab>.\n\nExamples\n\njulia> @truth_table p ← q\n┌───────────┬───────────┬───────────────┐\n│         p │         q │         p ← q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊤ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊥ │\n│         ⊥ │         ⊥ │             ⊤ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"boolean_operators/#PAQ.only_if","page":"Boolean Operators","title":"PAQ.only_if","text":"p ↔ q\n↔(p, q)\nonly_if(p, q)\n\nLogical only_if operator.\n\n↔ can be typed by \\leftrightarrow<tab>.\n\nExamples\n\njulia> @truth_table p ↔ q\n┌───────────┬───────────┬───────────────┐\n│         q │         p │         p ↔ q │\n│ Primitive │ Primitive │ Propositional │\n├───────────┼───────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊥ │\n├───────────┼───────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊥ │\n│         ⊥ │         ⊥ │             ⊤ │\n└───────────┴───────────┴───────────────┘\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using PAQ\nend","category":"page"},{"location":"#PQ.jl","page":"Home","title":"P∧Q.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do you like logic? If so, then you've come to the right package! Check out the source code.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"P∧Q.jl implements propositional logic (with more to come). It is designed to have an intuitive interface by enabling you to write and evaluate logical statements symbolically. This is thanks to Julia's support for Unicode and infix operators. Alternatively, every symbol has a written alias.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url = \"https://github.com/jakobjpeters/PAQ.jl\")\n\njulia> using PAQ","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> ¬⊥\n⊤\n\njulia> @primitive p q\n\njulia> r = ¬p\nPropositional(\n  Not(), Propositional(\n    Primitive(\"p\")\n  ) \n)\n\njulia> ¬r\nPrimitive(\"p\")\n\njulia> p ∨ ⊤\n⊤\n\njulia> @truth_table ¬p r p → q\n┌───────────┬───────────┬───────────────┬───────────────┐\n│         p │         q │         ¬p, r │         p → q │\n│ Primitive │ Primitive │ Propositional │ Propositional │\n├───────────┼───────────┼───────────────┼───────────────┤\n│         ⊤ │         ⊤ │             ⊥ │             ⊤ │\n│         ⊤ │         ⊥ │             ⊥ │             ⊥ │\n├───────────┼───────────┼───────────────┼───────────────┤\n│         ⊥ │         ⊤ │             ⊤ │             ⊤ │\n│         ⊥ │         ⊥ │             ⊤ │             ⊤ │\n└───────────┴───────────┴───────────────┴───────────────┘","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using PAQ\n    @primitive p q r\nend","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Propositional-Logic","page":"Tutorial","title":"Propositional Logic","text":"","category":"section"},{"location":"tutorial/#Primitive-Propositions","page":"Tutorial","title":"Primitive Propositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A primitive proposition is a statement that can be true or false. For example, the statement \"Logic is fun\" may be true for you but false for someone else. Primitive propositions can be expressed as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p = Primitive(\"Logic is fun\")\nPrimitive(\"Logic is fun\")\n\njulia> q = Primitive(\"Julia is awesome\")\nPrimitive(\"Julia is awesome\")","category":"page"},{"location":"tutorial/#Compound-Propositions","page":"Tutorial","title":"Compound Propositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since p can be true or false, we can form other logical statements that depends on p's truth value. These statements use logical connectives and are called Compound propositions. To express the proposition that \"Logic is not fun\", use the logical not connective: not(p) or ¬p.  If p's truth value is true, then ¬p's truth value is false, and vice versa. A helpful tool to check a statement's truth values is @truth_table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @truth_table ¬p\n┌───────────┬───────────────┐\n│         p │            ¬p │\n│ Primitive │ Propositional │\n├───────────┼───────────────┤\n│         ⊤ │             ⊥ │\n│         ⊥ │             ⊤ │\n└───────────┴───────────────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nFor now, think of the symbols ⊤ and ⊥ as true and false, respectively. An exact definition of them will be given in a couple of paragraphs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Statements can also depend on multiple primitive propositions. The logical and connective is true when both p and q are true and is false otherwise. This is expressed as and(p, q), ∧(p, q), or p ∧ q. Repeatedly combining the connectives not and and can produce any possible truth table. As such, they are referred to as functionally complete. For example, the connective or is equivalent to ¬(¬p ∧ ¬q).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @truth_table or(p, q) ¬(¬p ∧ ¬q)\n┌───────────┬───────────┬──────────────────────┐\n│         p │         q │ or(p, q), ¬(¬p ∧ ¬q) │\n│ Primitive │ Primitive │        Propositional │\n├───────────┼───────────┼──────────────────────┤\n│         ⊤ │         ⊤ │                    ⊤ │\n│         ⊤ │         ⊥ │                    ⊤ │\n├───────────┼───────────┼──────────────────────┤\n│         ⊥ │         ⊤ │                    ⊤ │\n│         ⊥ │         ⊥ │                    ⊥ │\n└───────────┴───────────┴──────────────────────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nThe first two cells of each row in this table is an interpretation, which allows the truth value of the corresponding last cell to be determined. More generally, interpretations are an assignment of meaning to logical symbols. A function that maps logical symbols to their meaning is called a valuation function.","category":"page"},{"location":"tutorial/#Truth-Values","page":"Tutorial","title":"Truth Values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider the proposition p ∧ ¬p. Using the earlier example, this states that both \"Logic is fun\" and \"Logic is not fun\". Since these statements are mutually exclusive, their conjunction forms a contradiction. A contradiction is a statement that is false in every possible interpretation. In other words, the statement p ∧ ¬p is false regardless of whether p's truth value is true or false. A contradiction can be expressed as contradiction or with the symbol ⊥. The negation of a contradiction, in this case ¬(p ∧ ¬p), results in a statement that is true in every possible interpretation. This is called a tautology and can be expressed as tautology or with the symbol ⊤. Contradiction and tautology symbols are also be used to express the concepts of true and false, respectively.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nNote that ⊤ is a Unicode symbol, not an uppercase \"t\". The documentation for each symbol provides instructions on how to type it. For example, ⊤ can be typed by \\top<tab>. See also Julia's documentation on Unicode Input.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ¬⊥\n⊤\n\njulia> p ∧ ⊤ # identity law\nPrimitive(\"p\")\n\njulia> p ∧ ⊥ # domination law\n⊥","category":"page"},{"location":"tutorial/#Implementation","page":"Tutorial","title":"Implementation","text":"","category":"section"},{"location":"tutorial/#Types","page":"Tutorial","title":"Types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PAQ # hide\nusing InteractiveUtils # hide\nusing AbstractTrees # hide\n\nAbstractTrees.children(x::Type) = InteractiveUtils.subtypes(x) # hide\nprint_tree(Language) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In Backus-Naur Form (BNF), Propositional is defined inductively as:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ϕ ::= p | ¬ψ | ψ ∧ ψ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since we may want to refer to compound statements defined differently, ψ has the abstract type Compound rather than being a Propositional.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Remember, every infix operator is a function. They also each have a written alias.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p ∧ q === ∧(p, q) === and(p, q)\ntrue","category":"page"},{"location":"tutorial/#Minimization","page":"Tutorial","title":"Minimization","text":"","category":"section"},{"location":"tutorial/#Order-of-Operations","page":"Tutorial","title":"Order of Operations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<!– associativity –>","category":"page"}]
}
