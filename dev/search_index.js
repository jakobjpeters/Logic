var documenterSearchIndex = {"docs":
[{"location":"manual/operators/","page":"Operators","title":"Operators","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"manual/operators/#operators_operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Typing symbols with tab completion is performed by typing \\, followed by the given characters, and then the [TAB] key. For example, ⊥ is typed with \\bot[TAB]. See also Julia's documentation on Tab Completion and Unicode Input.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Operator associativity determines how operators with the same precedence group their operands. For example, ∧ is left associative. Therefore, p ∧ q ∧ r is equivalent to (p ∧ q) ∧ r. Operator precedence determines how expressions with distinct operators are grouped together. Higher precedence operators will group their operands before lower precedence operators. For example, ∧ has a higher precedence than ∨. Therefore, p ∨ q ∧ r is equivalent to p ∨ (q ∧ r), even though both operators are left associative. See also Julia's documentation on Operator Precedence and Associativity.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"info: Info\n== has a precedence of 7, which is higher than that of several binary operators. For some cases, you may need to use parentheses. For example, @p p → q == r will error, but @p (p → q) == r will correctly return false.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Name Symbol Tab Completion Associativity Precedence\ntautology ⊤ \\top none 0\ncontradiction ⊥ \\bot none 0\nnot ¬ \\neg right 0\nand ∧ \\wedge left 12\nnand ⊼ \\nand left 12\nnor ⊽ \\nor left 11\nor ∨ \\vee left 11\nxor ⊻ \\xor left 11\nxnor ↔ \\leftrightarrow right 4\nimply → \\rightarrow right 4\nnot_imply ↛ \\nrightarrow right 4\nconverse_imply ← \\leftarrow right 4\nnot_converse_imply ↚ \\nleftarrow right 4","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"Every possible truth table can be constructed with the functionally complete set of operators not and and. For convenience, all sixteen of them have been prepared. There are ten binary operators, with the remaining six being expressed with truth values, individual propositions, and the unary not operator.","category":"page"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"julia> @p TruthTable(⊤, ⊥, ¬p, ¬q)\n┌────────┬────────┬──────┬──────┬─────────┬─────────┐\n│ ⊤      │ ⊥      │ p    │ q    │ ¬p      │ ¬q      │\n│ Clause │ Clause │ Atom │ Atom │ Literal │ Literal │\n├────────┼────────┼──────┼──────┼─────────┼─────────┤\n│ ⊤      │ ⊥      │ ⊤    │ ⊤    │ ⊥       │ ⊥       │\n│ ⊤      │ ⊥      │ ⊥    │ ⊤    │ ⊤       │ ⊥       │\n├────────┼────────┼──────┼──────┼─────────┼─────────┤\n│ ⊤      │ ⊥      │ ⊤    │ ⊥    │ ⊥       │ ⊤       │\n│ ⊤      │ ⊥      │ ⊥    │ ⊥    │ ⊤       │ ⊤       │\n└────────┴────────┴──────┴──────┴─────────┴─────────┘","category":"page"},{"location":"manual/operators/#Nullary-Operators","page":"Operators","title":"Nullary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"tautology\ncontradiction","category":"page"},{"location":"manual/operators/#PAndQ.tautology","page":"Operators","title":"PAndQ.tautology","text":"⊤()\ntautology()\n\nLogical true operator.\n\n⊤ can be typed by \\top<tab>.\n\nExamples\n\njulia> ⊤()\ntautology (generic function with 1 method)\n\njulia> @p TruthTable(⊤)\n┌────────┐\n│ ⊤      │\n│ Clause │\n├────────┤\n│ ⊤      │\n└────────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.contradiction","page":"Operators","title":"PAndQ.contradiction","text":"⊥()\ncontradiction()\n\nLogical false operator.\n\n⊥ can be typed by \\bot<tab>.\n\nExamples\n\njulia> ⊥()\ncontradiction (generic function with 1 method)\n\njulia> @p TruthTable(⊥)\n┌────────┐\n│ ⊥      │\n│ Clause │\n├────────┤\n│ ⊥      │\n└────────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Unary-Operators","page":"Operators","title":"Unary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"identity\nnot","category":"page"},{"location":"manual/operators/#Base.identity","page":"Operators","title":"Base.identity","text":"identity(::Proposition)\n\nLogical identity operator.\n\nExamples\n\njulia> @p TruthTable(p)\n┌──────┐\n│ p    │\n│ Atom │\n├──────┤\n│ ⊤    │\n│ ⊥    │\n└──────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not","page":"Operators","title":"PAndQ.not","text":"¬p\n¬(p)\nnot(p)\n\nLogical negation operator.\n\n¬ can be typed by \\neg<tab>.\n\nExamples\n\njulia> @p TruthTable(¬p)\n┌──────┬─────────┐\n│ p    │ ¬p      │\n│ Atom │ Literal │\n├──────┼─────────┤\n│ ⊤    │ ⊥       │\n│ ⊥    │ ⊤       │\n└──────┴─────────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Binary-Operators","page":"Operators","title":"Binary Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"and\nnand\nnor\nor\nxor\nxnor\nimply\nnot_imply\nconverse_imply\nnot_converse_imply","category":"page"},{"location":"manual/operators/#PAndQ.and","page":"Operators","title":"PAndQ.and","text":"p ∧ q\n∧(p, q)\nand(p, q)\n\nLogical conjunction operator.\n\n∧ can be typed by \\wedge<tab>.\n\nExamples\n\njulia> @p TruthTable(p ∧ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ∧ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊤     │\n│ ⊥    │ ⊤    │ ⊥     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊥     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nand","page":"Operators","title":"Base.nand","text":"p ⊼ q\n⊼(p, q)\nnand(p, q)\n\nLogical non-conjunction operator.\n\n⊼ can be typed by \\nand<tab>.\n\nExamples\n\njulia> @p TruthTable(p ⊼ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ⊼ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊤     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.nor","page":"Operators","title":"Base.nor","text":"p ⊽ q\n⊽(p, q)\nnor(p, q)\n\nLogical non-disjunction operator.\n\n⊽ can be typed by \\nor<tab>.\n\nExamples\n\njulia> @p TruthTable(p ⊽ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ⊽ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊥     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊥     │\n│ ⊥    │ ⊥    │ ⊤     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.or","page":"Operators","title":"PAndQ.or","text":"p ∨ q\n∨(p, q)\nor(p, q)\n\nLogical disjunction operator.\n\n∨ can be typed by \\vee<tab>.\n\nExamples\n\njulia> @p TruthTable(p ∨ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ∨ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊤     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#Base.xor","page":"Operators","title":"Base.xor","text":"p ⊻ q\n⊻(p, q)\nxor(p, q)\n\nLogical exclusive disjunction operator.\n\n⊻ can be typed by \\xor<tab>.\n\nExamples\n\njulia> @p TruthTable(p ⊻ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ⊻ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.xnor","page":"Operators","title":"PAndQ.xnor","text":"p ↔ q\n↔(p, q)\nxnor(p, q)\n\nLogical exclusive non-disjunction and biconditional operator.\n\n↔ can be typed by \\leftrightarrow<tab>.\n\nExamples\n\njulia> @p TruthTable(p ↔ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ↔ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊤     │\n│ ⊥    │ ⊤    │ ⊥     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊥     │\n│ ⊥    │ ⊥    │ ⊤     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.imply","page":"Operators","title":"PAndQ.imply","text":"p → q\n→(p, q)\nimply(p, q)\n\nLogical implication operator.\n\n→ can be typed by \\rightarrow<tab>.\n\nExamples\n\njulia> @p TruthTable(p → q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p → q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊤     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊥     │\n│ ⊥    │ ⊥    │ ⊤     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_imply","page":"Operators","title":"PAndQ.not_imply","text":"p ↛ q\n↛(p, q)\nnot_imply(p, q)\n\nLogical non-implication operator.\n\n↛ can be typed by \\nrightarrow<tab>.\n\nExamples\n\njulia> @p TruthTable(p ↛ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ↛ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊥     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.converse_imply","page":"Operators","title":"PAndQ.converse_imply","text":"p ← q\n←(p, q)\nconverse_imply(p, q)\n\nLogical converse implication operator.\n\n← can be typed by \\leftarrow<tab>.\n\nExamples\n\njulia> @p TruthTable(p ← q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ← q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊤     │\n│ ⊥    │ ⊤    │ ⊥     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊤     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/operators/#PAndQ.not_converse_imply","page":"Operators","title":"PAndQ.not_converse_imply","text":"p ↚ q\n↚(p, q)\nnot_converse_imply(p, q)\n\nLogical converse non-implication operator.\n\n↚ can be typed by \\nleftarrow<tab>.\n\nExamples\n\njulia> @p TruthTable(p ↚ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ↚ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊥     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘\n\n\n\n\n\n","category":"function"},{"location":"manual/propositions/#Propositions","page":"Propositions","title":"Propositions","text":"","category":"section"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"tip: Tip\nPropositions can be converted into different, but logically equivalent forms (see also ==). For example, ⊥ == Tree(⊥) == Clause(⊥) == Normal(⊥). However, not all forms are Expressively complete. Otherwise, the conversion may throw an exception. For example, there is no way to represent Literal(⊥).","category":"page"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"import AbstractTrees: children # hide\nusing AbstractTrees: print_tree # hide\nusing InteractiveUtils: subtypes # hide\nusing PAndQ: Proposition # hide\n\nchildren(x::Type) = subtypes(x) # hide\nprint_tree(Proposition) # hide","category":"page"},{"location":"manual/propositions/","page":"Propositions","title":"Propositions","text":"Proposition\nCompound\nExpressive\nAtom\nLiteral\nTree\nClause\nNormal","category":"page"},{"location":"manual/propositions/#PAndQ.Proposition","page":"Propositions","title":"PAndQ.Proposition","text":"Proposition\n\nThe set of well-formed logical formulae.\n\nSupertype of Atom and Compound.\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Compound","page":"Propositions","title":"PAndQ.Compound","text":"Compound <: Proposition\n\nA proposition composed from connecting Atomicpropositions with LogicalOperators.\n\nSubtype of Proposition. Supertype of Literal, Clause, and Expressive.\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Expressive","page":"Propositions","title":"PAndQ.Expressive","text":"Expressive <: Compound\n\nA proposition that is expressively complete.\n\nSubtype of Compound. Supertype of Tree and Normal.\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Atom","page":"Propositions","title":"PAndQ.Atom","text":"Atom{T} <: Proposition\nAtom(::T)\nAtom(::AtomicProposition)\n\nA proposition with no deeper propositional structure.\n\ntip: Tip\nDefine pretty-printing for an instance of Atom{T} by overloading show(io::IO, p::Atom{T}).\n\ntip: Tip\nUse @atoms and @p as shortcuts to define atoms or instantiate them inline, respectively.\n\nSubtype of Proposition. See also AtomicProposition and LiteralProposition.\n\nExamples\n\njulia> Atom(:p)\np\n\njulia> Atom(\"Logic is fun\")\nAtom(\"Logic is fun\")\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Literal","page":"Propositions","title":"PAndQ.Literal","text":"Literal{UO <: UnaryOperator, T} <: Compound\nLiteral(::UO, ::Atom{T})\nLiteral(::LiteralProposition)\n\nA proposition represented by an atomic formula or its negation.\n\nSubtype of Compound. See also UnaryOperator, Atom, and LiteralProposition.\n\nExamples\n\njulia> r = @p ¬p\n¬p\n\njulia> ¬r\np\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Tree","page":"Propositions","title":"PAndQ.Tree","text":"Tree{\n    LO <: LogicalOperator,\n    P <: Union{Tuple{Proposition}, Tuple{Proposition, Proposition}}\n} <: Expressive\nTree(::Union{NullaryOperator, Proposition})\nTree(::UnaryOperator, ::Atom)\nTree(::BinaryOperator, ::Tree, ::Tree)\n\nA proposition represented by an abstract syntax tree.\n\nSubtype of Expressive.\n\nExamples\n\njulia> @p r = p ⊻ q\np ⊻ q\n\njulia> @p ¬r → s\n(p ↔ q) → s\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Clause","page":"Propositions","title":"PAndQ.Clause","text":"Clause{AO <: AndOr, L <: Literal} <: Compound\nClause(::AO, ps = Literal[])\nClause(::AO, p::Proposition)\nClause(::Union{NullaryOperator, Proposition})\n\nA proposition represented as either a conjunction or disjunction of literals.\n\ninfo: Info\nAn empty clause is logically equivalent to the neutral element of it's binary operator.\n\nSee also Literal and NullaryOperator. Subtype of Compound.\n\nExamples\n\njulia> Clause(and)\n⊤\n\njulia> @p Clause(p)\np\n\njulia> @p Clause(or, [¬p, q])\n¬p ∨ q\n\n\n\n\n\n","category":"type"},{"location":"manual/propositions/#PAndQ.Normal","page":"Propositions","title":"PAndQ.Normal","text":"Normal{AO <: AndOr, C <: Clause} <: Expressive\nNormal(::typeof(and), ::Vector{Clause{typeof(or)}} = Clause{typeof(or)}[])\nNormal(::typeof(or), ::Vector{Clause{typeof(and)}} = Clause{typeof(and)}[])\nNormal(::AO, ::Proposition)\nNormal(::Union{NullaryOperator, Proposition})\n\nA proposition represented in conjunctive or disjunctive normal form.\n\ninfo: Info\nAn empty normal form is logically equivalent to the neutral element of it's binary operator.\n\nSee also Clause and NullaryOperator. Subtype of Expressive.\n\nExamples\n\njulia> s = @p Normal(and, [Clause(or, [p, q]), Clause(or, ¬r)])\n(p ∨ q) ∧ (¬r)\n\njulia> ¬s\n(¬p ∧ ¬q) ∨ (r)\n\n\n\n\n\n","category":"type"},{"location":"manual/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/semantics/#Semantics","page":"Semantics","title":"Semantics","text":"","category":"section"},{"location":"manual/semantics/","page":"Semantics","title":"Semantics","text":"==\ninterpret\ninterpretations\nvaluations\nsolve\nleft_neutrals\nright_neutrals\nconverse\ndual\nis_tautology\nis_contradiction\nis_truth\nis_contingency\nis_satisfiable\nis_falsifiable","category":"page"},{"location":"manual/semantics/#Base.:==","page":"Semantics","title":"Base.:==","text":"p == q\n==(p, q)\n\nReturns a boolean indicating whether p and q are logically equivalent.\n\ninfo: Info\nThe ≡ symbol is sometimes used to represent logical equivalence. However, Julia uses ≡ as an alias for the builtin function === which cannot have methods added to it. Use == and === to test for equivalence and identity, respectively.\n\nSee also Proposition.\n\nExamples\n\njulia> @p p == ¬p\nfalse\n\njulia> @p ¬(p ⊻ q) == (p → q) ∧ (p ← q)\ntrue\n\njulia> @p ¬(p ⊻ q) === (p → q) ∧ (p ← q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpret","page":"Semantics","title":"PAndQ.interpret","text":"interpret(p::Union{NullaryOperator, Proposition}, valuation...)\n\nReplaces each Atom in p with its truth value in valuation, then simplifies.\n\nvaluation is either a Dict or a set that can construct one that maps from atoms to their respective truth values.\n\nCalling p with an incomplete mapping will partially interpret it.\n\nSee also tautology and [contradiction].\n\nExamples\n\njulia> @p interpret(¬p, p => ⊤)\ncontradiction (generic function with 1 method)\n\njulia> @p p = Clause(and, [q, r, s])\nq ∧ r ∧ s\n\njulia> @p interpret(p, q => ⊤, r => ⊤)\ns\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.interpretations","page":"Semantics","title":"PAndQ.interpretations","text":"interpretations(p, valuations = valuations(p))\n\nReturn an iterator of values given by interpreting p by each valuation.\n\nSee also valuations.\n\nExamples\n\njulia> @p collect(interpretations(p))\n2-element Vector{Function}:\n tautology (generic function with 1 method)\n contradiction (generic function with 1 method)\n\njulia> @p collect(interpretations(p → q, [p => ⊤]))\n1-element Vector{Normal{typeof(and), Clause{typeof(or)}}}:\n (q)\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.valuations","page":"Semantics","title":"PAndQ.valuations","text":"valuations(atoms)\nvaluations(::Proposition)\n\nReturn an iterator containing every possible valuation of the Atoms.\n\nA valuation is a vector of Pairs which map from an atom to a truth value.\n\nExamples\n\njulia> @p collect(valuations([p]))\n2-element Vector{Vector}:\n Pair{Atom{Symbol}, typeof(tautology)}[Atom(:p) => PAndQ.tautology]\n Pair{Atom{Symbol}, typeof(contradiction)}[Atom(:p) => PAndQ.contradiction]\n\njulia> @p collect(valuations([p, q]))\n4-element Vector{Vector}:\n Pair{Atom{Symbol}, typeof(tautology)}[Atom(:p) => PAndQ.tautology, Atom(:q) => PAndQ.tautology]\n Pair{Atom{Symbol}}[Atom(:p) => PAndQ.contradiction, Atom(:q) => PAndQ.tautology]\n Pair{Atom{Symbol}}[Atom(:p) => PAndQ.tautology, Atom(:q) => PAndQ.contradiction]\n Pair{Atom{Symbol}, typeof(contradiction)}[Atom(:p) => PAndQ.contradiction, Atom(:q) => PAndQ.contradiction]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.solve","page":"Semantics","title":"PAndQ.solve","text":"solve(p, truth_value = ⊤)\n\nReturn a vector containing all interpretations such that interpret(p, interpretation) == truth_value.\n\nExamples\n\njulia> @p collect(solve(p))\n1-element Vector{Vector{Pair{Atom{Symbol}, typeof(tautology)}}}:\n [Atom(:p) => PAndQ.tautology]\n\njulia> @p collect(solve(p ⊻ q, ⊥))\n2-element Vector{Vector}:\n Pair{Atom{Symbol}, typeof(tautology)}[Atom(:p) => PAndQ.tautology, Atom(:q) => PAndQ.tautology]\n Pair{Atom{Symbol}, typeof(contradiction)}[Atom(:p) => PAndQ.contradiction, Atom(:q) => PAndQ.contradiction]\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.left_neutrals","page":"Semantics","title":"PAndQ.left_neutrals","text":"left_neutrals(::LogicalOperator)\n\nReturn the corresponding left identity elements of the operator. The identity elements can be tautology, contradiction, neither (empty set), or both.\n\nExamples\n\njulia> left_neutrals(or)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.contradiction\n\njulia> left_neutrals(imply)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.tautology\n\njulia> left_neutrals(nor)\nSet{Union{typeof(contradiction), typeof(tautology)}}()\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.right_neutrals","page":"Semantics","title":"PAndQ.right_neutrals","text":"right_neutrals(::LogicalOperator)\n\nReturn the corresponding right identity elements of the operator. The identity elements can be tautology, contradiction, neither (empty set), or both.\n\nExamples\n\njulia> right_neutrals(or)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.contradiction\n\njulia> right_neutrals(converse_imply)\nSet{Union{typeof(contradiction), typeof(tautology)}} with 1 element:\n  PAndQ.tautology\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.converse","page":"Semantics","title":"PAndQ.converse","text":"converse(::LogicalOperator)\n\nReturns the LogicalOperator that is the converse of the given boolean operator.\n\nExamples\n\njulia> converse(and)\nand (generic function with 23 methods)\n\njulia> @p and(p, q) == converse(and)(q, p)\ntrue\n\njulia> converse(imply)\nconverse_imply (generic function with 7 methods)\n\njulia> @p imply(p, q) == converse(imply)(q, p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.dual","page":"Semantics","title":"PAndQ.dual","text":"dual(::LogicalOperator)\n\nReturns the LogicalOperator that is the dual of the given boolean operator.\n\nExamples\n\njulia> dual(and)\nor (generic function with 19 methods)\n\njulia> @p and(p, q) == not(dual(and)(not(p), not(q)))\ntrue\n\njulia> dual(imply)\nnot_converse_imply (generic function with 6 methods)\n\njulia> @p imply(p, q) == not(dual(imply)(not(p), not(q)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_tautology","page":"Semantics","title":"PAndQ.is_tautology","text":"is_tautology(p)\n\nReturns a boolean on whether p is a tautology.\n\nExamples\n\njulia> is_tautology(⊤)\ntrue\n\njulia> @p is_tautology(p)\nfalse\n\njulia> @p is_tautology(¬(p ∧ ¬p))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contradiction","page":"Semantics","title":"PAndQ.is_contradiction","text":"is_contradiction(p)\n\nReturns a boolean on whether p is a contradiction.\n\nExamples\n\njulia> is_contradiction(⊥)\ntrue\n\njulia> @p is_contradiction(p)\nfalse\n\njulia> @p is_contradiction(p ∧ ¬p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_truth","page":"Semantics","title":"PAndQ.is_truth","text":"is_truth(p)\n\nReturns a boolean on whether p is a truth value (either a tautology or contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_truth(⊤)\ntrue\n\njulia> @p is_truth(p ∧ ¬p)\ntrue\n\njulia> @p is_truth(p)\nfalse\n\njulia> @p is_truth(p ∧ q)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_contingency","page":"Semantics","title":"PAndQ.is_contingency","text":"is_contingency(p)\n\nReturns a boolean on whether p is a contingency (neither a tautology or contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_contingency(⊤)\nfalse\n\njulia> @p is_contingency(p ∧ ¬p)\nfalse\n\njulia> @p is_contingency(p)\ntrue\n\njulia> @p is_contingency(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_satisfiable","page":"Semantics","title":"PAndQ.is_satisfiable","text":"is_satisfiable(p)\n\nReturns a boolean on whether p is satisfiable (not a contradiction).\n\nSee also Proposition.\n\nExamples\n\njulia> is_satisfiable(⊤)\ntrue\n\njulia> @p is_satisfiable(p ∧ ¬p)\nfalse\n\njulia> @p is_satisfiable(p)\ntrue\n\njulia> @p is_satisfiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/semantics/#PAndQ.is_falsifiable","page":"Semantics","title":"PAndQ.is_falsifiable","text":"is_falsifiable(p)\n\nReturns a boolean on whether p is falsifiable (not a tautology).\n\nSee also Proposition.\n\nExamples\n\njulia> is_falsifiable(⊥)\ntrue\n\njulia> @p is_falsifiable(¬(p ∧ ¬p))\nfalse\n\njulia> @p is_falsifiable(p)\ntrue\n\njulia> @p is_falsifiable(p ∧ q)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"manual/utility/","page":"Utility","title":"Utility","text":"arity\n@atoms\n@p\n@p_str\natoms\nconjunction\ndisjunction","category":"page"},{"location":"manual/utility/#PAndQ.arity","page":"Utility","title":"PAndQ.arity","text":"arity(::LogicalOperator)\n\nReturns the arity of the given LogicalOperator.\n\nExamples\n\njulia> arity(tautology)\n0\n\njulia> arity(not)\n1\n\njulia> arity(and)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/utility/#PAndQ.@atoms","page":"Utility","title":"PAndQ.@atoms","text":"@atoms(ps...)\n\nInstantiate and define Atoms with symbols and return a vector containing them.\n\ninfo: Info\nAtoms are defined in the global scope as constants.\n\nExamples\n\njulia> @atoms p q\n2-element Vector{Atom{Symbol}}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\n\n\n\n\n","category":"macro"},{"location":"manual/utility/#PAndQ.@p","page":"Utility","title":"PAndQ.@p","text":"@p(expression)\n\nInstantiates each undefined variable (ignoring variable assignment and keyword arguments) as an Atom{Symbol}.\n\nExamples\n\njulia> @p x = p\np\n\njulia> @p x ∧ q → r\n(p ∧ q) → r\n\n\n\n\n\n","category":"macro"},{"location":"manual/utility/#PAndQ.@p_str","page":"Utility","title":"PAndQ.@p_str","text":"@p_str(x)\n\nExamples\n\njulia> p = @p_str(\"x\")\nx\n\njulia> p\"p ∧ q, Clause(and)\"\n(Tree(and, Tree(identity, Atom(:x)), Tree(identity, Atom(:q))), Clause(and, []))\n\n\n\n\n\n","category":"macro"},{"location":"manual/utility/#PAndQ.atoms","page":"Utility","title":"PAndQ.atoms","text":"atoms(::Proposition)\n\nReturns a vector of unique Atoms contained in the given Proposition.\n\nwarning: Warning\nSome atoms may optimized out of an expression, such as in p ∧ ⊥ == ⊥.\n\nExamples\n\njulia> @p atoms(¬p)\n1-element Vector{Atom{Symbol}}:\n p\n\njulia> @p atoms(p ∧ q)\n2-element Vector{Atom}:\n p\n q\n\n\n\n\n\n","category":"function"},{"location":"manual/utility/#PAndQ.conjunction","page":"Utility","title":"PAndQ.conjunction","text":"⋀(ps)\nconjunction(ps)\n\nEquivalent to foldl(and, ps; init = ⊤).\n\n⋀ can be typed by \\bigwedge<tab>.\n\nSee also and.\n\nExamples\n\njulia> @p ⋀([p, q, r, s])\n((p ∧ q) ∧ r) ∧ s\n\n\n\n\n\n","category":"function"},{"location":"manual/utility/#PAndQ.disjunction","page":"Utility","title":"PAndQ.disjunction","text":"⋁(ps)\ndisjunction(ps)\n\nEquivalent to foldl(or, ps; init = ⊥).\n\n⋁ can be typed by \\bigvee<tab>.\n\nSee also or.\n\nExamples\n\njulia> @p ⋁([p, q, r, s])\n((p ∨ q) ∨ r) ∨ s\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"manual/printing/","page":"Printing","title":"Printing","text":"TruthTable\nprint_truth_table\nprintln_truth_table\nprint_tree\nprintln_tree\nprint_latex\nprintln_latex\nprint_markdown\nprintln_markdown","category":"page"},{"location":"manual/printing/#PAndQ.TruthTable","page":"Printing","title":"PAndQ.TruthTable","text":"TruthTable(ps)\n\nConstruct a truth table for the given Propositions and LogicalOperators.\n\nThe header is a vector containing vectors of logically equivalent propositions. The sub_header corresponds to the header, but contains each proposition's UnionAll type. The body is a matrix where the rows contain interpretations and the columns correspond to elements in the header and sub_header.\n\nLogically equivalent propositions are grouped in the same column.\n\nSee also tautology and contradiction.\n\nExamples\n\njulia> @p TruthTable(p ∧ ¬p, p ∧ q)\n┌────────┬──────┬──────┬───────┐\n│ p ∧ ¬p │ p    │ q    │ p ∧ q │\n│ Tree   │ Atom │ Atom │ Tree  │\n├────────┼──────┼──────┼───────┤\n│ ⊥      │ ⊤    │ ⊤    │ ⊤     │\n│ ⊥      │ ⊥    │ ⊤    │ ⊥     │\n├────────┼──────┼──────┼───────┤\n│ ⊥      │ ⊤    │ ⊥    │ ⊥     │\n│ ⊥      │ ⊥    │ ⊥    │ ⊥     │\n└────────┴──────┴──────┴───────┘\n\njulia> TruthTable([⊻, imply])\n┌──────┬──────┬────────┬────────┐\n│ _    │ __   │ _ ⊻ __ │ _ → __ │\n│ Atom │ Atom │ Tree   │ Tree   │\n├──────┼──────┼────────┼────────┤\n│ ⊤    │ ⊤    │ ⊥      │ ⊤      │\n│ ⊥    │ ⊤    │ ⊤      │ ⊤      │\n├──────┼──────┼────────┼────────┤\n│ ⊤    │ ⊥    │ ⊤      │ ⊥      │\n│ ⊥    │ ⊥    │ ⊥      │ ⊤      │\n└──────┴──────┴────────┴────────┘\n\n\n\n\n\n","category":"type"},{"location":"manual/printing/#PAndQ.print_truth_table","page":"Printing","title":"PAndQ.print_truth_table","text":"print_truth_table([io::Union{IO, String}], x, backend = :text, kwargs...)\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.println_truth_table","page":"Printing","title":"PAndQ.println_truth_table","text":"println_truth_table(args...; kwargs...)\n\nEquivalent to print_truth_table(args...; kwargs..., newline = true).\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_tree","page":"Printing","title":"PAndQ.print_tree","text":"print_tree([io::Union{IO, String} = stdout], p; max_depth = typemax(Int64), newline = false, kwargs...)\n\nPrints a tree diagram of p.\n\nIf p isn't a Tree, it will be converted to one. The optional argument max_depth will truncate sub-trees at that depth.\n\njulia> @p print_tree(p ⊻ q)\n⊻\n├─ p\n└─ q\n\njulia> @p print_tree((p ∧ ¬q) ∨ (¬p ∧ q))\n∨\n├─ ∧\n│  ├─ p\n│  └─ ¬\n│     └─ q\n└─ ∧\n   ├─ ¬\n   │  └─ p\n   └─ q\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.println_tree","page":"Printing","title":"PAndQ.println_tree","text":"println_tree(args...; kwargs...)\n\nEquivalent to print_tree(args...; kwargs..., newline = true).\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_latex","page":"Printing","title":"PAndQ.print_latex","text":"print_latex([io::Union{IO, String} = stdout], x, delimeter = \"\\(\" => \"\\)\")\n\nReturn a string representation of x enclosed by delimeter, replacing each symbol with it's respective command.\n\nExamples\n\njulia> @p s = print_latex(String, p ∧ q)\n\"\\\\(p \\\\wedge q\\\\)\"\n\njulia> println(s)\n\\(p \\wedge q\\)\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.println_latex","page":"Printing","title":"PAndQ.println_latex","text":"println_latex(args...; kwargs...)\n\nEquivalent to print_latex(args...; kwargs..., newline = true).\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.print_markdown","page":"Printing","title":"PAndQ.print_markdown","text":"print_markdown\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"manual/printing/#PAndQ.println_markdown","page":"Printing","title":"PAndQ.println_markdown","text":"println_markdown(args...; kwargs...)\n\nEquivalent to print_markdown(args...; kwargs..., newline = true).\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you like propositional logic, then you've come to the right place!","category":"page"},{"location":"","page":"Home","title":"Home","text":"P∧Q has an intuitive interface that enables you to manipulate logical expressions symbolically. Propositions have multiple representations which can be easily converted and extended. Several utilities have been provided for convenience, visualization, and solving propositions.","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg: add\n\njulia> add(\"PAndQ\")\n\njulia> using PAndQ\n\njulia> ¬⊥\ntautology (generic function with 1 method)\n\njulia> @atoms p q\n2-element Vector{Atom{Symbol}}:\n p\n q\n\njulia> r = ¬p\nLiteral:\n ¬p\n\njulia> s = Clause(and, p, ¬q)\nClause:\n p ∧ ¬q\n\njulia> @p t = ((q ∧ r) ↔ a)(a => ⊤)\nNormal:\n (q) ∧ (¬p)\n\njulia> u = s ∨ t\nNormal:\n (p ∧ ¬q) ∨ (q ∧ ¬p)\n\njulia> TruthTable(p ∧ ¬p, r, p ⊻ q, u)\n┌────────┬──────┬──────┬─────────┬────────────────────────────┐\n│ p ∧ ¬p │ p    │ q    │ ¬p      │ p ⊻ q, (p ∧ ¬q) ∨ (q ∧ ¬p) │\n│ Tree   │ Atom │ Atom │ Literal │ Tree, Normal               │\n├────────┼──────┼──────┼─────────┼────────────────────────────┤\n│ ⊥      │ ⊤    │ ⊤    │ ⊥       │ ⊥                          │\n│ ⊥      │ ⊥    │ ⊤    │ ⊤       │ ⊤                          │\n├────────┼──────┼──────┼─────────┼────────────────────────────┤\n│ ⊥      │ ⊤    │ ⊥    │ ⊥       │ ⊤                          │\n│ ⊥      │ ⊥    │ ⊥    │ ⊤       │ ⊥                          │\n└────────┴──────┴──────┴─────────┴────────────────────────────┘","category":"page"},{"location":"#Related-Projects","page":"Home","title":"Related Projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PAndQ.jl is currently best suited for learning and visualizing propositional logic. The user interface is well-documented and has numerous quality of life features that make it easy to create, manipulate, and query about propositions. Further, propositions can be converted, visualized, and output in several different forms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features such as a fast satisfiability algorithm, proofs, and other logics are still in development. In the meantime, check out the these excellent projects.","category":"page"},{"location":"#Top-Picks","page":"Home","title":"Top Picks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julog.jl\nLogicCircuits.jl\nSoleLogics.jl\nFirstOrderLogic.jl\nModalDecisionTrees.jl","category":"page"},{"location":"#Computer-Algebra-Systems","page":"Home","title":"Computer Algebra Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Symbolics.jl\nMetatheory.jl\nRewrite.jl\nSimplify.jl\nSymbolicUtils.jl","category":"page"},{"location":"#Constraint-Solvers","page":"Home","title":"Constraint Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConstraintSolver.jl\nJuMP.jl","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chuffed\nCPLEXCP.jl\nJaCoP.jl","category":"page"},{"location":"#Wrappers-2","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Z3.jl\nPicoSat.jl\nBeeEncoder.jl\nSatisfiabilityInterface.jl","category":"page"},{"location":"#Honorable-Mentions","page":"Home","title":"Honorable Mentions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TruthTables.jl\nSimpleSATSolver.jl\nPropositionalLogic.jl\nMathematicalPredicates.jl\ncombinators","category":"page"},{"location":"#Kanren","page":"Home","title":"Kanren","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MuKanren.jl\nLilKanren.jl\nMiniKanren\nYet Another MicroKanren in Julia","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#internals_operators","page":"Internals","title":"Operators","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"PAndQ.NullaryOperator\nPAndQ.UnaryOperator\nPAndQ.BinaryOperator\nPAndQ.LogicalOperator\nPAndQ.CommutativeOperator\nPAndQ.AssociativeOperator\nPAndQ.LeftNeutralOperator\nPAndQ.RightNeutralOperator\nPAndQ.AndOr","category":"page"},{"location":"internals/#PAndQ.NullaryOperator","page":"Internals","title":"PAndQ.NullaryOperator","text":"NullaryOperator\n\nThe Union of LogicalOperators that take zero arguments.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.UnaryOperator","page":"Internals","title":"PAndQ.UnaryOperator","text":"UnaryOperator\n\nThe Union of LogicalOperators that take one argument.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.BinaryOperator","page":"Internals","title":"PAndQ.BinaryOperator","text":"BinaryOperator\n\nThe Union of LogicalOperators that take two arguments.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.LogicalOperator","page":"Internals","title":"PAndQ.LogicalOperator","text":"LogicalOperator\n\nThe Union of logical operators.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.CommutativeOperator","page":"Internals","title":"PAndQ.CommutativeOperator","text":"CommutativeOperator\n\nThe Union of LogicalOperators with the commutative property.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.AssociativeOperator","page":"Internals","title":"PAndQ.AssociativeOperator","text":"AssociativeOperator\n\nThe Union of LogicalOperators with the associative property.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.LeftNeutralOperator","page":"Internals","title":"PAndQ.LeftNeutralOperator","text":"LeftNeutralOperator\n\nThe Union of LogicalOperators that have one or more left_neutrals.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.RightNeutralOperator","page":"Internals","title":"PAndQ.RightNeutralOperator","text":"RightNeutralOperator\n\nThe Union of LogicalOperators that have one or more right_neutrals.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.AndOr","page":"Internals","title":"PAndQ.AndOr","text":"AndOr\n\nThe Union of and and or.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Propositions","page":"Internals","title":"Propositions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"PAndQ.AtomicProposition\nPAndQ.LiteralProposition","category":"page"},{"location":"internals/#PAndQ.AtomicProposition","page":"Internals","title":"PAndQ.AtomicProposition","text":"AtomicProposition\n\nA Proposition that is known by its type to be logically equivalent to an Atom.\n\n\n\n\n\n","category":"type"},{"location":"internals/#PAndQ.LiteralProposition","page":"Internals","title":"PAndQ.LiteralProposition","text":"LiteralProposition\n\nA Proposition that is known by its type to be logically equivalent to a Literal.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Printing","page":"Internals","title":"Printing","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"show","category":"page"},{"location":"internals/#Base.show","page":"Internals","title":"Base.show","text":"show\n\n\n\n\n\n","category":"function"},{"location":"internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"mapfoldl\nmapfoldr","category":"page"},{"location":"internals/#Base.mapfoldl","page":"Internals","title":"Base.mapfoldl","text":"mapfoldl(f, lio::LeftNeutralOperator, ps)\n\nEquivalent to mapfoldl(f, lio, ps; init = only(left_neutrals(lio)))\n\ntip: Tip\nThis also works with foldl(lio, ps).\n\nExamples\n\njulia> @p mapfoldl(not, and, [p, q, r, s])\n((¬p ∧ ¬q) ∧ ¬r) ∧ ¬s\n\njulia> foldl(and, [])\ntautology (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Base.mapfoldr","page":"Internals","title":"Base.mapfoldr","text":"mapfoldr(f, rio::RightNeutralOperator, ps)\n\nEquivalent to mapfoldr(f, rio, ps; init = only(right_neutrals(rio)))\n\ntip: Tip\nThis also works with foldr(rio, ps).\n\nExamples\n\njulia> @p mapfoldr(not, and, [p, q, r, s])\n¬p ∧ (¬q ∧ (¬r ∧ ¬s))\n\njulia> foldr(and, [])\ntautology (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Semantics","page":"Internals","title":"Semantics","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"convert","category":"page"},{"location":"internals/#Base.convert","page":"Internals","title":"Base.convert","text":"convert\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = :(using PAndQ)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Truth-Values","page":"Tutorial","title":"Truth Values","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A truth value is logic's version of a boolean true or false. These concepts can also be represented as a 1 or a 0. Similarly, we use tautology and contradiction. These are commonly represented with the symbols ⊤ and ⊥. These truth values have additional meaning, which will be discussed further on.","category":"page"},{"location":"tutorial/#tutorial_operators","page":"Tutorial","title":"Operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Just like with boolean values, we can perform operations on truth values. Both ! and the symbol ¬ represent the unary operator not.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> !true == false # boolean negation\ntrue\n\njulia> ¬⊤ == ⊥ # logical negation\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several operators that accept multiple arguments. Both && and the symbol ∧ represent the binary operator and. Both || and the symbol ∨ represent the binary operator or.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> true && false == false # boolean and\ntrue\n\njulia> true || false == true # boolean or\ntrue\n\njulia> ⊤ ∧ ⊥ == ⊥ # logical and\ntrue\n\njulia> ⊤ ∨ ⊥ == ⊤ # logical or\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several more operators, which will be discussed later. Use the arity function to determine the number of arguments for an operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> arity(contradiction)\n0\n\njulia> arity(not)\n1\n\njulia> arity(and)\n2","category":"page"},{"location":"tutorial/#Propositions","page":"Tutorial","title":"Propositions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A Proposition is a statement that can be either true or false. For example, \"Logic is fun\" is a proposition because it may be true for you but false for someone else. Note that the proposition exists on its own, regardless of whether or not it is known to be true or false.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p = Atom(\"Logic is fun\")\nAtom(\"Logic is fun\")\n\njulia> q = Atom(\"Julia is awesome\")\nAtom(\"Julia is awesome\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also perform operations on propositions. In a written form, we can negate the above proposition by saying \"Logic is not fun\". We could combine two propositions using another operator, such as \"Logic is fun and Julia is awesome\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> r = ¬p\n¬Atom(\"Logic is fun\")\n\njulia> s = p ∧ q\nAtom(\"Logic is fun\") ∧ Atom(\"Julia is awesome\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An Atomic proposition is such that it has not been operated on and is not composed of any other propositions. Thus the first proposition, \"Logic is fun\", is atomic. A Compound proposition is any proposition that is not an atom. \"Logic is not fun\" and \"Logic is fun and Julia is awesome\" are Compound propositions. A Literal proposition is a proposition that is either an atom or its negation. \"Logic is fun\" and \"Logic is not fun\" are literals. Since propositions can be nested arbitrarily, a Tree structure can be used to represent them.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> p isa Atom && q isa Atom && Atom <: Proposition\ntrue\n\njulia> r isa Compound && s isa Compound && Compound <: Proposition\ntrue\n\njulia> r isa Literal && Literal <: Compound\ntrue\n\njulia> s isa Tree && Tree <: Compound\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In mathematics, it's useful to replace individual numbers with a symbolic variable that can represent any number. Since these propositions are for demonstration and could really be any proposition, we will do the same with our propositions p and q. To do so, we will use the @atoms macro to define each atomic proposition as a constant. Alternatively, you can construct this kind of atom with a Symbol: Atom(:p).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @atoms p q\n2-element Vector{Atom{Symbol}}:\n p\n q\n\njulia> p\np\n\njulia> q\nq\n\njulia> r = ¬p\n¬p\n\njulia> s = p ∧ q\np ∧ q","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function atoms returns a vector of each unique Atom in a proposition.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> atoms(r)\n1-element Vector{Atom{Symbol}}:\n p\n\njulia> atoms(s)\n2-element Vector{Atom}:\n p\n q","category":"page"},{"location":"tutorial/#Semantics","page":"Tutorial","title":"Semantics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We know that since these are propositions, they can be true or false. If you think that \"Logic is fun\", it would be invalid to assign it the valuation false. So the proposition p is true if you think that \"Logic is fun\" and is false otherwise. If we assign the value true to the proposition \"Logic is fun\", then we know that the validity of the proposition \"Logic is fun and Julia is awesome\" depends on whether or not \"Julia is awesome\". If \"Julia is awesome\" is assigned false, then the conjunction of the two propositions is false. Use the interpret function to assign meaning to atomic propositions and then simplify the proposition.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> interpret(s, p => ⊤)\n(q)\n\njulia> interpret(s, p => ⊤, q => ⊥)\ncontradiction (generic function with 1 method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Assigning meaning to any number of atomic propositions is called a Valuation. Since p can only be true or false, it has two possible valuations. r doesn't depend on any other propositions, because it is just a negation of p. Thus, it also has two possible valuations. However, the valuation and result of evaluating it are not longer the same. Since r == ¬p, if p is assigned true, then r is determined to be false, and vice versa. An interpretation is the truth values of any number of propositions determined by a given valuation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(valuations(r))\n2-element Vector{Vector}:\n Pair{Atom{Symbol}, typeof(tautology)}[Atom(:p) => PAndQ.tautology]\n Pair{Atom{Symbol}, typeof(contradiction)}[Atom(:p) => PAndQ.contradiction]\n\njulia> collect(interpretations(r))\n2-element Vector{Function}:\n contradiction (generic function with 1 method)\n tautology (generic function with 1 method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since s contains two atomic propositions, there are four valuations: p is true and q is true, p is false and q is true, p is true and q is false, and p is false and q is false. Each additional atomic proposition in a proposition doubles the number of possible valuations. Mathematically, there are 2 ^ n valuations where n = length(atoms(p)). Since each interpretation depends on a valuation, the number of valuations and interpretations are equal.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> n = length(atoms(s))\n2\n\njulia> length(valuations(s)) == length(interpretations(s)) == 2 ^ n == 4\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are often interested in valuations that result in a valid interpretation. This is accomplished with the solve function. The proposition s is the conjunction of p and p, so it is only true if both p and q are true. Each of the other three possible valuations are invalid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(solve(s, tautology))\n1-element Vector{Vector{Pair{Atom{Symbol}, typeof(tautology)}}}:\n [Atom(:p) => PAndQ.tautology, Atom(:q) => PAndQ.tautology]\n\njulia> collect(solve(s, contradiction))\n3-element Vector{Vector}:\n Pair{Atom{Symbol}}[Atom(:p) => PAndQ.contradiction, Atom(:q) => PAndQ.tautology]\n Pair{Atom{Symbol}}[Atom(:p) => PAndQ.tautology, Atom(:q) => PAndQ.contradiction]\n Pair{Atom{Symbol}, typeof(contradiction)}[Atom(:p) => PAndQ.contradiction, Atom(:q) => PAndQ.contradiction]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition is_satisfiable if there is at least one valid interpretation. A proposition is_falsifiable if there is at least one invalid interpretation. A proposition is_contingency if it is both satisfiable and falsifiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> is_satisfiable(s) && is_falsifiable(s) && is_contingency(s)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A proposition is a tautology if every possible interpretation is true. A proposition is a contradiction if every possible interpretation is false. For example, p ∧ ¬p is always interpreted as false because either p or ¬p must be false. p ∨ ¬p is always interpreted as true because either p or ¬p must be true. Use the functions is_tautology, is_contradiction, and is_truth to check whether a proposition is logically equivalent to a truth value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> t = p ∧ ¬p\np ∧ ¬p\n\njulia> u = p ∨ ¬p\np ∨ ¬p\n\njulia> collect(interpretations(t))\n2-element Vector{typeof(contradiction)}:\n contradiction (generic function with 1 method)\n contradiction (generic function with 1 method)\n\njulia> collect(interpretations(u))\n2-element Vector{typeof(tautology)}:\n tautology (generic function with 1 method)\n tautology (generic function with 1 method)\n\njulia> is_contradiction(t) && is_tautology(u)\ntrue\n\njulia> is_truth(t) && is_truth(u)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Two propositions are logically equivalent if their interpretation is equivalent for every possible valuation. For example, the propositions ¬(¬p ∧ ¬q) and p ∨ q are logically equivalent. In fact, the or operator is implemented this way. Use == to test that two propositions are logically equivalent. Use === to test that two propositions have an identical internal representation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ¬(¬p ∧ ¬q) == p ∨ q\ntrue\n\njulia> ¬(¬p ∧ ¬q) === p ∨ q\nfalse","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It would also be helpful to enumerate each valuation and interpretation in a visual format. This is accomplished by creating a TruthTable. A truth table is a table where each column in the header identifies a proposition, and each row contains an interpretation (including the valuation of atomic propositions). To demonstrate these, we will use the xor operator, represented by the symbol ⊻. Try to understand the meaning of this operator as it is interpreted with different valuations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TruthTable(p ⊻ q)\n┌──────┬──────┬───────┐\n│ p    │ q    │ p ⊻ q │\n│ Atom │ Atom │ Tree  │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊤    │ ⊥     │\n│ ⊥    │ ⊤    │ ⊤     │\n├──────┼──────┼───────┤\n│ ⊤    │ ⊥    │ ⊤     │\n│ ⊥    │ ⊥    │ ⊥     │\n└──────┴──────┴───────┘","category":"page"}]
}
