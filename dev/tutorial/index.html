<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PAQ.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PAQ.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PAQ.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Propositional-Logic"><span>Propositional Logic</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Minimization"><span>Minimization</span></a></li><li><a class="tocitem" href="#Logically-Equivalent-Representations"><span>Logically Equivalent Representations</span></a></li><li><a class="tocitem" href="#Order-of-Operations"><span>Order of Operations</span></a></li><li><a class="tocitem" href="#Associativity"><span>Associativity</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/abstract_types/">Abstract Types</a></li><li><a class="tocitem" href="../manual/propositional_logic/">Propositional Logic</a></li><li><a class="tocitem" href="../manual/boolean_operators/">Boolean Operators</a></li><li><a class="tocitem" href="../manual/semantics/">Semantics</a></li><li><a class="tocitem" href="../manual/pretty_printing/">Pretty Printing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakobjpeters/PAQ.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Propositional-Logic"><a class="docs-heading-anchor" href="#Propositional-Logic">Propositional Logic</a><a id="Propositional-Logic-1"></a><a class="docs-heading-anchor-permalink" href="#Propositional-Logic" title="Permalink"></a></h2><h3 id="Primitive-Propositions"><a class="docs-heading-anchor" href="#Primitive-Propositions">Primitive Propositions</a><a id="Primitive-Propositions-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-Propositions" title="Permalink"></a></h3><p>A primitive proposition is a statement that can be true or false. For example, the statement &quot;Logic is fun&quot; may be true for you but false for someone else. <a href="../manual/propositional_logic/#PAQ.Primitive"><code>Primitive</code></a> propositions can be expressed as:</p><pre><code class="language-julia-repl hljs">julia&gt; p = Primitive(&quot;Logic is fun&quot;)
Primitive:
  Logic is fun

julia&gt; q = Primitive(&quot;Julia is awesome&quot;)
Primitive:
  Julia is awesome</code></pre><h3 id="Compound-Propositions"><a class="docs-heading-anchor" href="#Compound-Propositions">Compound Propositions</a><a id="Compound-Propositions-1"></a><a class="docs-heading-anchor-permalink" href="#Compound-Propositions" title="Permalink"></a></h3><p>Since <code>p</code> can be true or false, we can form other logical statements that depends on <code>p</code>&#39;s truth value. These statements use logical connectives and are called <a href="../manual/abstract_types/#PAQ.Compound"><code>Compound</code></a> propositions. To express the proposition that &quot;Logic is not fun&quot;, use the logical <a href="../manual/boolean_operators/#PAQ.not"><code>not</code></a> connective: <code>not(p)</code> or <code>¬p</code>.  If <code>p</code>&#39;s truth value is true, then <code>¬p</code>&#39;s truth value is false, and vice versa. A helpful tool to check a statement&#39;s truth values is <a href="../manual/semantics/#PAQ.@truth_table"><code>@truth_table</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @truth_table ¬p
┌───────────┬─────────┐
│ p         │ ¬p      │
│ Primitive │ Literal │
│ &quot;p&quot;       │         │
├───────────┼─────────┤
│ ⊤         │ ⊥       │
│ ⊥         │ ⊤       │
└───────────┴─────────┘</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For now, think of the symbols <code>⊤</code> and <code>⊥</code> as <em>true</em> and <em>false</em>, respectively. An exact definition of them will be given in a couple of paragraphs.</p></div></div><p>Statements can also depend on multiple primitive propositions. The logical <a href="../manual/boolean_operators/#PAQ.and"><code>and</code></a> connective is true when both <code>p</code> and <code>q</code> are true and is false otherwise. This is expressed as <code>and(p, q)</code>, <code>∧(p, q)</code>, or <code>p ∧ q</code>. Repeatedly combining the connectives <code>not</code> and <code>and</code> can produce any possible truth table. As such, they are referred to as <a href="https://en.wikipedia.org/wiki/Functional_completeness">functionally complete</a>. For example, the connective <a href="../manual/boolean_operators/#PAQ.or"><code>or</code></a> is equivalent to <code>¬(¬p ∧ ¬q)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @truth_table or(p, q) ¬(¬p ∧ ¬q)
┌───────────┬───────────┬──────────────────────┐
│ p         │ q         │ or(p, q), ¬(¬p ∧ ¬q) │
│ Primitive │ Primitive │ Propositional        │
│ &quot;p&quot;       │ &quot;q&quot;       │                      │
├───────────┼───────────┼──────────────────────┤
│ ⊤         │ ⊤         │ ⊤                    │
│ ⊤         │ ⊥         │ ⊤                    │
├───────────┼───────────┼──────────────────────┤
│ ⊥         │ ⊤         │ ⊤                    │
│ ⊥         │ ⊥         │ ⊥                    │
└───────────┴───────────┴──────────────────────┘</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The first two cells of each row in this table is an <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">interpretation</a>, which allows the truth value of the corresponding last cell to be determined. More generally, interpretations are an assignment of meaning to logical symbols. A function that maps logical symbols or formulae to their meaning is called a <a href="https://en.wikipedia.org/wiki/Valuation_(logic)">valuation</a> function.</p></div></div><h3 id="Truth-Values"><a class="docs-heading-anchor" href="#Truth-Values">Truth Values</a><a id="Truth-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Truth-Values" title="Permalink"></a></h3><p>Consider the proposition <code>p ∧ ¬p</code>. Using the earlier example, this states that both &quot;Logic is fun&quot; and &quot;Logic is not fun&quot;. Since these statements are mutually exclusive, their conjunction forms a <a href="../manual/propositional_logic/#PAQ.contradiction"><code>contradiction</code></a>. A contradiction is a statement that is false in every possible interpretation. In other words, the statement <code>p ∧ ¬p</code> is false regardless of whether <code>p</code>&#39;s truth value is true or false. A contradiction can be expressed as <code>contradiction</code> or with the symbol <code>⊥</code>. The negation of a contradiction, in this case <code>¬(p ∧ ¬p)</code>, results in a statement that is true in every possible interpretation. This is called a <a href="../manual/propositional_logic/#PAQ.tautology"><code>tautology</code></a> and can be expressed as <code>tautology</code> or with the symbol <code>⊤</code>. Contradiction and tautology symbols are also be used to express the concepts of <em>true</em> and <em>false</em>, respectively.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Note that <code>⊤</code> is a Unicode symbol, not an uppercase &quot;t&quot;. The documentation for each symbol provides instructions on how to type it. For example, <code>⊤</code> can be typed by <code>\top&lt;tab&gt;</code>. See also Julia&#39;s documentation on <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">Unicode Input</a>.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; ¬⊥
Truth:
  ⊤

julia&gt; p ∧ ⊤ # identity law
Primitive:
  p

julia&gt; p ∧ ⊥ # domination law
Truth:
  ⊥</code></pre><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Language
├─ Compound
│  ├─ Literal
│  ├─ Normal
│  └─ Propositional
├─ Contingency
├─ Primitive
└─ Truth</code></pre><p>In Backus-Naur Form (BNF), <a href="../manual/propositional_logic/#PAQ.Propositional"><code>Propositional</code></a> is defined inductively as:</p><pre><code class="nohighlight hljs">ϕ ::= p | ¬ψ | ψ ∧ ψ</code></pre><p>Since we may want to refer to compound statements defined differently, ψ has the abstract type <a href="../manual/abstract_types/#PAQ.Compound"><code>Compound</code></a> rather than being a <code>Propositional</code>.</p><p>Remember, every infix operator is a function. They also each have a written alias.</p><pre><code class="language-julia-repl hljs">julia&gt; p ∧ q === ∧(p, q) === and(p, q)
true</code></pre><h2 id="Minimization"><a class="docs-heading-anchor" href="#Minimization">Minimization</a><a id="Minimization-1"></a><a class="docs-heading-anchor-permalink" href="#Minimization" title="Permalink"></a></h2><h2 id="Logically-Equivalent-Representations"><a class="docs-heading-anchor" href="#Logically-Equivalent-Representations">Logically Equivalent Representations</a><a id="Logically-Equivalent-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Logically-Equivalent-Representations" title="Permalink"></a></h2><h2 id="Order-of-Operations"><a class="docs-heading-anchor" href="#Order-of-Operations">Order of Operations</a><a id="Order-of-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Order-of-Operations" title="Permalink"></a></h2><h2 id="Associativity"><a class="docs-heading-anchor" href="#Associativity">Associativity</a><a id="Associativity-1"></a><a class="docs-heading-anchor-permalink" href="#Associativity" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../manual/abstract_types/">Abstract Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 December 2022 10:43">Monday 19 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
